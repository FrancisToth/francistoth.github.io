<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">

    <title>Introduction to Functional Programming - by Francis Toth</title>

    <meta name="description" content="A framework for easily creating beautiful presentations using HTML">
    <meta name="author" content="Hakim El Hattab">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/custom.css">
    <link rel="stylesheet" href="css/theme/francis.css" id="theme">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
</head>

<body>


<aside style="display: block; position: fixed; bottom: 10px; right: 10px; z-index: 30;">
    <a href="http://www.yoppworks.com"><img src="images/yoppworks.logo-corner-dark.png"  height="30"></a>
</aside>
<aside style="display: block; position: fixed; bottom: 0px; left: 10px; z-index: 30;">
    <a href="https://www.meetup.com/lambda-montreal/"><img src="images/logo.lambda_montreal.jpeg"  height="100"></a>
</aside>

<div class="reveal">
    <div class="slides">
        <section>
            <aside class="notes">
                Hello everyone,<br/>

                First of all, thank you all for being here tonight. To be honest I wasn't expecting so many people, so I'm glad to
                see so much interest in Functional Programming. I've read somewhere that when you start understanding Functional
                Programming, you become unable to explain it. Well, this is my second attempt, and I really hope you'll
                be satisfied with it.
                <br/><br/>
                Before starting, how many of you guys are not familiar with Scala at all? Well, the examples in this talk are all in Scala
                but if you are not familiar with the language, that should be ok. In any case, if during this talk, there is
                something you don't understand, please interrupt me, I'll be glad to help you.
                <br/><br/>
                Secondly, I'm far from being a Functional Programming expert and I may not be accurate sometime. If this
                happens, and if you think you can contribute to this talk, please do. You will be very welcome.
                <br/><br/>
                By the way, how many of you guys consider themselves as Functional Programming experts? Same question but for those
                who feel like intermediate? Alright, any beginners? So, I don't know about you guys, but the first time I've learnt
                about Functional Programming, It sounded like jibberish to me. Functional Programming can be indeed very
                obscure some time as it has deep abstract mathematical roots. Fortunately, we won't cover those today
                and will instead tackle Functional Programming from a very practical angle.
                <br/><br/>
                Alright, let's get this started.
            </aside>

            <h2 style="display: inline-block;"><img style="vertical-align: text-bottom; margin: -2px 0; border: 0; background-color: #243044" src="images/intro_to_fp/haskell-logo.png" width="11%"/> Functional Programming</h2>
        </section>
        <section>
            <h2>Expressions Oriented</h2>
            <section data-transition="none none">
                <aside class="notes">
                    Ok so first of all, Functional Programming is based on expressions. An expression, is a finite combination
                    of symbols well-formed according a set of rules which produces a value. Those symbols can be
                    constants, operators, or functions.
                    <br/><br/>
                    In Functional code, an expression has to be referentially transparent. In other words, replacing it
                    by the value it produces should not affect a program's output in any way. This is referred to the
                    substitution model which is something you are actually all familiar with since first grade.
                    <br/><br/>
                    In Functional Programming, expressions are indeed evaluated just like mathematical
                    expressions. So the evaluation process of an expression, goes on and on until it cannot be reduced
                    no more and produces a value.
                </aside>
                <pre><code data-trim data-noescape style="font-size: 1.5em; line-height: 1.2em">42
x = 41 + 1
y = x * 2
z = add(x, 2)</code></pre>
                <pre class="fragment"><code data-trim data-noescape style="font-size: 1.5em; line-height: 1.2em">x = 42
y = x + 1 == 42 + 1</code></pre>
                <pre class="fragment"><code data-trim data-noescape style="font-size: 1.5em; line-height: 1.2em">x = (2 * 2) + (3 * 4)
x = 2 * 2 + 3 * 4
x = 4 + 12
x = 16</code></pre>
            </section>

            <section data-transition="none none">
                <aside class="notes">
                    What about functions now? We just said that functions are also expressions right? Therefore they
                    also have to be referentially transparent. So how does a Function can hold this contract?
                    <br/><br/>
                    Well in order to be Referentially Transparent, a Function must have three properties. It has to be
                    <br/><br/>
                    <b>Total</b>: that is every input has to be mapped with an output<br/>
                    <b>Pure</b>: A function's only effect is the computation of its returning value<br/>
                    <b>Deterministic</b>: Given the same input, a function has to always return the same output<br/>
                    <br/><br/>
                    In the next slides, we'll see what prevents a function to hold these rules, along with the solutions
                    to enforce them.
                </aside>
                <ul>
                    <li class="fragment"><span style="color:#42BAE8"><b>Total</b></span>: A function must yield a value for <i>every</i> possible input.</li>
                    <li class="fragment"><span style="color:#42BAE8"><b>Pure</b></span>: A function’s only effect must be the computation of its return value</li>
                    <li class="fragment"><span style="color:#42BAE8"><b>Deterministic</b></span>: A function must yield the <i>same</i> value for the <i>same</i> input.
                        <br/><br/><br/>
                        <div style="text-align: right"><span style="font-size: 20px">
                            Taken from <i>"A Beginner-Friendly Tour through Functional Programming in Scala"</i>.<br/><b>John A De Goes</b>.
                        </span></div>
                    </li>
                </ul>
            </section>
        </section>
        <section data-transition="none none">
            <h2>Inputs / Outputs</h2>
            <section data-transition="none none">
                <aside class="notes">
                    Let's hold on a minute and think about what are the inputs and the outputs of a function.
                    <br/><br/>
                    The function 'foo' takes a String and returns an Integer. Simple enough. Now what about the 'bar'
                    function? Just like 'foo', it takes a String, returns an Integer but also outputs another String in
                    the console. So 'bar' has two outputs: the resulting integer and the String written in the console.
                    In Functional code, this is what we call a side-effect. Let's see some others examples:
                </aside>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.5em; line-height: 1.2em">
def foo(number: String): Int = number.toInt

def bar(input: String): Int = { 
  println("performing bar")
  foo(input)
}</code></pre>
            </section>
        </section>
        <section data-transition="none none">
            <h2>Side Effects</h2>
            <section data-transition="none none">
                <aside class="notes">
                    In those examples, beside returning a value, those two functions may respectfully throw an exception
                    or return a null value.
                    <br/><br/>
                    The problem with exceptions is that there is absolutely no guarantee about where they will occur.
                    So they can occur everywhere. Just like with nulls, exceptions lead you to set up aggressive
                    exception handling, even in cases where it doesn't make any sense.
                    <br/><br/>
                    Those who worked on wide legacy codebases know what I am talking about. You know that situation
                    when you ask a guy why he is using a try-catch for no reason, and the guy answers, "Well, you know,
                    just in case of". Exceptions and Nulls prevent a function from being total, as given an input, they
                    may not return anything at all.
                </aside>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
def parse(integer: String): Int = {
  if(numberIsNotAString(number)) {
    throw new IllegalArgumentException(/*...*/)
  } else {
    // parsing logic returning parsed integer
  }
}</code></pre>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
def ask(question: String): String = {
  if(question == "What's the meaning of life?") {
    "42"
  else
    null // does not compile in Scala
}</code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    Another example, so here, the add1 function is responsible for incrementing by 2 the integer passed in argument.
                    But once called, it also gets the value of n, and increments it. Referential transparency is clearly
                    broken here as replacing the add2 function call by its resulting expression changes the output of
                    the program. So this function's effect cannot be obtained just by computing its resulting value
                    which means it's not pure.
                </aside>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
var n = 0
def add2(x: Int): Int = { 
  n = n + 1
  x + 2
}
// ...
val y = add2(40)
assert(n == 1)</code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    Last example, in this case, we still have a situation where exceptions could happen, but this
                    time, the problem could occur at any time during the call, as we rely on the local filesystem.
                    <br/><br/>
                    For various reasons, this function may throw an exception, maybe because the file is not available or
                    whatever else, which therefore prevents the function from always returning the same value given the
                    same input. Non-determinism is another solid way to break Referential Transparency.
                </aside>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
def readIntegerFromFile(filePath: String): Int = { 
  // throws exceptions
  val content = readFromFile(filePath)
  // ...
}</code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    More generally, a side-effect is an observable interaction that a function has with its callers or
                    the outside world besides returning a value.
                    <br/><br/>
                    In other words, whenever a function requires or outputs more than what is suggested by its signature,
                    chances are that a side-effect is created, which breaks Referential Transparency along with the
                    substitution model. So Referential Transparency is not about programming without mutable state, it's
                    about whether or not a function call needs something which is not part of its argument list, or
                    outputs something that is not part of its returned value.
                </aside>
                <div style="text-align: justify">
                <i>"A function having a side-effect is a function which has an observable interaction with its calling
                    functions or the outside world besides returning a value"</i><br/>
                    <div style="text-align: right">Wikipedia.</div>
                </div>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    Scala for example, contains some functions which implementation have been optimized using mutable
                    variables. Despite that, these functions are still considered referentially transparent as they do
                    exactly what their signatures suggest. Pure Functional Programming does not allow mutable
                    variables, but from a pragmatic point of view, this sounds alright.
                </aside>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
// List.scala
override def drop(n: Int): List[A] = {
  var these = this
  var count = n
  while (!these.isEmpty && count > 0) {
    these = these.tail
    count -= 1
  }
  these
}</code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    Overall Side-effects introduce complexity as there is no way for you to know what a function
                    requires or does without looking inside it. When it comes to testing, it's even worse. Unlike a
                    circuit board, you can’t just plug into a function's inputs and check its outputs. You actually have
                    to break open the code, figure out its hidden causes and effects, and simulate the world it’s
                    supposed to exist in.
                    <br/><br/>
                    So Side-effects prevent functions from being total, deterministic and pure, and therefore referentially
                    transparent.
                    <br/><br/>
                    Now, the question is, how can we make sure that our functions are Referentially Transparent while
                    keeping our program useful? I mean, no matter how you design a program, side effects will be
                    required at some point, either to get some data from the user or to output some result. So how can
                    we reconcile side-effects with Referential Transparency?
                </aside>
                <img style="vertical-align: text-bottom;margin-top:40px; border: 0; background-color: #243044"
                     src="images/intro_to_fp/side-effects.png" width="330"/>
            </section>
        </section>
        <section>
            <h2>Total Functions</h2>
            <span style="font-size: 30px">Total: A function must yield a value for <i>every</i> possible input.</span>
            <section data-transition="none none">
                <aside class="notes">
                    So first of all, let's see how we can make sure that our functions are total. As we've seen it
                    earlier, a total function must yield a value for every possible input. The problem here is that
                    these functions may never return if they are passed arguments leading them to throw an exception
                    or to return a null.<br/><br/>

                    So the whole challenge here is to model these situations so we can make them explicit.
                </aside>
                <div style="margin-top: 60px">&nbsp;</div>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
def parse(integer: String): Int = {
  if(numberIsNotAString(number)) {
    throw new IllegalArgumentException(/*...*/)
  } else { /* parsing logic */}
}</code></pre>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
def ask(question: String): String = {
  if(question == "What's the meaning of life?") {
    "42"
  else
    null // does not compile in Scala
}</code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    So let's create some types. Either represents a value that may have one type or the other. In
                    our first example, we can now tell the caller that the parse function may return an error in some
                    cases or an integer. So no matter what happens, the parse function will always return something
                    which makes it total, as for every possible input, it will return an output.<br/><br/>

                    In the same way, the ask function returns now a Maybe, which indicates that a question may not have
                    an appropriate answer.<br/><br/>

                    So the solution consists in bringing the complexity to the surface, and in informing the caller about all
                    the situations that may happen during the function call by refining the result's type.

                    This is great, but how are we supposed now to get the value obtained with an Either or a Maybe.
                    Well we can use Pattern Matching.
                </aside>
                <div style="margin-top: 60px">&nbsp;</div>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
trait Either[A, B]
case class Left[A, B](a: A)  extends Either[A, B]
case class Right[A, B](b: B) extends Either[A, B]

def parse(integer: String): Either[Exception, Int]</code></pre>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
trait Maybe[A]
case class Some[A](a: A) extends Maybe[A]
case class None[A]()     extends Maybe[A]

def ask(question: String): Maybe[String]
                </code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    Briefly, Pattern Matching is way to decompose a data-structure using patterns, and to bind values to
                    successful matches. Here's an example.<br/><br/>

                    So we have a case class Foo composed of two fields, a String and an Integer. On the next line, we
                    instantiate the class and attempt to match the instance to a series of pattern. The first matching
                    attempt succeed, and therefore, bar = 42 is printed.<br/><br/>

                    In the next example, the second field has been initialized to 74. As the first pattern does not
                    match, we go to the next matching attempt, which succeed. If none of these patterns match, the last
                    pattern is used as default case.
                </aside>
                <div style="margin-top: 60px">&nbsp;</div>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
case class Foo(first: String, second: Int)
                </code></pre>
                <pre class="fragment"><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
Foo("bar", 42) match {
  case Foo(x, 42)    => println(s"$x == 42")
  case Foo("bar", _) => println(s"bar != 42")
  case _             => println("Default case")
}
                </code></pre>
                <pre class="fragment"><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
Foo("bar", 74) match {
  case Foo(x, 42)    => println(s"$x == 42")
  case Foo("bar", _) => println(s"bar != 42")
  case _             => println("Default case")
}
                </code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    Back to our example, using Pattern Matching we could now do something like this. Any question
                    regarding what we've just seen? Alright, what about Purity now?
                </aside>
                <div style="margin-top: 60px">&nbsp;</div>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
def ask(question: String): Maybe[String] = {
  if(question == "What's the meaning of life?") {
    Some("42")
  else
    None
}

ask("What's the meaning of life?") match {
  case Some(answer)  =>
    println(s"The answer is: $answer")
  case None          =>
    println("I cannot answer this question.")
}
                </code></pre>
            </section>
        </section>
        <section>
            <h2>Pure Functions</h2>
            <span style="font-size: 30px">Pure: A function’s only effect must be the computation of its return value</span>
            <section data-transition="none none">
                <aside class="notes">
                    So we want to ensure that our functions always return an expression that capture all the effects
                    it generates. In this case, we are updating a variable outside the scope of the add1 function, which makes
                    it a global variable from the function's point of view. So the add1 function has two outputs,
                    the integer provided incremented by 1 along with a state update.<br/><br/>

                    Just like in the previous example, the solution consists in making this explicit in the signature.
                </aside>
                <div style="margin-top: 60px">&nbsp;</div>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
var n = 0
def add2(x: Int): Int = { 
  n = n + 1
  x + 2
}
// ...
val y = add2(40)
assert(n == 1)
                </code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    The interaction between the input and the output is now clear for the caller. So, instead of
                    modifying the variable n, we just create a function that increment and return both integers passed
                    in arguments, making the variable n useless. The add2 function is now pure as its result captures
                    all the effects it generates.
                </aside>
                <div style="margin-top: 60px">&nbsp;</div>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
def add2(x: Int, n: Int): (Int, Int) = { 
  (x + 2, n + 1)
}
// ...
val (y, n) = add2(40, 0)
assert(n == 1)
                </code></pre>
            </section>
        </section>
        <section>
            <h2>Deterministic Functions</h2>
            <span style="font-size: 30px">Deterministic: A function must yield the <i>same</i> output for the <i>same</i> input.</span>
            <section data-transition="none none">
                <aside class="notes">
                    Finally, in order to be Referentially Transparent, a function has to be deterministic. Given the same
                    value, it should always return the same output. This works very well with simple functions like the
                    one in the previous example, but what about functions involving IO, like database queries or
                    file-system interactions.<br/><br/>

                    The problem is that this function cannot be deterministic as it interacts with a potentially
                    unstable environment. So it could crash for many different reasons, or even run forever. Fact is,
                    you cannot control everything, so instead of trying, let's think about another approach.<br/><br/>

                    Once again, let's think about how this problem could be modeled.
                </aside>
                <div style="margin-top: 60px">&nbsp;</div>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
val s: String = readInput()
printOnConsole(s)
                </code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    Just like earlier, we've created some types representing our domain. The class Read represents
                    an interaction with the console, which at some point in the future will return a String we can
                    process. This is what the process function is for.<br/><br/>

                    Secondly, we've created a type that represents another interaction, which once processed, write
                    a line in the console. Now back to our problem, we can now write something like this.<br/><br/>

                    Which is really cool.

                    <!--Now just for the sake of it, how would we represent a program that reads a-->
                    <!--line and prints it back on the console over and over without stopping. Well using recursion.-->
                    <!--That's really neat. No while loop required here.<br/><br/>-->

                    Alright, but you may say, this looks pretty nice, but so far nothing is performed. Well, wasn't
                    that the point of doing all of this? Earlier the problem was about figuring out how this code
                    could be represented without performing any side effect. This is a solution to this problem. This
                    allows to represent the computation we want to run without involving any side effect.
                </aside>
                <div style="margin-top: 60px">&nbsp;</div>
                <pre style="width: 100%"><code class="scala" data-trim data-noescape style="font-size: 1.2em; line-height: 1.2em">
trait ConsoleIO
case class Read(process: String => ConsoleIO) extends ConsoleIO
case class Write(line: String, then: ConsoleIO) extends ConsoleIO
case object End extends ConsoleIO
                </code></pre>
                <pre class="fragment" style="width: 100%"><code class="scala" data-trim data-noescape style="font-size: 1.2em; line-height: 1.2em">
val program: ConsoleIO = Read { line => Write(line, End) }
                </code></pre>

                <pre class="fragment" style="width: 100%"><code class="scala" data-trim data-noescape style="font-size: 1.2em; line-height: 1.2em">
val loop: ConsoleIO = Read { line => Write(line, loop) }
                </code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    Now if we want to run this computation, we need an interpreter. This interpreter is responsible
                    for executing the program we've created and for performing any side effect needed.

                    What did we just do here ? Well it's very simple. We kept the specification of the problem
                    free from side-effects, and therefore Referentially transparent. This allows us to compose it
                    in a pure way without dealing with any issue related to its execution. So, how can Referential
                    Transparency be reconciled with IO?
                </aside>
                <div style="margin-top: 60px">&nbsp;</div>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.2em; line-height: 1.2em">
def interpret(program: ConsoleIO): Unit = program match {
  case Read(process) => interpret(process(readLine()))
  case Write(line, next) => println(line); interpret(next)
  case End => println("Done !")
}
                </code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    Well just like with many software engineering problems, it's all about separating the concerns
                    properly. First, we declare the computations required to solve a problem and only then, we decide
                    to execute those using an interpreter. So the idea is to make a clear distinction between the
                    evaluation of a program and its execution, or said differently, to distinguish the 'what' from the
                    'how'.<br/><br/>

                    When you think about it, this is a very common software best practice. Anyone remembers of the
                    Command pattern? Well, this is exactly the same idea. This pattern makes it easy to construct
                    commands sequences which execution is delegated to an interpreter that can be implemented in
                    different ways.<br/><br/>

                    This idea is also the one suggested by the Onion Architecture, where the core of the onion is
                    responsible for setting up the business logic which is then performed by the outer layers. This
                    allows multiple interpretations of the same logic while keeping a high level of composition and
                    flexibility. In this case, we could for example write another interpreter that would interact
                    with a file instead of the console.
                </aside>
                <div style="margin-top: 60px">&nbsp;</div>
                <pre style="width: 100%"><code class="scala" data-trim data-noescape style="font-size: 1.2em; line-height: 1.2em">
trait ConsoleIO
case class Read(process: String => ConsoleIO) extends ConsoleIO
case class Write(line: String, then: ConsoleIO) extends ConsoleIO
case object End extends ConsoleIO

val program: ConsoleIO = Read { line => Write(line) }
interpret(program)
                </code></pre>
                <pre style="width: 100%"><code class="scala" data-trim data-noescape style="font-size: 1.2em; line-height: 1.2em">
def interpret(program: ConsoleIO): Unit = program match {
  case Read(process) => interpret(process(readLine()))
  case Write(line, next) => println(line); interpret(next)
  case End => println("Done !")
}
                </code></pre>
            </section>
        </section>
        <section data-transition="none none">
            <aside class="notes">
                So in order to be Referentially Transparent, a function has to be Total, Pure and Deterministic. We've
                also learnt that side-effects prevent a function to be referentially transparent if they are not managed
                properly.<br/><br/>

                For this reason, they have to be encapsulated and be explicit to the caller. This can be achieved by
                refining a function's signature and by separating the 'what' from the 'how'.<br/><br/>

                So Referential Transparency is a powerful tool to organize code, to separate a concept from how it's
                actually being implemented, and to expose the effects generated at runtime by a function. But that's
                actually far from being the end. Indeed, Referential Transparency deeply affects the way we design
                programs<br/><br/>
            </aside>
            <ul style="list-style-type: none;">
                <li><ul>
                    <li><span style="font-size: 30px;color: #42BAE8;">Total</span>: A function must yield a value for <i>every</i> possible input.</li>
                    <li><span style="font-size: 30px;color: #42BAE8;">Pure</span>: A function only effect must be the computation of its return value</li>
                    <li><span style="font-size: 30px;color: #42BAE8;">Deterministic</span>: A function must yield the <i>same</i> value for the <i>same</i> input.</li>
                </ul></li>
                <li style="list-style-type: none;">&nbsp;</li>
                <li><ul>
                    <li>Side effects break Referential Transparency :(</li>
                    <li>Side-Effects must be explicit</li>
                    <li>Separate the 'what' from the 'how'</li>
                </ul></li>
            </ul>
        </section>
        <!--15:47-->
<!--#################################################################################################################-->
<!--#################################################################################################################-->
<!--#################################################################################################################-->
        <section data-transition="none none">
            <h2>Order of evaluation</h2>
            <section data-transition="none none">
                <aside class="notes">
                    First of all, Referential Transparency changes the way a program is evaluated. In Imperative
                    programming, the order of execution of each instruction of a program cannot be altered in any way.
                    Simply, because each of them may interact with the global state of the program, and changing their
                    order of execution may impact the resulting output. This is actually not the case in Functional
                    Programming.<br/><br/>

                    As an expression does not generate any side-effect, the order in which two expressions are evaluated
                    doesn't matter. Here we have two functions, which are respectfully responsible for multiplying the
                    argument by 3 and for incrementing it by one. As those functions are referentially transparent, no matter if
                    we first evaluate f or g, we'll always get a 6 in the end.<br/><br/>
                    <!--As the order of evaluation is irrelevant, the interpreter can now decide about how and when an expression should be executed,-->
                    <!--which creates opportunities for runtime optimizations. In the last piece of code there, an-->
                    <!--interpreter could decide to run those computations in parallel or in sequence, it would not really-->
                    <!--matter, the program would still be specified the same way.-->
                </aside>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
def f(x: Int) = x * 3
def g(y: Int) = y + 1

f(g(1))
                </code></pre>
                <div><table style="width: 100%">
                    <tr>
                        <td>
                            <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
f(g(1))
= f(1+1)
= f(2)
= 2*3
= 6
                            </code></pre>
                        </td>
                        <td>
                            <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
f(g(1))
= g(1)*3
= (1+1)*3
= 2*3
= 6
                            </code></pre>
                        </td>
                    </tr>
                </table></div>
            </section>

            <section data-transition="none none">
                <aside class="notes">
                    Let's quickly look at another example. Given a list of numbers, let's say you'd like to increment
                    each of them by one. How would you do it? One way to solve the problem consists simply into
                    iterating over the list, taking each number one by one, incrementing them sequentially and storing
                    the result in another list. That's the most basic way.<br/><br/>

                    However, as add1 is referentially transparent, and because the order of evaluation does not matter,
                    you can also decide to perform these incrementation operations in parallel. So now may you see
                    why the Big Data field is so much interested by Functional Programming. It's mostly because this
                    paradigm encourages patterns which are easy to distribute and to parallelize.
                </aside>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
val xs = List(1,2,3,4,5)
def add1(x: Int): Int = /* ...*/
                </code></pre>

                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
for(i <- 1 to xs.length) yield add1(i)
                </code></pre>

                <img class="fragment" src="images/intro_to_fp/mapping.png" style="background-color: white">
            </section>
        </section>

        <section data-transition="none none">
            <h2>Explicit Data Dependencies</h2>
            <aside class="notes">
                Just think about how you would make sure this program is correct. In this example, nothing tells you
                that something may go wrong if you switch those expressions. You know this program is correct because
                you are mentally representing the state of the program at runtime, and you know that once
                cracked, the eggs can be safely beaten as their inner state allow it.<br/><br/>

                In Functional Programming on the other hand, a function can only read what it's being provided with and the
                only way it can have an effect on the world is through the value it returns. As a consequence, the data
                dependency graph becomes obvious, and beating eggs before cracking them is no longer an option.<br/><br/>
            </aside>
            <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
val eggs = ...

crackEggs()
beatEggs()
cookOmelette()
            </code></pre>

            <pre class="fragment"><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height:
            1.2em">
val eggs = ...

val crackedEggs = crackEggs(eggs)
val beatenEggs = beatEggs(crackedEggs)
val omelette = cookOmelette(beatenEggs)
            </code></pre>
        </section>

        <section data-transition="none none">
            <h2>Equational Reasoning</h2>
            <aside class="notes">
                Alright, so order of evaluation is no more relevant, side-effects are put aside, data dependencies are
                explicit, what does that give us? Well, the ability to start reasoning about code.<br/><br/>

                First of all, as you can substitute an expression by the value it produces and vice-versa, you can
                prove that one notation is equivalent to another. This is a fundamental principle used in pretty much
                all scientific fields to prove theorems and establish formal proofs. More concretely, this brings you
                to think about alternative forms of code that are equivalent but better and reusable, which is the
                exact definition of refactoring.<br/><br/>

                Secondly, this gives the possibility to start building on some proved assumptions in order to validate
                other assumptions, which is pretty much what the scientific approach is all about. So Referential
                Transparency gives us Equational Reasoning. If you lose that, reasoning about the code is way harder.<br/><br/>

                I mean just think about what would happen if 1 + 1 would be not longer equal to 2. Well, this is
                actually happening every day in the imperative programming world. No wonder that people argue for a
                100% test coverage. Anyway that's another debate.

                I could go on and on listing the benefits provided by Referential Transparency and talk about how it
                makes testings simpler, or about the runtime optimizations that it can provides, but overall there is
                one thing I'd like us to focus on. Referentially Transparency is the fundamental principle of Functional
                Programming, but also of one other critical concept in programming, which is Composition.
            </aside>
            <pre><code data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
(a + b)²
= (a + b) * (a + b)
= a * (a + b) + b * (a + b)
= a² + 2ab + b²
            </code></pre>
        </section>


        <!--<section data-transition="none none">-->
            <!--<h2>Laziness</h2>-->
            <!--<aside class="notes">-->

                <!--All the tools provided by Maths-->

                <!--Now, if evaluation order is no more relevant, one could ask how a functionally oriented compiler-->
                <!--decides when an expression should be resolved or not. Well, it is very simple. It evaluates it only-->
                <!--if it is required. In other words, if an expression is not used to defined the program's output, it is-->
                <!--simply not evaluated at all.<br/>-->

                <!--This is the concept of laziness. As evaluation order is no more relevant, we can decide to push the-->
                <!--evaluation of an expression until it is absolutely required. An imperative language however, would-->
                <!--evaluate the second predicate as it cannot know its context of usage.-->
            <!--</aside>-->
            <!--<pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">-->
<!--val predicate1 = ...-->
<!--lazy val predicate2 = ... // can only be obtained after a heavy computation-->

<!--// predicate2 may not be evaluated ever-->
<!--val result = if(predicate1 && predicate2) { ... }-->
            <!--</code></pre>-->
        <!--</section>-->


        <!--<section data-transition="none none">-->
            <!--<h2>Immutability</h2>-->
            <!--<aside class="notes">-->
                <!--One of the question that comes back over and over whenever Referential Transparency is introduced is-->
                <!--how can a program output anything valuable without using mutable variables. Well, it's actually-->
                <!--pretty easy as long as you follow some rules. Instead of mutating a value, you recreate a value of-->
                <!--the same type and provided it with the value you would like to mutate. I know. There may be some-->
                <!--people here which would argue that this would lead to performance issues. Well, maybe in certain-->
                <!--cases but definitely not in all of them. In the case of collections for example, Functional-->
                <!--Programming advocate for persistent data structures, which are basically shared by various references-->
                <!--while minimizing memory allocation. Secondly, sometime the performance cost can be justified by-->
                <!--the level of correctness of your code.-->
            <!--</aside>-->
        <!--</section>-->




        <section data-transition="none none">
            <h2>Composition</h2>
            <section data-transition="none none">
                <aside class="notes">
                    Composition is the cornerstone of any successful design, and it's usually the lack of it that leads a
                    software to a catastrophe. But what is composition about? Well, as wikipedia states it:<br/><br/>

                    So in other words, composition allows you to assemble and disassemble a set of components depending on
                    what you want to achieve. Now the next question, how do you make a system composable? Well let's
                    take some steps back.
                </aside>
                <div class="fragment" style="text-align: justify">
                    <i>"A highly composable system provides components that can be selected and assembled in various
                    combinations to satisfy specific user requirements."</i><br/>
                    <div style="text-align: right">Wikipedia.</div>
                </div>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    When you were younger, you learnt about the domain of numbers. Later, you also learnt that
                    you can combine those numbers using specific operators, and that the domain of numbers is ruled by
                    laws. Numbers, operators and laws, all together form an algebra. Numbers are actually what we call
                    algebraic data types.<br/><br/>
                </aside>
                <pre><code data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
// Algebraic data types
1, 2, 3...

// Operations
1 + 2 = 3
3 * 2 = 6

// Laws
0 + x = x
1 * x = x
                </code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    In the same way, the domain of booleans is ruled by boolean algebra, where True and False compose
                    the algebraic data types, and where the operators include AND, OR, and NOT. Just like any other
                    algebras, some rules have been established and specify how TRUE and FALSE can be combined.<br/><br/>

                    Another very common example, less related to programming, is Lego blocks. Lego blocks also have
                    their own algebra, and rules which define how one block can be combined with another. Finally,
                    Mathematical Algebra which you probably all know about.<br/><br/>

                    So just like with numbers, booleans or legos, a flexible domain is all about having small reusable
                    blocks that can composed into larger blocks following a set of rules. Once those rules have been
                    established, abstracting and reasoning about a domain becomes possible. And this is why Referential
                    Transparency matters so much. Without Totality, Purity and Determinism, assumptions and laws cannot be
                    established.<br/><br/>

                    So, Algebras, thanks to Referential Transparency, allows us to reason about a domain, and therefore
                    to express more abstract concepts.
                </aside>
                <img src="images/intro_to_fp/booleantable.png" style="background-color: #FFFFFF">
                <img class="fragment" src="images/intro_to_fp/lego-parts.jpg"><br/>
                <span class="fragment" >3y + 5z * 2x + y = 5</span>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    Back to Functional Programming now. Having this concept of Algebra in mind, let's look at how this
                    is concretely implemented. Take the String type for example.<br/><br/>

                    Overall, a String can contain something or be empty. So, in more algebraic terms, EmptyString and
                    NonEmptyString, all together, compose the algebraic datatypes of the domain of Strings. What about
                    the operators? Well, a String can be concatenated with another using the append function. However,
                    there is one important rule here. If you combine an EmptyString with a NonEmptyString, you'll get
                    the same NonEmptyString you provided in the first place. And this actually works in both ways.<br/><br/>

                    Well, these properties happen to be also present in the domain of Collections. You can combine two
                    collections, but if you combine an empty collection with another one, you'll get the same non-empty
                    collection you provided in the first place.
                </aside>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.5em; line-height: 1.2em">
val emptyString = ""
val nonEmptyString = "this is not empty"

emptyString + nonEmptyString == nonEmptyString
nonEmptyString + emptyString == nonEmptyString
                </code></pre>

                <pre class="fragment"><code class="scala" data-trim data-noescape style="font-size: 1.5em; line-height: 1.2em">
class NonEmpty[A](a: A)
class Empty[A]

NonEmpty(42) ++ Empty[Int] == NonEmpty(42)
Empty[Int] ++ NonEmpty(42) == NonEmpty(42)
                </code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    These properties are actually the ones defining Monoids. A Monoid is a type of element providing a
                    binary operator allowing to combine them, along with a zero. Monoids laws are the following:<br/>
                    - left identity<br/>
                    - right identity<br/>
                    - associativity<br/>
                </aside>
                <br/><br/>
                <div style="text-align: left">
                    <div style="margin-left: 45px; text-align: left"><i>A monoid is an algebraic structure with a single associative binary operation and an identity element.</i></div>
                </div>
                <br/>
                <div style="text-align: left">
                    <table style="font-size: 25px">
                        <tr style="outline: thin solid"><td style="outline: thin solid">Type</td><td style="outline: thin solid">Zero</td><td style="outline: thin solid">Binary Operator</td></tr>
                        <tr style="outline: thin solid"><td style="outline: thin solid">String</td><td style="outline: thin solid">Empty String</td><td>+</td></tr>
                        <tr style="outline: thin solid"><td style="outline: thin solid">Collection</td><td style="outline: thin solid">Empty</td><td>++</td></tr>
                    </table>
                    <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
// Left Identity :
zero |+| x = x
// Right Identity:
x |+| zero = x
// Associativity :
(x |+| y) |+| z = x |+| (y |+| z)
                    </code></pre>
                </div>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    Any idea of another very well known Monoid? Well functions. In the domain of functions, the
                    identity function, which only returns the argument its provided with, represents the zero.
                    Therefore, if you try to compose a function with the identity function you get the same function
                    than the one you started with. And as a function is a monoid, Right Identity and Associativity also
                    apply.
                </aside>
                Functions are monoid too!<br/>
                <i>(with respect of Function composition)</i>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.5em; line-height: 1.2em">
// Left Identity :
f(identity(x)) == f(x)
// Right Identity:
identity(f(x)) == f(x)
// Associativity :
f(g(h(x))) == f ° g(h(x)) == f(g ° h(x))
                </code></pre>
            </section>

            <section data-transition="none none">
                <aside class="notes">
                    Monoids have a pretty simple algebra, but is far from being the only one provided by Functional
                    Programming. Indeed, let's look at some previous data structure we came upon earlier.<br/>

                    A value typed as a Maybe, represents a value which may or may not be available. The question is, how
                    could we compose a Maybe value with a simple function:<br/>

                    Well, we can define another function which takes a maybe value along with a function we'd like to
                    map over it. Thanks to map, we can now combine a function with a Maybe value without any
                    additional boilerplate.<br/>

                    What's the Algebra of this new combinator.
                </aside>
                <pre style="width:100%"><code class="scala" data-trim data-noescape style="font-size: 1.3em;
                line-height: 1.0em">
val x: Maybe[Int] = ...

def isBiggerThan42(i: Int): Boolean = i > 42

isBiggerThan42(x) // does not compile as x is not an Int
                </code></pre>
                <pre style="width:100%" class="fragment"><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height:
                1.0em">
def map[A, B](m: Maybe[A], f: A => B): Maybe[B] =
  m match {
    case Some(a) => Some(f(a))
    case None => None
  }
                </code></pre>
                <pre style="width:100%" class="fragment"><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height:
                1.0em">
val y: Maybe[Boolean] = map(x, isBiggerThan42)
                </code></pre>
            </section>

            <section data-transition="none none">
                <aside class="notes">
                    - The first law states that if we map the identity function over a functor, the functor that we get
                      back should be the same as the original functor.<br/>
                    - The second law says that composing two functions and then mapping the resulting function over a
                      functor, should be the same as first mapping one function over the functor, and then mapping the
                      second one over th result.

                    What we've just described is actually called a Functor. A Functor, is a type we can map over
                    which obeys the two laws we've just defined.<br/><br/>
                </aside>
                <pre style="width:100%"><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height:
                1.0em">
def map[A, B](m: Maybe[A], f: A => B): Maybe[B] =
  m match {
    case Some(a) => Some(f(a))
    case None => None
  }
                </code></pre>

                <pre style="width:100%" class="fragment"><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height:1.0em">
// Identity :
map(m, identity) == m

// Associativity :
map(m, f ° g)) == map(map(m, g), f)
                </code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    Alright, I guess you get the point now. Functional Programming provides many Algebras similar to
                    Functors and Monoids. Among them the famous Monad for example.<br/><br/>

                    Ok, so if this is the first time you
                    hear about these patterns and laws, I guess you're a bit confused. This takes a while before
                    being comfortable with these concepts and that's alright. What really matters here is not for you
                    to understand all those laws for now but to keep in mind that over the centuries, composable
                    systems were those having a specific Algebra. So you can see those rules as some kind of Grammar
                    which specify how one block can be composed with another. And this is actually the secret for
                    keeping a codebase maintainable.<br/><br/>

                    I mean look at the languages we use everyday like French or English. Without a proper
                    grammar those languages would be dead by today. This is why we need laws.
                </aside>
                <img style="vertical-align: text-bottom;margin-top:40px; border: 0; background-color: #243044"
                     src="images/intro_to_fp/g.png" width="550"/>
                <img class="fragment" style="vertical-align: text-bottom;margin-top:40px; border: 0; background-color: #243044"
                     src="images/intro_to_fp/39070116.jpg" width="387"/>
            </section>
        </section>

        <section data-transition="none none">
            <h2>Conclusion</h2>
            <aside class="notes">
                So, we are reaching the end of this talk, and I hope you've enjoyed it. Overall, Functional Programming
                can help you in lot of things like getting a stunning beard, an awesome moustache along with
                a couple of creepy t-shirts. More seriously.<br/><br/>

                I would really recommend every developer to learn about Functional Programming. Not because some consider
                it's better than any other paradigm, but because it's a matter of design. The more ways you can tackle a
                problem, the more relevant your solution for this problem will be.<br/><br/>

                Now when it comes to Functional Programming, you can quickly feel overwhelmed by the amount of
                resources on the Internet. So here's a couple of them I've considered really useful...
            </aside>
            <ul>
                <li><span style="font-size: 30px;color: #42BAE8;">Learn You a Haskell for Great Good! : </span><span style="font-size: 25px">by Miran Lipovaca</span></li>
                <li><span style="font-size: 30px;color: #42BAE8;">Functional Programming in Scala : </span><span style="font-size: 25px">by Paul Chiusano and Rúnar Bjarnason</span></li>
                <li><span style="font-size: 30px;color: #42BAE8;">http://degoes.net/: </span><span style="font-size: 25px">by John A De Goes</span></li>
                <li><span style="font-size: 30px;color: #42BAE8;">https://wiki.haskell.org/Typeclassopedia: </span><span style="font-size: 25px">by Brent Yorgey</span></li>
                <li><span style="font-size: 30px;color: #42BAE8;">Functional and Reactive Domain Modeling: </span><span style="font-size: 25px">by Debasish Ghosh</span></li>
                <li><span style="font-size: 30px;color: #42BAE8;">Real World Haskell: </span><span style="font-size: 25px">by Bryan O'Sullivan, Don Stewart, and John Goerzen</span></li>
            </ul>
        </section>
        <section data-transition="none none">
            <aside class="notes">
                I haven't introduced my self, my name is Francis Toth, I'm a happy Scala developer and Trainer working
                at Yoppworks, and one of the co-organizer of the Lambda Montreal meetup. A couple of words regarding
                Yoppworks, well we are a company providing consulting and training services in partnership with
                Hortonworks and Lightbend and are looking for people interested by Big Data, Functional Programming
                And Scala related technologies. If you are interested, just come see me and I'll be glad to talk
                about a potential collaboration with you. Thank you again, and now it's time for questions.
            </aside>
            <img style="background-color: transparent"
                 src="images/yoppworks.logo-corner-dark.png"/>
            <span style="font-size: 40px">Thank you ! Questions ?</span><br/>
            <span style="font-size: 25px">francis.toth@yoppworks.com</span>
        </section>
    </div>
</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>

<script>

    // Full list of configuration options available at:
    // https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
            { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
            { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
            { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
            { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
            { src: 'plugin/zoom-js/zoom.js', async: true },
            { src: 'plugin/notes/notes.js', async: true }
        ]
    });

</script>
</body>
</html>

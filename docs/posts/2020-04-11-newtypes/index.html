<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Newtype | Francis Toth / Contramap</title>

<meta name="keywords" content="" />
<meta name="description" content="In the previous post, we briefly covered how a typeclass can be implemented and ended up asking ourselves how multiple implementations of a typeclass could be done for the same data type while not compromising the implicit mechanism (in other words, type class coherency).
This technique has been deeply covered in a Spartan session presented by John De Goes, and this is a small teaser of what one can learn while attending his course:">
<meta name="author" content="">
<link rel="canonical" href="https://francistoth.github.io/posts/2020-04-11-newtypes/" />
<link href="https://francistoth.github.io/assets/css/stylesheet.min.d1bc2b736056bd5698d770eeedc08a73bce9e6cebb30810f6f1b2c2048e46ab8.css" integrity="sha256-0bwrc2BWvVaY13Du7cCKc7zp5s67MIEPbxssIEjkarg=" rel="preload stylesheet"
    as="style">

<link rel="icon" href="https://francistoth.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://francistoth.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://francistoth.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://francistoth.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://francistoth.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.68.3" />



<script>
    function openCity(evt, cityName, ref) {
        var i = 0;
        var bar = ref.parentElement;
        var tab = ref.parentElement.parentElement;

        var tabs = tab.getElementsByClassName("city");
        for (i = 0; i < tabs.length; i++) {
            tabs[i].style.display = "none";
            if (tabs[i].id == cityName)
                tabs[i].style.display = "block";
        }

        var tablinks = bar.getElementsByClassName("tablink");
        for (i = 0; i < tabs.length; i++) {
            tablinks[i].className = tablinks[i].className.replace(" white0", "");
        }
        evt.currentTarget.className += " white0";
    }


hljs.registerLanguage("scala", function(e) {
  return {   
    k: {
      keyword: 'type yield lazy override def with val var sealed abstract private trait object if forSome for while throw finally protected extends import final return else break new catch super class case package default try this match continue throws implicit',
      literal: 'true false null'
    },
    c: [
        hljs.QUOTE_STRING_MODE,
        hljs.COMMENT(
          "//",      
          "*"        
        ),
        hljs.COMMENT(
          "/\*",      
          "\*/"        
        )
      ]
  }
});


















































</script>
<style>

    .dark {
        --hljs-bg: rgb(30, 40, 45);
    }
    .post-content .highlight,
    .post-content pre {
        margin-left: 0;
        margin-right: 0;
        background: var(--hljs-bg) !important;
        border-radius: var(--radius);
        background-color: rgb(30, 40, 45) !important;
    }
    .btn {
        -webkit-border-radius: 5;
        -moz-border-radius: 5;
        border-radius: 5px;
        font-family: Arial;
        color: #ffffff;
        font-size: 13px;
        padding: 2px 7px 2px 7px;
        text-decoration: none;
    }

     

    
    .grey0 {
        background: #8a8a8a;
    }
    
    .white0 {
        background: #68899e;
    }

    .dark {
    --hljs-bg: #263238;
    }

    .post-content code {
        font-family: Hack, monospace !important;
    }

    .first-entry {
        position: relative;
        display: flex;
        flex-direction: column;
        justify-content: center;
        min-height: 0px;
        margin: var(--gap) 0 calc(var(--gap) * 2) 0;
        margin-bottom: 0;
    }

.highlight .hll { background-color: #ffffcc }
.highlight  { background: rgb(30, 40, 45); }
.highlight .c { color: #546E7A; font-style: italic }  
.highlight .err { color: #a61717; background-color: #e3d2d2 }  
.highlight .k { color:rgb(194, 136, 232);  }  
.hljs-keyword { color:rgb(194, 136, 232);  }  

.highlight .ch { color: #546E7A; font-style: italic }  
.highlight .cm { color: rgb(167, 159, 148); font-style: italic }  
.highlight .cp { color: #546E7A }  
.highlight .cpf { color: #546E7A; font-style: italic }  
.highlight .c1 { color: rgb(167, 159, 148); font-style: italic }  
.highlight .cs { color: #546E7A; font-weight: bold }  
.highlight .gd { color: #000000; background-color: #ffdddd }  
.highlight .ge { font-style: italic }  
.highlight .gr { color: #aa0000 }  
.highlight .gh { color: #999999 }  
.highlight .gi { color: #000000; background-color: #ddffdd }  
.highlight .go { color: #888888 }  
.highlight .gp { color: #555555 }  
.highlight .gs { font-weight: bold }  
.highlight .gu { color: #aaaaaa }  
.highlight .gt { color: #aa0000 }  
.highlight .kc { color: #F77669; font-weight: bold }  
.highlight .kd { color: rgba(233, 237, 237, 1); font-weight: bold }  
.highlight .kn { color: #000080; font-weight: bold }  
.highlight .kp { color: #000080; font-weight: bold }  
.highlight .kr { color: #000080; font-weight: bold }  
.highlight .kt { color: rgb(127, 174, 255); }  
.highlight .m { color: #F77669 }  
.highlight .s { color: rgb(195, 232, 141) }  
.highlight .n { color: rgba(233, 237, 237, 1); }  
.highlight .na { color: #FF0000 }  
.highlight .nc { color: rgba(233, 237, 237, 1); }  
.highlight .nt { color: #000080; font-weight: bold }  
.highlight .ow { font-weight: bold }  
.highlight .w { color: #bbbbbb }  
.highlight .mb { color: #0000FF }  
.highlight .mf { color: #0000FF }  
.highlight .mh { color: #0000FF }  
.highlight .mi { color:rgb(247, 118, 105) }  
.highlight .mo { color: #0000FF }  
.highlight .sa { color: #0000FF }  
.highlight .sb { color: #0000FF }  
.highlight .sc { color: #800080 }  
.highlight .dl { color: #0000FF }  
.highlight .sd { color: #0000FF }  
.highlight .s2 { color: #0000FF }  
.highlight .se { color: #0000FF }  
.highlight .sh { color: #0000FF }  
.highlight .si { color: #0000FF }  
.highlight .sx { color: #0000FF }  
.highlight .sr { color: #0000FF }  
.highlight .s1 { color: #0000FF }  
.highlight .ss { color: #0000FF }  
.highlight .il { color: #0000FF }  

</style>
<meta property="og:title" content="Newtype" />
<meta property="og:description" content="In the previous post, we briefly covered how a typeclass can be implemented and ended up asking ourselves how multiple implementations of a typeclass could be done for the same data type while not compromising the implicit mechanism (in other words, type class coherency).
This technique has been deeply covered in a Spartan session presented by John De Goes, and this is a small teaser of what one can learn while attending his course:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://francistoth.github.io/posts/2020-04-11-newtypes/" />
<meta property="article:published_time" content="2020-04-11T08:02:48-05:00" />
<meta property="article:modified_time" content="2020-04-11T08:02:48-05:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Newtype"/>
<meta name="twitter:description" content="In the previous post, we briefly covered how a typeclass can be implemented and ended up asking ourselves how multiple implementations of a typeclass could be done for the same data type while not compromising the implicit mechanism (in other words, type class coherency).
This technique has been deeply covered in a Spartan session presented by John De Goes, and this is a small teaser of what one can learn while attending his course:"/>

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Newtype",
  "name": "Newtype",
  "description": "In the previous post, we briefly covered how a typeclass can be implemented and ended up asking ourselves how multiple implementations of a typeclass could be done for the same …",
  "keywords": [
    
  ],
  "articleBody": "In the previous post, we briefly covered how a typeclass can be implemented and ended up asking ourselves how multiple implementations of a typeclass could be done for the same data type while not compromising the implicit mechanism (in other words, type class coherency).\nThis technique has been deeply covered in a Spartan session presented by John De Goes, and this is a small teaser of what one can learn while attending his course:\ntrait Associative[A] { def combine(a0: A, a1: A): A } object Associative { def apply[A: Associative]: Associative[A] = implicitly[Associative[A]] implicit val intAssociative: Associative[Int] = _ + _ /* which is syntactic sugar for: implicit val intAssociative: Associative[Int] = (a, b) = a + b */ // ... } The Associative typeclass describes how two values of the same type can be combined using an associative combinator. In order for a structure to be associative, the combinator must obey the following law:\na + (b + c) === (a + b) + c This is an aspect of typeclasses we have not mentioned in the previous post. Each typeclass has specific laws that must be satisfied by its implementations (commonly called instances in the functional programming jargon). There is no such thing as a lawless typeclass (otherwise it cannot be referred to as one).Back to our problem, when it comes to Int, there are two possible implementations to satisfy this associative law:\nimplicit val intSumAssociative : Associative[Int] = _ + _ implicit val intProductAssociative: Associative[Int] = _ * _ As we explained it in the previous post, the compiler throws an error whenever it cannot figure out which one of two or more implicits definitions should be selected to satisfy an implicit requirement. Therefore, it may seem at first impossible to create two implicit implementations of a typeclass, in the same implicit scope, for the same data type (eg. Int).\nValue Type One approach to get around this, would consist in creating a value type:\ncase class Mult(value: Int) extends AnyVal object Associative { implicit val sum : Associative[Int] = _ + _ implicit val product: Associative[Mult] = (a0, a1) = Mult(a0.value * a1.value) } This is not bad, but very inefficient (in terms of memory usage and ergonomics) even using AnyVal. AnyVal would prevent some extra allocations for sure but won’t get us too far:\ndef reduce[A: Associative](zero: A, as: List[A]): A = as.fold(zero)(Associative[A].combine) We would lose the benefits of AnyVal as soon as a List[Mult] is passed to reduce as memory allocation is required when a value value class is used as a type argument:\nreduce(Mult(0), List(Mult(1), Mult(2))) // Mult(3) What we really need is a way to create a new type that can be used in place of another, while being considered different during the implicit lookup, so that an Associative[Mult] is different than an Associative[Int].\nNaive approach Haskell provides a feature called newtype which exactly does that. Let’s try to implement a similar feature in Scala and take a step-by-step approach:\nsealed trait Newtype[A] { type WrappedType = A def wrap(a: A): WrappedType = a } Newtype[A] defines a type that can be used in place of an A. It provides a wrap function which given an A returns a Newtype[A].WrappedType. If you look closely, you will notice that WrappedType is a type alias for A:\nobject Mult extends Newtype[Int] type Mult = Mult.WrappedType val m1: Mult = Mult.wrap(1) def add1(i: Int): Int = i + 1 add1(m1) // 2 First, an object Mult is defined to represent the newtype. A type alias Mult is then created on Mult.WrappedType which points to A. This works fine, but this does not give us much compared to a simple type alias:\ntype Mult = Int val m1: Mult = 1 def add1(i: Int): Int = i + 1 add1(m1) // 2 And when it comes to implicits, Scala does not make any difference between an Associative[Int] and an Associative[Mult]. The problem here is that the compiler still knows that Mult stands for Int. This connection needs to be broken somehow so they are not considered the same. We could do this using an additional interface:\ntrait Foo { type Bar = Int def bar: Bar = 42 } val foo: Foo = new Foo {} val i : Int = foo.bar // compiles In the above example, Scala knows that Bar is a type alias for Int. Therefore, a Foo#Bar can be used in place of an Int, and these two are considered the same. However, this connection breaks whenever an additional abstraction layer is introduced:\ntrait Foo { type Bar def b(): Bar } class FooImpl extends Foo { type Bar = Int def b(): Bar = 42 } val foo: Foo = new FooImpl val i: foo.Bar = foo.b() // compiles val i: Int = foo.b() // does not compiles /* ^ error: type mismatch; found : foo.Bar required: Int */ As shown by this example, Bar and Int become distinct types even though they are the same. This is because foo is defined as a Foo and not a FooImpl. When referring to Foo, there is no way to prove that Foo#Bar points to Int. So foo.b() could technically return anything.\nThe real newtype Using what we’ve just learnt, let’s use a similar approach with Newtype[A]:\nsealed trait Newtype[A] { type WrappedType def wrap(a: A): WrappedType } val Mult: Newtype[Int] = new Newtype[Int] { type WrappedType = Int def wrap(a: Int): WrappedType = a } type Mult = Mult.WrappedType val m0: Mult = Mult.wrap(1) // compiles val m1: Int = Mult.wrap(1) // does not compile The connection between Mult and Int is now broken, and they are not considered as the same type by Scala anymore. However, we lost the ability to use a Mult in place of an Int. In some cases that’s exactly what we would like to achieve but not always. For this reason, we could make the distinction between Newtype which is unrelated to the initial type (this is how Haskell implements it), and Subtype which “extends” it:\nsealed trait Newtype[A] { type WrappedType // ... } sealed trait Subtype[A] { type WrappedType  A // ... } // ... val Mult: Subtype[Int] = new Subtype[Int] { type WrappedType = Int def wrap(a: Int): WrappedType = a } type Mult = Mult.WrappedType val m0: Mult = Mult.wrap(1) // compiles val m1: Int = Mult.wrap(1) // compiles Note: We won’t go through the Subtype facilities implementation to avoid going too much through similar code. You may refer to the complete code here.\nSo far, in terms of memory allocation the only cost is the one implied by creating Mult. Wrapping a type to a WrappedType only consists of a function call with no extra allocation. This approach is therefore more contraining than a type alias but at least as efficient memory wise than using a value class.What about implicit resolution now? Can we declare two implementations of the Associative typeclass for, technically speaking, the same data type? To achieve this, we would need a bit more than just wrap:\nsealed trait Newtype[A] { // ...  def unwrap(wt: WrappedType): A } val Mult: Newtype[Int] = new Newtype[Int] { // ...  def unwrap(wt: WrappedType): Int = wt } implicit val sum : Associative[Int] = _ + _ implicit val product: Associative[Mult] = (a0, a1) = Mult.wrap( Mult.unwrap(a0) * Mult.unwrap(a1) ) Let’s see if we can use this with reduce without getting a compilation error:\nreduce(1, List(2, 3)) // 2 + 3 = 5  reduce( Mult.wrap(1), List(Mult.wrap(2), Mult.wrap(3)) ) // 2 * 3 = 6 Great! we’ve just managed to create a type that is more constraining that an type alias, and more efficient memory wise than using a value class. Before going forward, let’s look at how the code looks like so far:\nsealed trait Newtype[A] { type WrappedType def wrap(a: Int): WrappedType def unwrap(wt: WrappedType): A } val Mult: Newtype[Int] = new Newtype[Int] { type WrappedType = Int def wrap(a: Int): WrappedType = a def unwrap(wt: WrappedType): Int = wt } implicit val sum : Associative[Int] = _ + _ implicit val product: Associative[Mult] = (a0, a1) = Mult.wrap( Mult.unwrap(a0) * Mult.unwrap(a1) ) reduce(1, List(2, 3)) // 5 reduce(Mult.wrap(1), List(Mult.wrap(2), Mult.wrap(3))) // 6 Ergonomics This is great but there is a lot of boilerplate. Declaring a newtype should be at most two lines long. If we think about it, no matter the newtype, the implementation of Newtype[A] is always the same. We could therefore provide an additional module dedicated for that:\nobject NewtypeModule { def newtype[A]: Newtype[A] = new Newtype[A] { type WrappedType = A def wrap(a: A): WrappedType = a def unwrap(wt: WrappedType): A = wt } } val Mult: Newtype[Int] = NewtypeModule.newtype[Int] We could also improve the wrapping operation by simply renaming the wrap method to apply:\nsealed trait Newtype[A] { def apply(a: A): WrappedType // ... } The API looks already better:\nval Mult: Newtype[Int] = NewtypeModule.newtype[Int] type Mult = Mult.WrappedType val m0: Mult = Mult(1) Pattern Matching There is one last thing we cannot do with a newtype which is pattern matching. Mult is currently a value which prevents writing anything such as:\nMult(42) match { case Mult(meaningOfLife) = ??? } To achieve this, Mult has to be an object implementing a unapply method:\nobject Mult extends ??? type Mult = Mult.WrappedType However, Mult can’t extend Newtype[Int] otherwise Scala will establish a link between Mult.WrappedType and Int bringing us back to square one. Newtype[Int] should therefore be provided as a dependent type:\nobject Mult extends module.Newtype[Int] type Mult = Mult.WrappedType module is a value providing a dependent type Newtype[A] and which could be implemented like this:\ntrait NewtypeModule { sealed trait Newtype[A] { type WrappedType def apply(a: A): WrappedType def unwrap(wt: WrappedType): A } } val module: NewtypeModule = new NewtypeModule {} Mult can now extends module.Newtype[Int] as described earlier:\nobject Mult extends module.Newtype[Int] { type WrappedType = Int def apply(a: Int): WrappedType = a def unwrap(wt: WrappedType): Int = wt } Reducing Boilerplate So far so good, except that we ended up with even more boilerplate :) If we think about it, we don’t really need multiple instances of NewtypeModule. We just need one:\nobject NewtypeModule { val instance: NewtypeModule = new NewtypeModule {} } object Mult extends NewtypeModule.instance.Newtype[Int] { // ... } Secondly, we could factor the implementation of a Newtype[A], as it is the same for every newtype:\ntrait NewtypeModule { def newtype[A]: Newtype[A] // ... } object NewtypeModule { val instance: NewtypeModule = new NewtypeModule { def newtype[A]: Newtype[A] = new Newtype[A] { type WrappedType = A def apply(a: A): WrappedType = a def unwrap(wt: WrappedType): A = wt } } } Finally the API could be improved by creating an abstract class Newtype[A] which delegates the work to NewtypeModule.instance:\ntrait NewtypeModuleExports { import NewtypeModule._ abstract class Newtype[A] extends instance.Newtype[A] { val newtype: instance.Newtype[A] = instance.newtype[A] type WrappedType = newtype.WrappedType def apply(a: A): WrappedType = newtype(a) def unwrap(wt: WrappedType): A = newtype.unwrap(wt) } } NewtypeModuleExports could be then mixed in a package object to prevent any additional import from the user:\npackage io.github.francistoth // if the package is called `newtype` package object newtype extends NewtypeModuleExports This makes the declaration of a newtype really easy:\nobject Mult extends Newtype[Int] type Mult = Mult.WrappedType The last piece consists of adding an unapply method to enable pattern matching capabilities for any newtype:\ntrait NewtypeModule { sealed trait Newtype[A] { type WrappedType def apply(a: A): WrappedType def unwrap(wt: WrappedType): A def unapply(wt: WrappedType): Option[A] = Some(unwrap(wt)) } } // ... Mult(42) match { case Mult(i) = i } // 42 There we go. The code is available here.\nAdditional thoughts In the past, Calvin and myself have been pushing hard to use strong typing everywhere in our code. We used to rely on value types, macros and libraries such as scala-newtype. Knowing the technique we just covered is one more tool under our belt, and is probably the one we’ll use in the future, especially since it will be part of the incoming zio-prelude library.\nCredits Thanks to Calvin, Phil, and John for helping me to write this post and for their mentoring.\n",
  "wordCount" : "2027",
  "inLanguage": "en",
  "datePublished": "2020-04-11T08:02:48-05:00",
  "dateModified": "2020-04-11T08:02:48-05:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://francistoth.github.io/posts/2020-04-11-newtypes/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Francis Toth / Contramap",
    "logo": {
      "@type": "ImageObject",
      "url": "https://francistoth.github.io/favicon.ico"
    }
  }
}
</script>



</head>

<body class=" dark">
<noscript>
    <style type="text/css">
        .theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://francistoth.github.io" accesskey="h" title="Francis Toth / Contramap (Alt + H)">Francis Toth / Contramap</a>
            <span class="logo-switches">
                
            </span>
        </div>
        <ul class="menu" id="menu" onscroll="menu_on_scroll()">
            <li>
                <a href="https://francistoth.github.io/about/" title="about">
                    <span>about</span>
                </a>
            </li>
            <li>
                <a href="https://francistoth.github.io/talks/" title="talks">
                    <span>talks</span>
                </a>
            </li>
            <li>
                <a href="https://francistoth.github.io/cv/" title="resume">
                    <span>resume</span>
                </a>
            </li><li>
                <a style="display: inline;" target="_blank" href="https://twitter.com/francistoth?lang=en">
                    <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" style="height: 20px; width: 30px; fill: currentColor; transition: transform .1s">
                        <path
                            d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
                    </svg>
                </a>
                <a style="display: inline;" target="_blank" href="https://ca.linkedin.com/in/francistoth/en-us">
                    <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" style="height: 20px; width: 30px; fill: currentColor; transition: transform .1s">
                        <path
                            d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
                    </svg>
                </a>
                <a style="display: inline;" target="_blank" href="https://github.com/FrancisToth">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round", style="height: 20px; width: 30px; fill: currentColor; transition: transform .1s">
                        <path
                            d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22">
                        </path>
                    </svg>
                </a>
            </li>
            
        </ul>
    </nav>
</header>

    <main class="main">

<article class="post-single">
  <header class="post-header">
    <h1 class="post-title">
      Newtype
    </h1>
    <div class="post-meta">April 11, 2020

    </div>
  </header> 

  <div class="post-content">
<p>In the <a href="https://francistoth.github.io/2020/04/09/typeclasses.html">previous post</a>, we briefly covered how a typeclass can be implemented and ended up asking ourselves how multiple implementations of a typeclass could be done for the same data type while not compromising the implicit mechanism (in other words, type class coherency).</p>
<p>This technique has been deeply covered in a <a href="https://www.patreon.com/jdegoes">Spartan session</a> presented by <a href="https://github.com/jdegoes">John De Goes</a>, and this is a small teaser of what one can learn while attending his course:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">trait</span> <span class="nc">Associative</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">combine</span><span class="o">(</span><span class="n">a0</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">a1</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>
<span class="o">}</span>
<span class="k">object</span> <span class="nc">Associative</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Associative</span><span class="o">]</span><span class="k">:</span> <span class="kt">Associative</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">Associative</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span>

  <span class="k">implicit</span> <span class="k">val</span> <span class="n">intAssociative</span><span class="k">:</span> <span class="kt">Associative</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="k">_</span> <span class="o">+</span> <span class="k">_</span>
  <span class="cm">/* which is syntactic sugar for: 
</span><span class="cm">  implicit val intAssociative: Associative[Int] = (a, b) =&gt; a + b
</span><span class="cm">  */</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="o">}</span>
</code></pre></div><p>The <code>Associative</code> typeclass describes how two values of the same type can be combined using an associative combinator. In order for a structure to be associative, the combinator must obey the following law:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">a</span> <span class="o">+</span> <span class="o">(</span><span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="o">)</span> <span class="o">===</span> <span class="o">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">)</span> <span class="o">+</span> <span class="n">c</span>
</code></pre></div><p>This is an aspect of typeclasses we have not mentioned in the previous post. Each typeclass has specific laws that must be satisfied by its implementations (commonly called <em>instances</em> in the functional programming jargon). There is no such thing as a lawless typeclass (otherwise it cannot be referred to as one).<!-- raw HTML omitted --></p>
<p>Back to our problem, when it comes to <code>Int</code>, there are two possible implementations to satisfy this associative law:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">implicit</span> <span class="k">val</span> <span class="n">intSumAssociative</span>    <span class="k">:</span> <span class="kt">Associative</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="k">_</span> <span class="o">+</span> <span class="k">_</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="n">intProductAssociative</span><span class="k">:</span> <span class="kt">Associative</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="k">_</span> <span class="o">*</span> <span class="k">_</span>
</code></pre></div><p>As we explained it in the previous post, the compiler throws an error whenever it cannot figure out which one of two or more implicits definitions should be selected to satisfy an implicit requirement. Therefore, it may seem at first impossible to create two implicit implementations of a typeclass, in the same implicit scope, for the same data type (eg. <code>Int</code>).</p>
<h2 id="value-type">Value Type<a hidden class="anchor" aria-hidden="true" href="#value-type">#</a></h2>
<p>One approach to get around this, would consist in creating a value type:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">case</span> <span class="k">class</span> <span class="nc">Mult</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">AnyVal</span>

<span class="k">object</span> <span class="nc">Associative</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="n">sum</span>    <span class="k">:</span> <span class="kt">Associative</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="k">_</span> <span class="o">+</span> <span class="k">_</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="n">product</span><span class="k">:</span> <span class="kt">Associative</span><span class="o">[</span><span class="kt">Mult</span><span class="o">]</span> <span class="k">=</span> 
    <span class="o">(</span><span class="n">a0</span><span class="o">,</span> <span class="n">a1</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Mult</span><span class="o">(</span><span class="n">a0</span><span class="o">.</span><span class="n">value</span> <span class="o">*</span> <span class="n">a1</span><span class="o">.</span><span class="n">value</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div><p>This is not bad, but very inefficient (in terms of memory usage and ergonomics) even using <code>AnyVal</code>. <code>AnyVal</code> would prevent some extra allocations for sure but won&rsquo;t get us <a href="https://failex.blogspot.com/2017/04/the-high-cost-of-anyval-subclasses.html?m=1">too far</a>:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">def</span> <span class="n">reduce</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Associative</span><span class="o">](</span><span class="n">zero</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">as</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> 
  <span class="n">as</span><span class="o">.</span><span class="n">fold</span><span class="o">(</span><span class="n">zero</span><span class="o">)(</span><span class="nc">Associative</span><span class="o">[</span><span class="kt">A</span><span class="o">].</span><span class="n">combine</span><span class="o">)</span>
</code></pre></div><p>We would lose the benefits of <code>AnyVal</code> as soon as a <code>List[Mult]</code> is passed to <code>reduce</code> as memory allocation is required when a value value class is used as a type argument:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">reduce</span><span class="o">(</span><span class="nc">Mult</span><span class="o">(</span><span class="mi">0</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Mult</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="nc">Mult</span><span class="o">(</span><span class="mi">2</span><span class="o">)))</span> <span class="c1">// Mult(3)
</span></code></pre></div><p>What we really need is a way to create a new type that can be used in place of another, while being considered different during the implicit lookup, so that an <code>Associative[Mult]</code> is different than an <code>Associative[Int]</code>.</p>
<h2 id="naive-approach">Naive approach<a hidden class="anchor" aria-hidden="true" href="#naive-approach">#</a></h2>
<p>Haskell provides a feature called <code>newtype</code> which exactly does that. Let&rsquo;s try to implement a similar feature in Scala and take a step-by-step approach:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Newtype</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">WrappedType</span> <span class="o">=</span> <span class="n">A</span>
  <span class="k">def</span> <span class="n">wrap</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">WrappedType</span> <span class="o">=</span> <span class="n">a</span>
<span class="o">}</span>
</code></pre></div><p><code>Newtype[A]</code> defines a type that can be used in place of an <code>A</code>. It provides a <code>wrap</code> function which given an <code>A</code> returns a <code>Newtype[A].WrappedType</code>. If you look closely, you will notice that <code>WrappedType</code> is a type alias for <code>A</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">object</span> <span class="nc">Mult</span> <span class="k">extends</span> <span class="nc">Newtype</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="k">type</span> <span class="kt">Mult</span> <span class="o">=</span> <span class="nc">Mult</span><span class="o">.</span><span class="nc">WrappedType</span>

<span class="k">val</span> <span class="n">m1</span><span class="k">:</span> <span class="kt">Mult</span> <span class="o">=</span> <span class="nc">Mult</span><span class="o">.</span><span class="n">wrap</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="k">def</span> <span class="n">add1</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>

<span class="n">add1</span><span class="o">(</span><span class="n">m1</span><span class="o">)</span> <span class="c1">// 2 
</span></code></pre></div><p>First, an object <code>Mult</code> is defined to represent the newtype. A type alias <code>Mult</code> is then created on <code>Mult.WrappedType</code> which points to <code>A</code>. This works fine, but this does not give us much compared to a simple type alias:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">type</span> <span class="kt">Mult</span> <span class="o">=</span> <span class="nc">Int</span>

<span class="k">val</span> <span class="n">m1</span><span class="k">:</span> <span class="kt">Mult</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">def</span> <span class="n">add1</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>

<span class="n">add1</span><span class="o">(</span><span class="n">m1</span><span class="o">)</span> <span class="c1">// 2 
</span></code></pre></div><p>And when it comes to implicits, Scala does not make any difference between an <code>Associative[Int]</code> and an <code>Associative[Mult]</code>. The problem here is that the compiler still knows that <code>Mult</code> stands for <code>Int</code>. This connection needs to be broken somehow so they are not considered the same. We could do this using an additional interface:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">trait</span> <span class="nc">Foo</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Bar</span> <span class="o">=</span> <span class="nc">Int</span>
  <span class="k">def</span> <span class="n">bar</span><span class="k">:</span> <span class="kt">Bar</span> <span class="o">=</span> <span class="mi">42</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">foo</span><span class="k">:</span> <span class="kt">Foo</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Foo</span> <span class="o">{}</span>
<span class="k">val</span> <span class="n">i</span>  <span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">foo</span><span class="o">.</span><span class="n">bar</span> <span class="c1">// compiles
</span></code></pre></div><p>In the above example, Scala knows that <code>Bar</code> is a type alias for <code>Int</code>. Therefore, a <code>Foo#Bar</code> can be used in place of an <code>Int</code>, and these two are considered the same. However, this connection breaks whenever an additional abstraction layer is introduced:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">trait</span> <span class="nc">Foo</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Bar</span>
  <span class="k">def</span> <span class="n">b</span><span class="o">()</span><span class="k">:</span> <span class="kt">Bar</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">FooImpl</span> <span class="k">extends</span> <span class="nc">Foo</span> <span class="o">{</span> 
  <span class="k">type</span> <span class="kt">Bar</span> <span class="o">=</span> <span class="nc">Int</span>
  <span class="k">def</span> <span class="n">b</span><span class="o">()</span><span class="k">:</span> <span class="kt">Bar</span> <span class="o">=</span> <span class="mi">42</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">foo</span><span class="k">:</span> <span class="kt">Foo</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FooImpl</span>

<span class="k">val</span> <span class="n">i</span><span class="k">:</span> <span class="kt">foo.Bar</span> <span class="o">=</span> <span class="n">foo</span><span class="o">.</span><span class="n">b</span><span class="o">()</span> <span class="c1">// compiles
</span><span class="c1"></span><span class="k">val</span> <span class="n">i</span><span class="k">:</span> <span class="kt">Int</span>     <span class="o">=</span> <span class="n">foo</span><span class="o">.</span><span class="n">b</span><span class="o">()</span> <span class="c1">// does not compiles
</span><span class="c1"></span><span class="cm">/*                   ^
</span><span class="cm">error: type mismatch;
</span><span class="cm"> found   : foo.Bar
</span><span class="cm"> required: Int
</span><span class="cm">*/</span>
</code></pre></div><p>As shown by this example, <code>Bar</code> and <code>Int</code> become distinct types even though they are the same. This is because <code>foo</code> is defined as a <code>Foo</code> and not a <code>FooImpl</code>. When referring to <code>Foo</code>, there is no way to prove that <code>Foo#Bar</code> points to <code>Int</code>. So <code>foo.b()</code> could technically return anything.</p>
<h2 id="the-real-newtype">The real newtype<a hidden class="anchor" aria-hidden="true" href="#the-real-newtype">#</a></h2>
<p>Using what we&rsquo;ve just learnt, let&rsquo;s use a similar approach with <code>Newtype[A]</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Newtype</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">WrappedType</span>
  <span class="k">def</span> <span class="n">wrap</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">WrappedType</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nc">Mult</span><span class="k">:</span> <span class="kt">Newtype</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Newtype</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">WrappedType</span> <span class="o">=</span> <span class="nc">Int</span>
  <span class="k">def</span> <span class="n">wrap</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">WrappedType</span> <span class="o">=</span> <span class="n">a</span>
<span class="o">}</span>
<span class="k">type</span> <span class="kt">Mult</span> <span class="o">=</span> <span class="nc">Mult</span><span class="o">.</span><span class="nc">WrappedType</span>

<span class="k">val</span> <span class="n">m0</span><span class="k">:</span> <span class="kt">Mult</span> <span class="o">=</span> <span class="nc">Mult</span><span class="o">.</span><span class="n">wrap</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="c1">// compiles
</span><span class="c1"></span><span class="k">val</span> <span class="n">m1</span><span class="k">:</span> <span class="kt">Int</span>  <span class="o">=</span> <span class="nc">Mult</span><span class="o">.</span><span class="n">wrap</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="c1">// does not compile
</span></code></pre></div><p>The connection between <code>Mult</code> and <code>Int</code> is now broken, and they are not considered as the same type by Scala anymore. However, we lost the ability to use a <code>Mult</code> in place of an <code>Int</code>. In some cases that&rsquo;s exactly what we would like to achieve but not always. For this reason, we could make the distinction between <code>Newtype</code> which is <em>unrelated</em> to the initial type (this is how Haskell implements it), and <code>Subtype</code> which <em>&ldquo;extends&rdquo;</em> it:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Newtype</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">WrappedType</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="o">}</span>

<span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Subtype</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">WrappedType</span> <span class="k">&lt;:</span> <span class="kt">A</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="o">}</span>
<span class="c1">// ...
</span><span class="c1"></span><span class="k">val</span> <span class="nc">Mult</span><span class="k">:</span> <span class="kt">Subtype</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Subtype</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">WrappedType</span> <span class="o">=</span> <span class="nc">Int</span>
  <span class="k">def</span> <span class="n">wrap</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">WrappedType</span> <span class="o">=</span> <span class="n">a</span>
<span class="o">}</span>
<span class="k">type</span> <span class="kt">Mult</span> <span class="o">=</span> <span class="nc">Mult</span><span class="o">.</span><span class="nc">WrappedType</span>

<span class="k">val</span> <span class="n">m0</span><span class="k">:</span> <span class="kt">Mult</span> <span class="o">=</span> <span class="nc">Mult</span><span class="o">.</span><span class="n">wrap</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="c1">// compiles
</span><span class="c1"></span><span class="k">val</span> <span class="n">m1</span><span class="k">:</span> <span class="kt">Int</span>  <span class="o">=</span> <span class="nc">Mult</span><span class="o">.</span><span class="n">wrap</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="c1">// compiles
</span></code></pre></div><p><strong>Note</strong>: We won&rsquo;t go through the <code>Subtype</code> facilities implementation to avoid going too much through similar code. You may refer to the complete code <a href="https://github.com/FrancisToth/francistoth.github.io/blob/master/src/main/scala/io/github/francistoth/newtype">here</a>.</p>
<p>So far, in terms of memory allocation the only cost is the one implied by creating <code>Mult</code>. Wrapping a type to a <code>WrappedType</code> only consists of a function call with no extra allocation. This approach is therefore more contraining than a type alias but at least as efficient memory wise than using a value class.<!-- raw HTML omitted --></p>
<p>What about implicit resolution now? Can we declare two implementations of the <code>Associative</code> typeclass for, technically speaking, the same data type? To achieve this, we would need a bit more than just <code>wrap</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Newtype</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// ...
</span><span class="c1"></span>  <span class="k">def</span> <span class="n">unwrap</span><span class="o">(</span><span class="n">wt</span><span class="k">:</span> <span class="kt">WrappedType</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nc">Mult</span><span class="k">:</span> <span class="kt">Newtype</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Newtype</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// ...
</span><span class="c1"></span>  <span class="k">def</span> <span class="n">unwrap</span><span class="o">(</span><span class="n">wt</span><span class="k">:</span> <span class="kt">WrappedType</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">wt</span>
<span class="o">}</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="n">sum</span>    <span class="k">:</span> <span class="kt">Associative</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="k">_</span> <span class="o">+</span> <span class="k">_</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="n">product</span><span class="k">:</span> <span class="kt">Associative</span><span class="o">[</span><span class="kt">Mult</span><span class="o">]</span> <span class="k">=</span> 
  <span class="o">(</span><span class="n">a0</span><span class="o">,</span> <span class="n">a1</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Mult</span><span class="o">.</span><span class="n">wrap</span><span class="o">(</span>
    <span class="nc">Mult</span><span class="o">.</span><span class="n">unwrap</span><span class="o">(</span><span class="n">a0</span><span class="o">)</span> <span class="o">*</span> <span class="nc">Mult</span><span class="o">.</span><span class="n">unwrap</span><span class="o">(</span><span class="n">a1</span><span class="o">)</span>
  <span class="o">)</span>
</code></pre></div><p>Let&rsquo;s see if we can use this with <code>reduce</code> without getting a compilation error:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">reduce</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nc">List</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">))</span> <span class="c1">// 2 + 3 = 5
</span><span class="c1"></span>
<span class="n">reduce</span><span class="o">(</span>
  <span class="nc">Mult</span><span class="o">.</span><span class="n">wrap</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> 
  <span class="nc">List</span><span class="o">(</span><span class="nc">Mult</span><span class="o">.</span><span class="n">wrap</span><span class="o">(</span><span class="mi">2</span><span class="o">),</span> <span class="nc">Mult</span><span class="o">.</span><span class="n">wrap</span><span class="o">(</span><span class="mi">3</span><span class="o">))</span>
<span class="o">)</span> <span class="c1">// 2 * 3 = 6
</span></code></pre></div><p>Great! we&rsquo;ve just managed to create a type that is more constraining that an type alias, and more efficient memory wise than using a value class. Before going forward, let&rsquo;s look at how the code looks like so far:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Newtype</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">WrappedType</span>
  <span class="k">def</span> <span class="n">wrap</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">WrappedType</span>
  <span class="k">def</span> <span class="n">unwrap</span><span class="o">(</span><span class="n">wt</span><span class="k">:</span> <span class="kt">WrappedType</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nc">Mult</span><span class="k">:</span> <span class="kt">Newtype</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Newtype</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">WrappedType</span> <span class="o">=</span> <span class="nc">Int</span>
  <span class="k">def</span> <span class="n">wrap</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">WrappedType</span>    <span class="o">=</span> <span class="n">a</span>
  <span class="k">def</span> <span class="n">unwrap</span><span class="o">(</span><span class="n">wt</span><span class="k">:</span> <span class="kt">WrappedType</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">wt</span>
<span class="o">}</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="n">sum</span>    <span class="k">:</span> <span class="kt">Associative</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="k">_</span> <span class="o">+</span> <span class="k">_</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="n">product</span><span class="k">:</span> <span class="kt">Associative</span><span class="o">[</span><span class="kt">Mult</span><span class="o">]</span> <span class="k">=</span> 
    <span class="o">(</span><span class="n">a0</span><span class="o">,</span> <span class="n">a1</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Mult</span><span class="o">.</span><span class="n">wrap</span><span class="o">(</span>
      <span class="nc">Mult</span><span class="o">.</span><span class="n">unwrap</span><span class="o">(</span><span class="n">a0</span><span class="o">)</span> <span class="o">*</span> <span class="nc">Mult</span><span class="o">.</span><span class="n">unwrap</span><span class="o">(</span><span class="n">a1</span><span class="o">)</span>
    <span class="o">)</span>

<span class="n">reduce</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nc">List</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">))</span> <span class="c1">// 5
</span><span class="c1"></span><span class="n">reduce</span><span class="o">(</span><span class="nc">Mult</span><span class="o">.</span><span class="n">wrap</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Mult</span><span class="o">.</span><span class="n">wrap</span><span class="o">(</span><span class="mi">2</span><span class="o">),</span> <span class="nc">Mult</span><span class="o">.</span><span class="n">wrap</span><span class="o">(</span><span class="mi">3</span><span class="o">)))</span> <span class="c1">// 6
</span></code></pre></div><h2 id="ergonomics">Ergonomics<a hidden class="anchor" aria-hidden="true" href="#ergonomics">#</a></h2>
<p>This is great but there is a lot of boilerplate. Declaring a newtype should be at most two lines long. If we think about it, no matter the newtype, the implementation of <code>Newtype[A]</code> is always the same. We could therefore provide an additional module dedicated for that:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">object</span> <span class="nc">NewtypeModule</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">newtype</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">Newtype</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Newtype</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">type</span> <span class="kt">WrappedType</span> <span class="o">=</span> <span class="n">A</span>
    <span class="k">def</span> <span class="n">wrap</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">WrappedType</span> <span class="o">=</span> <span class="n">a</span>
    <span class="k">def</span> <span class="n">unwrap</span><span class="o">(</span><span class="n">wt</span><span class="k">:</span> <span class="kt">WrappedType</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">wt</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nc">Mult</span><span class="k">:</span> <span class="kt">Newtype</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">NewtypeModule</span><span class="o">.</span><span class="n">newtype</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
</code></pre></div><p>We could also improve the wrapping operation by simply renaming the <code>wrap</code> method to <code>apply</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Newtype</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">WrappedType</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="o">}</span>
</code></pre></div><p>The API looks already better:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="nc">Mult</span><span class="k">:</span> <span class="kt">Newtype</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">NewtypeModule</span><span class="o">.</span><span class="n">newtype</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="k">type</span> <span class="kt">Mult</span> <span class="o">=</span> <span class="nc">Mult</span><span class="o">.</span><span class="nc">WrappedType</span>

<span class="k">val</span> <span class="n">m0</span><span class="k">:</span> <span class="kt">Mult</span> <span class="o">=</span> <span class="nc">Mult</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
</code></pre></div><h2 id="pattern-matching">Pattern Matching<a hidden class="anchor" aria-hidden="true" href="#pattern-matching">#</a></h2>
<p>There is one last thing we cannot do with a newtype which is pattern matching. <code>Mult</code> is currently a value which prevents writing anything such as:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="nc">Mult</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Mult</span><span class="o">(</span><span class="n">meaningOfLife</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">???</span>
<span class="o">}</span>
</code></pre></div><p>To achieve this, <code>Mult</code> has to be an <code>object</code> implementing a <code>unapply</code> method:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">object</span> <span class="nc">Mult</span> <span class="k">extends</span> <span class="o">???</span>
<span class="k">type</span> <span class="kt">Mult</span> <span class="o">=</span> <span class="nc">Mult</span><span class="o">.</span><span class="nc">WrappedType</span>
</code></pre></div><p>However, <code>Mult</code> can&rsquo;t extend <code>Newtype[Int]</code> otherwise Scala will establish a link between <code>Mult.WrappedType</code> and <code>Int</code> bringing us back to square one. <code>Newtype[Int]</code> should therefore be provided as a dependent type:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">object</span> <span class="nc">Mult</span> <span class="k">extends</span> <span class="n">module</span><span class="o">.</span><span class="nc">Newtype</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="k">type</span> <span class="kt">Mult</span> <span class="o">=</span> <span class="nc">Mult</span><span class="o">.</span><span class="nc">WrappedType</span>
</code></pre></div><p><code>module</code> is a value providing a dependent type <code>Newtype[A]</code> and which could be implemented like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">trait</span> <span class="nc">NewtypeModule</span> <span class="o">{</span>
  <span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Newtype</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">type</span> <span class="kt">WrappedType</span>
    <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">WrappedType</span>
    <span class="k">def</span> <span class="n">unwrap</span><span class="o">(</span><span class="n">wt</span><span class="k">:</span> <span class="kt">WrappedType</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">module</span><span class="k">:</span> <span class="kt">NewtypeModule</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">NewtypeModule</span> <span class="o">{}</span>
</code></pre></div><p><code>Mult</code> can now extends <code>module.Newtype[Int]</code> as described earlier:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">object</span> <span class="nc">Mult</span> <span class="k">extends</span> <span class="n">module</span><span class="o">.</span><span class="nc">Newtype</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">WrappedType</span>  <span class="o">=</span> <span class="nc">Int</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">WrappedType</span> <span class="o">=</span> <span class="n">a</span>
  <span class="k">def</span> <span class="n">unwrap</span><span class="o">(</span><span class="n">wt</span><span class="k">:</span> <span class="kt">WrappedType</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">wt</span>
<span class="o">}</span>
</code></pre></div><h2 id="reducing-boilerplate">Reducing Boilerplate<a hidden class="anchor" aria-hidden="true" href="#reducing-boilerplate">#</a></h2>
<p>So far so good, except that we ended up with even more boilerplate :) If we think about it, we don&rsquo;t really need multiple instances of <code>NewtypeModule</code>. We just need one:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">object</span> <span class="nc">NewtypeModule</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">instance</span><span class="k">:</span> <span class="kt">NewtypeModule</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">NewtypeModule</span> <span class="o">{}</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Mult</span> <span class="k">extends</span> <span class="nc">NewtypeModule</span><span class="o">.</span><span class="n">instance</span><span class="o">.</span><span class="nc">Newtype</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
 <span class="c1">// ...
</span><span class="c1"></span><span class="o">}</span>
</code></pre></div><p>Secondly, we could factor the implementation of a <code>Newtype[A]</code>, as it is the same for every newtype:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">trait</span> <span class="nc">NewtypeModule</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">newtype</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">Newtype</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="o">}</span>

<span class="k">object</span> <span class="nc">NewtypeModule</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">instance</span><span class="k">:</span> <span class="kt">NewtypeModule</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">NewtypeModule</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">newtype</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">Newtype</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Newtype</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
      <span class="k">type</span> <span class="kt">WrappedType</span>  <span class="o">=</span> <span class="n">A</span>
      <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">WrappedType</span> <span class="o">=</span> <span class="n">a</span>
      <span class="k">def</span> <span class="n">unwrap</span><span class="o">(</span><span class="n">wt</span><span class="k">:</span> <span class="kt">WrappedType</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">wt</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>Finally the API could be improved by creating an abstract class <code>Newtype[A]</code> which delegates the work to <code>NewtypeModule.instance</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">trait</span> <span class="nc">NewtypeModuleExports</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">NewtypeModule._</span>
  
  <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Newtype</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="nc">extends</span> <span class="n">instance</span><span class="o">.</span><span class="nc">Newtype</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">newtype</span><span class="k">:</span> <span class="kt">instance.Newtype</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">instance</span><span class="o">.</span><span class="n">newtype</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
    <span class="k">type</span> <span class="kt">WrappedType</span> <span class="o">=</span> <span class="n">newtype</span><span class="o">.</span><span class="nc">WrappedType</span>

    <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">WrappedType</span>   <span class="o">=</span> <span class="n">newtype</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
    <span class="k">def</span> <span class="n">unwrap</span><span class="o">(</span><span class="n">wt</span><span class="k">:</span> <span class="kt">WrappedType</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">newtype</span><span class="o">.</span><span class="n">unwrap</span><span class="o">(</span><span class="n">wt</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p><code>NewtypeModuleExports</code> could be then mixed in a package object to prevent any additional import from the user:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">package</span> <span class="nn">io.github.francistoth</span>

<span class="c1">// if the package is called `newtype`
</span><span class="c1"></span><span class="k">package</span> <span class="nn">object</span> <span class="n">newtype</span> <span class="k">extends</span> <span class="nc">NewtypeModuleExports</span>
</code></pre></div><p>This makes the declaration of a newtype really easy:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">object</span> <span class="nc">Mult</span> <span class="k">extends</span> <span class="nc">Newtype</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="k">type</span> <span class="kt">Mult</span> <span class="o">=</span> <span class="nc">Mult</span><span class="o">.</span><span class="nc">WrappedType</span>
</code></pre></div><p>The last piece consists of adding an <code>unapply</code> method to enable pattern matching capabilities for any newtype:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">trait</span> <span class="nc">NewtypeModule</span> <span class="o">{</span>
  <span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Newtype</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">type</span> <span class="kt">WrappedType</span>
    <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">WrappedType</span>
    <span class="k">def</span> <span class="n">unwrap</span><span class="o">(</span><span class="n">wt</span><span class="k">:</span> <span class="kt">WrappedType</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>
    <span class="k">def</span> <span class="n">unapply</span><span class="o">(</span><span class="n">wt</span><span class="k">:</span> <span class="kt">WrappedType</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
      <span class="nc">Some</span><span class="o">(</span><span class="n">unwrap</span><span class="o">(</span><span class="n">wt</span><span class="o">))</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// ...
</span><span class="c1"></span><span class="nc">Mult</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Mult</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">i</span>
<span class="o">}</span> <span class="c1">// 42
</span></code></pre></div><p>There we go. The code is available <a href="https://github.com/FrancisToth/francistoth.github.io/blob/master/src/main/scala/io/github/francistoth/newtype">here</a>.</p>
<h2 id="additional-thoughts">Additional thoughts<a hidden class="anchor" aria-hidden="true" href="#additional-thoughts">#</a></h2>
<p>In the past, <a href="https://github.com/calvinlfer">Calvin</a> and myself have been pushing hard to use strong typing everywhere in our code. We used to rely on value types, macros and libraries such as <a href="https://github.com/estatico/scala-newtype">scala-newtype</a>. Knowing the technique we just covered is one more tool under our belt, and is probably the one we&rsquo;ll use in the future, especially since it will be part of the incoming <a href="https://twitter.com/jdegoes/status/1236099212137373696?lang=en">zio-prelude</a> library.</p>
<h2 id="credits">Credits<a hidden class="anchor" aria-hidden="true" href="#credits">#</a></h2>
<p>Thanks to <a href="https://github.com/calvinlfer">Calvin</a>, <a href="https://github.com/phderome">Phil</a>, and <a href="https://github.com/jdegoes">John</a> for helping me to write this post and for their mentoring.</p>

</div>
  <footer class="post-footer">



<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share Newtype on twitter"
        href="https://twitter.com/intent/tweet/?text=Newtype&amp;url=https%3a%2f%2ffrancistoth.github.io%2fposts%2f2020-04-11-newtypes%2f&amp;hashtags=">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Newtype on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2ffrancistoth.github.io%2fposts%2f2020-04-11-newtypes%2f&amp;title=Newtype&amp;summary=Newtype&amp;source=https%3a%2f%2ffrancistoth.github.io%2fposts%2f2020-04-11-newtypes%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Newtype on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2ffrancistoth.github.io%2fposts%2f2020-04-11-newtypes%2f&title=Newtype">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Newtype on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2ffrancistoth.github.io%2fposts%2f2020-04-11-newtypes%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Newtype on whatsapp"
        href="https://api.whatsapp.com/send?text=Newtype%20-%20https%3a%2f%2ffrancistoth.github.io%2fposts%2f2020-04-11-newtypes%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Newtype on telegram"
        href="https://telegram.me/share/url?text=Newtype&amp;url=https%3a%2f%2ffrancistoth.github.io%2fposts%2f2020-04-11-newtypes%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

  </footer>
</article>
    </main><footer class="footer">
    <span>&copy; 2020 <a href="https://francistoth.github.io">Francis Toth / Contramap</a></span>
    <span>&middot;</span>
    <span>Powered by <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a></span>
    <span>&middot;</span>
    <span>Theme <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a></span>
</footer>
<button class="top-link" id="top-link" type="button" aria-label="go to top" title="Go to Top (Alt + G)" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6">
        <path d="M12 6H0l6-6z" /></svg>
</button>



<script defer src="https://francistoth.github.io/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js" integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w="
    onload="hljs.initHighlightingOnLoad();"></script>
<script>
    window.onload = function () {
        if (localStorage.getItem("menu-scroll-position")) {
            document.getElementById('menu').scrollLeft = localStorage.getItem("menu-scroll-position");
        }
    }
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };
    mybutton.onclick = function () {
        document.body.scrollTop = 0;
        document.documentElement.scrollTop = 0;
        window.location.hash = ''
    }

    function menu_on_scroll() {
        localStorage.setItem("menu-scroll-position", document.getElementById('menu').scrollLeft);
    }

</script>

</body>

</html>

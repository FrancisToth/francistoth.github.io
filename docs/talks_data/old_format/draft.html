
<!-- ####################################################################################################### -->
<!-- ####################################################################################################### -->
<!-- ####################################################################################################### -->
<!-- ####################################################################################################### -->

<!--
    taking the result of a computation to create another one: combination using different types of combinators which
    abstract the control-flow and this is why we talk about data-flow

    In the same way, the compiler could also save memory storage. One common criticism when it comes to
    Functional Programming, is that because expressions are immutable, Functional Programming requires ----
    persistent data structures

    So Referential Transparency is a very good case for parallelism and data streaming.



    As expressions always return something, you can leverage this and create pipelines.

    create larger blocks from smaller ones



    - optimize the way a program is evaluated (opens doors to parallelism and storage optimization)
    - provides an awesome way to represent very abstract concepts like infinity using recursion, which brings us
      to the concept of composition
    - encourages composition using combinators

composition
noun 1. the act of combining parts or elements to form a whole.


    What does prevent composition? Side-effects, dead end functions, types not aligning, lack of recursion?
    things compose as long as the value they generate do not have lifecycle
    lowest common interface, generic, small unit, laws.






    val loop = ReadLine(process, loop)



   - parallelism
   - evaluation order

   - pipeline
   - pipeline are built using combinators




   It also makes code easier to reason about as you don't need anymore to
   mentally re


Apart from making the code more readable and easier to reuse, What’s so great about Referential Transparency?

represent concepts like infinity, powerfull technique to represent concepts

Well, boys and girls, welcome to the wonderful world of simultaneity! Now, how are you going to deal with it?



    So Referential Transparency allows code to be easier to reason about, and also to keep the code easier to
    reuse, more testable, .



    -> We talked about the contract functions should hold but not really talk about how they...
    - Currying, Partial Application
    - Higher Orders Functions ; Compose, map, filter, reduce -> allows to abstract the control-flow and to let
      the compiler decides about how the function should be executed. Another way to separate the what from the
      how.

    - Instead of the Functor we could talk about Monoids.

    - We can also abstract those functions using Functors for example. All those functions can


    - evaluation order problem
    - Pattern Matching
    - Algebraic Data types
    - Type classes (vs Interfaces: https://stackoverflow.com/questions/8122109/difference-between-oop-interfaces-and-fp-type-classes)

    - Methods declaration are separated from the type, allowing multiple implementations for the same method
    - Multiple objects of the type as parameter (Integer.compareTo(Double))
    - Typeclasses can be defined for types constructors, not only for types
    - can apply more constraints than just "Has to implement these interfaces"

    - OOP supports dynamic dispatch, Type classes support them using existential types.
-->











<!-- So Referential Transparency and the concept of pushing side-effects towards an architecture peripheries are
     among the key concepts of Functional Programming. This could be the end of this talk however, there is one
     aspect we did not cover without which Functional Programming would never had so much success.

     As you all know, Composition is the cornerstone of any successful design, and it's usually the lack of it
     that leads a software to a catastrophe. But what is composition? Well basically, it's all about having
     small reusable blocks that can be composed into larger blocks. In OOP, this is done at the object level.
     Functional Programming on the other hand tackles this problem on the function level and provides therefore
     various ways to compose, decompose and form new functions from other ones.

     - Higher Order Functions, Currying, Partial Application

     Functions compose very well but as we seen it earlier, their effects have to be explicit in order to
     achieve Referential Transparency. Therefore, we cannot just return functions, we sometime need more
     explicit types like Either or Maybe. So, the remaining question, how can does types can be composed. Well,
     just like the compose function, those types can be composed using combinators, among which there are probably
     some you are pretty familiar with. Let's look at the map function for example.

     So the map function allows you to change the resulting value of a computation like Maybe or Either without
     actually ....This is pretty much the compose combinator of a function

     compose: (A => B) + (B => C) = (A => C)

     map:     F[A] + (A => B)       = F[B]
     filter:  F[A] + (A => Boolean) = F[A]
     fold:    F[A] + (A, A) => A    = F[A]

     Algebra, Laws (applied to combinators) + Functor



     compose, curry, partial_app are combinators for the function type
     complex types have their own set of combinators, which also define their abstraction type (Functor)

     "I need an effect than can mapped over." - talk about sequence, or reduce?

 -->


<section data-transition="none none">
    <h2>Composition</h2>
    <section data-transition="none none">
        <aside class="notes">
            So far, we've seen how functions can become referentially transparent, but did not really
            addressed the problem of composition. Composition is the cornerstone of any successful design,
            and it's usually the lack of it that leads a software to a catastrophe.<br/><br/>

            In Functional Languages, Functions are first class citizens and are treated just like any other
            values. So you can pass functions to other functions, return functions from other functions and so
            forth. <br/><br/>

            In this example, I've created two functions, that can be combined using the compose function, and
            form another function called add1AndSub2. Functions like compose are actually called Higher order
            functions. So whenever a function takes or return another one, it is considered as a higher order
            function. Any question regarding the syntax ?
        </aside>

        <!-- Put the syntax of the function back on the top of this slide
                <section>
    <h2>Functions</h2>
    <section data-transition="none none">
        <pre class="customcode" style="background-color: #4F4F4F"><span class="hljs-function"><span class="hljs-keyword" style="margin-left:7px">def</span> <span class="hljs-title">name</span><span style="color: #00CC33;">(arg: Type,...)</span>:</span> <span class="hljs-type" style="color: #3399FF;">Returned_Type</span> = <span style="color: #FF6600;">body</span></pre>
        <div style="visibility: hidden">
            <pre class="customcode"><span class="hljs-function"><span class="hljs-keyword" style="margin-left:7px">def</span> <span class="hljs-title">substract</span><span style="color: #00CC33;">(x:Int, y:Int)</span>:</span> <span class="hljs-type" style="color: #3399FF;">Int</span> = <span style="color: #FF6600;">{ x - y }</span></pre>
            <pre class="customcode"><span class="hljs-function"><span class="hljs-keyword" style="margin-left:7px">def</span> <span class="hljs-title">printHelloWorld</span>:</span> <span class="hljs-type" style="color: #3399FF;">Unit</span> = <span style="color: #FF6600;">println("hello world !")</span></pre>
            <pre><code class="scala">def foo(): Int = {
                def bar(): Int = { ... }
            }</code></pre>
            Anonymous
            <pre class="customcode" style="background-color: #4F4F4F"><span class="hljs-function"><span class="hljs-keyword" style="margin-left:7px">val</span> <span class="hljs-title">name</span>:</span> <span class="hljs-type" style="color: #00CC33;">(arg type,...)</span> =&gt; <span class="hljs-type" style="color: #3399FF;">Returned Type</span> = <span style="color: #FF6600;">body</span></pre>
            <pre class="customcode"><span class="hljs-function"><span class="hljs-keyword" style="margin-left:7px">val</span> <span class="hljs-title">multiply</span>:</span> <span style="color: #00CC33;">(<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>)</span> =&gt; <span class="hljs-type" style="color: #3399FF;">Int</span> = <span style="color: #FF6600;">(x,y) =&gt; x * y</span></pre>
        </div>


                <section>
    <h2>Higher Order Functions</h2>
    <section data-transition="none none">
        <div class="fragment">
            <pre class="customcode" style="background-color: #4F4F4F"><span class="hljs-function"><span class="hljs-keyword" style="margin-left:7px">val</span> <span class="hljs-title">func</span>:</span> <span class="hljs-type" style="color: #00CC33;">(arg type,...)</span> =&gt; <span class="hljs-type" style="color: #3399FF;">Returned Type</span> = <span style="color: #FF6600;">body</span></pre>
            <pre class="customcode"><span class="hljs-function"><span class="hljs-keyword" style="margin-left:7px">val</span> <span class="hljs-title">multiply</span>:</span> <span style="color: #00CC33;">(<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>)</span> =&gt; <span class="hljs-type" style="color: #3399FF;">Int</span> = <span style="color: #FF6600;">(x,y) =&gt; x * y</span></pre>
        </div>

        <pre class="fragment customcode"><span class="hljs-function"><span class="hljs-keyword" style="margin-left:7px">val</span> <span class="hljs-title">foo</span>:</span> <span class="hljs-type" style="color: #00CC33;">Int</span> =&gt; <span class="hljs-type" style="color: #3399FF;">Int</span> = <span style="color: #FF6600;">x => x + 1</span>
<span class="hljs-function"><span class="hljs-keyword" style="margin-left:7px">def</span> <span class="hljs-title">bar</span>(</span><span class="hljs-type" style="color: #00CC33;">f: Int => Int</span>, </span><span class="hljs-type" style="color: #00CC33;">number: Int </span>): <span class="hljs-type" style="color: #3399FF;">Int</span> = <span style="color: #FF6600;">f(number)</span>
<span class="hljs-function" style="margin-left:7px">bar</span>(<span class="hljs-type" style="color: #00CC33;">foo, 41</span>)<span class="hljs-comment"> // returns 42</span></pre>

        <div style="visibility: hidden">

        <pre class="customcode"><span class="hljs-function"><span class="hljs-keyword" style="margin-left:7px">def</span> <span class="hljs-title">bar</span>(</span><span class="hljs-type" style="color: #00CC33;">f: Int => Int</span>): <span class="hljs-type" style="color: #3399FF;">(Int, Int) => Int</span> = <span style="color: #FF6600;">(x, y) => f(x + y)</span>
<span class="hljs-function" style="margin-left:7px">bar</span>(<span class="hljs-type" style="color: #00CC33;">x => x * 2</span>)(<span class="hljs-type" style="color: #00CC33;">2</span>, <span class="hljs-type" style="color: #00CC33;">3</span>)<span class="hljs-comment"> // returns 10</span></pre></pre>

        <div>
            Multiple-argument-list function
            <pre class="customcode"><span class="hljs-function"><span class="hljs-keyword" style="margin-left:7px">def</span> <span class="hljs-title">reduce</span>(<span style="color: #00CC33;">combine: (Int, Int) => Int</span>)
  <span style="margin-left:7px">(</span><span style="color: #00CC33">x: Int</span>, <span style="color: #00CC33;margin-left:7px">y: Int</span>):</span> <span class="hljs-type" style="color: #3399FF;">Int</span> = <span style="color: #FF6600;">combine(x, y)</span></pre>
            <pre class="customcode"><span class="hljs-function"><span class="hljs-keyword" style="margin-left:7px">val</span> <span class="hljs-title">sum</span>:</span> <span class="hljs-type" style="color: #00CC33;">(Int, Int)</span> =&gt; <span class="hljs-type" style="color: #3399FF;">Int</span> = <span style="color: #FF6600;">reduce((x,y) => x + y)</span>
<span class="hljs-function" style="margin-left:7px">sum</span>(<span class="hljs-type" style="color: #00CC33;">1, 2</span>)<span class="hljs-comment"> // returns 3</span></pre>
        </div>
    </div>
    </section>

        -->

        <pre class="customcode" style="background-color: #4F4F4F"><span class="hljs-function"><span class="hljs-keyword" style="margin-left:7px">def</span> <span class="hljs-title">name</span><span style="color: #00CC33;">(arg: Type,...)</span>:</span> <span class="hljs-type" style="color: #3399FF;">Returned_Type</span> = <span style="color: #FF6600;">body</span></pre>
        <div >
            <pre class="customcode"><span class="hljs-function"><span class="hljs-keyword" style="margin-left:7px">def</span> <span class="hljs-title">substract</span><span style="color: #00CC33;">(x:Int, y:Int)</span>:</span> <span class="hljs-type" style="color: #3399FF;">Int</span> = <span style="color: #FF6600;">{ x - y }</span></pre>
            <pre class="customcode"><span class="hljs-function"><span class="hljs-keyword" style="margin-left:7px">def</span> <span class="hljs-title">printHelloWorld</span>:</span> <span class="hljs-type" style="color: #3399FF;">Unit</span> = <span style="color: #FF6600;">println("hello world !")</span></pre>
            Functions as Types
            <pre class="customcode" style="background-color: #4F4F4F"><span class="hljs-function"><span class="hljs-keyword" style="margin-left:7px">val</span> <span class="hljs-title">name</span>:</span> <span class="hljs-type" style="color: #00CC33;">(arg: type,...)</span> =&gt; <span class="hljs-type" style="color: #3399FF;">Returned Type</span> = <span style="color: #FF6600;">body</span></pre>
            <pre class="customcode"><span class="hljs-function"><span class="hljs-keyword" style="margin-left:7px">val</span> <span class="hljs-title">multiply</span>:</span> <span style="color: #00CC33;">(<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>)</span> =&gt; <span class="hljs-type" style="color: #3399FF;">Int</span> = <span style="color: #FF6600;">(x,y) =&gt; x * y</span></pre>
        </div>

        <!--<pre class="fragment"><code class="scala" data-trim data-noescape style="font-size: 1.5em; line-height: 1.2em">-->
        <!--val add1: Int => Int = (i:Int) => i + 1-->
        <!--val sub1: Int => Int = (i:Int) => i - 2-->

        <!--def compose[A, B, C](-->
        <!--f: B => C,-->
        <!--g: A => B,-->
        <!--): A => C = { a => f(g(a)) }-->

        <!--val add1AndSub2 = compose(add1, sub2)-->
        <!--add1AndSub1(1) == 0-->
        <!--</code></pre>-->
    </section>

    <!--Let's go back to a previous-->
    <!--example<br/><br/>-->

    <!--As we've seen it, the Either type represents a value that may have one type or the other. We've-->
    <!--also seen that Pattern Matching allows us to extract the value obtained through this kind of type.<br/><br/>-->

    <!--So let's think about how expressions can be composed without losing all the benefits of Referential-->
    <!--Transparency.Let's say we'd like to represent a computation that updates the result obtained through-->
    <!--a successful Either<br/><br/>-->

    <!--We basically need a function allowing the update of those-->
    <!--containers values without having to extract them. This sounds a lot like polymorphism.-->




    <!--

    So Referential Transparency is one key concept of Functional Programming.

    Whether they are functions or simple constants, referentially transparent expressions are the core idea of
    Functional Programming, as they
    * Evaluation order
    *



    Using referentially transparent expressions


     but did not really
    addressed the problem of composition. Composition is the cornerstone of any successful design,
    and it's usually the lack of it that leads a software to a catastrophe.

    In Functional Program


<section data-transition="none none">
            <h2>Order of Execution</h2>
                        <section data-transition="none none">
                            <aside class="notes">
                                This leads to another aspect of Functional Programming which is the abstraction of the control-flow.
                                Because, we let the compiler/interpreter decides about the execution of the program, we never really
                                have to express how a set of expressions has to be performed. We rather focus on the specification
                                of the problem and its declaration. This is actually the reason why Pure Functional Languages do not
                                provide control-flow statements such as loops, goto, for-each, etc...<br/><br/>

                                As we

                                Instead, they provide clever ways to clearly express the different aspects of a problem using
                                recursion, pattern matching and composition. Composition is the cornerstone of any successful design,
                                and it's usually the lack of it that leads a software to a catastrophe. It's therefore no wonder
                                that Functional Programming provides very subtle mechanisms to maintain a high level of composition.<br/><br/>
                            </aside>
                            <pre><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.2em">
            trait Program
            case class Uppercase(s: String)            extends Program
            case class Compose(a: Program, b: Program) extends Program
            case class Return(s: String)               extends Program

            interpret(Concat(Uppercase("hello"), UpperCase("world")))

            def interpret(program: Program): Unit = program match {
               case Concat(a, b) => parallel(interpret(a), interpret(b)).reduce(_ + _)
               case Uppercase(s) => Return(s.toUpperCase)
               case Return(r)    => println(r)
            }

            def parallel(ps: Program*): List[String] = ???
                            </code></pre>
                        </section>
                    </section>

                    <section data-transition="none none">
                        <aside class="notes">

                        </aside>
                    </section>




        <!-- Relies heavily on composition, expressions very small blocks that are composed with each others, but
         we did not really talk about those mechanisms work-->


    <section data-transition="none none">
        <aside class="notes">
            Now when you think about it, modeling a problem using referential transparent functions comes back to design
            a stateless pipeline which takes the problem's input and outputs a solution. Many times while reading about
            Functional Programming, you'll see that this paradigm tends indeed to represent a program as a singular
            function composed of many others. This is actually why Functional Programming puts so much emphasis on
            function composition.
        </aside>
    </section>
    <section data-transition="none none">
        <aside class="notes">
            In Functional Languages, Functions are first class citizens and are treated just like any other values.
            So you can pass functions to other functions, return functions from other functions and so forth:
            <br/><br/>
            In this example, I've created two functions, that can be combined using the compose function, and
            form another function called add1AndSub2. Functions like compose are called Higher order functions.
            So whenever a function takes or return another one, it is considered as a higher order function.
            Any question regarding the syntax ?
        </aside>
        <pre class="fragment"><code class="scala" data-trim data-noescape style="font-size: 1.5em; line-height: 1.2em">
val add1: Int => Int = (i:Int) => i + 1
val sub1: Int => Int = (i:Int) => i - 2

def compose[A, B, C](
  f: B => C,
  g: A => B,
): A => C = { a => f(g(a)) }

val add1AndSub2 = compose(add1, sub2)
add1AndSub1(1) == 0
            </code></pre>
    </section>
    <section data-transition="none none">
        <aside class="notes">
            Alright. Functional Programming puts obviously a big focus on functions, and therefore provides
            various ways to compose and decompose them. You can for example create a new function from another
            one by decomposing it using currying:
            <br/><br/>
            Currying consists in transforming a function of arbitrary arity into a composition of unary
            functions. So a function that takes two arguments, once curried, returns a one-argument function
            returning another one argument function which finally produces the final result once called.
        </aside>
        <pre><code class="scala" data-trim data-noescape style="font-size: 1.5em; line-height: 1.2em">
&nbsp; (Int, Int) => Int becomes Int => Int => Int</code></pre>
        <pre><code class="scala" data-trim data-noescape style="font-size: 1.4em; line-height: 1.3em">
val sum:     (Int, Int) => Int = (x, y) => x + y
val curried: Int => Int => Int = x => (y => x + y)

curried(1)(3) == 4
            </code></pre><br/>
        <div style="font-size: 30px; margin:0; padding:0; text-align: left"><i>"Currying is the technique of translating the evaluation of
            a function that takes multiple arguments into evaluating a sequence of functions, each with a single
            argument."</i> - Wikipedia</div>
    </section>
    <section data-transition="none none">
        <aside class="notes">
            A very close concept is Partial Application, which consists in producing a function of reduced
            arity by binding fixed values to some of the original function's arguments.
            <br/><br/>
            So you can think about currying like a technique to create constructors for Functions, that let you
            decouple construction from invocation.
        </aside>
        <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.3em">
val f3: (Int, Int, Int) => Int = (x, y, z) => x + y + z
val f2: (Int, Int) => Int = f3(0, _, _)

f2(40, 2) == 42
                </code></pre><br/>
        <div style="font-size: 30px; margin:0; padding:0; text-align: left"><i>"Partial application refers to the process of fixing a number of arguments to a function, producing
            another function of smaller arity"</i> - Wikipedia</div>
    </section>









    Traditionally, we rely on control-flow statements like for-loops to tell the program how a computation
    should be done.

    On abstrait le control-flow pour le rendre plus composable

    Concretely, this means that we do not use any statement like for-loops, yields or gotos that would give
    a hint about the order of execution. Having said that, we still need sometime to represent concepts like
    computation dependency
    </aside>
    <pre><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.2em">
Concat(Uppercase("hello"), UpperCase("world"))
            </code></pre>
    <pre><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.2em">
Read { line => Write(line, loop) }
            </code></pre>
    <pre><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.2em">
Maybe(mayReturnNull(/*...*/))
            </code></pre>
</section>









<section data-transition="none none">
    Examples of how functions are composed using currying and partial application


    All those functions are actually called combinators
    they abstract the control flow,

    compose(g: A => B, f: B => C): A => C = f(g(_))

    So far we'e combined computations having the Function type: A => B but what about other types like
    Either or Maybe for example.

    case class Func[A, B](f: A => B)
    compose(f: Func[A, B], g: B => C): Func[A, C] = Func(g(f(_)))
    def map[A, B, C](fab: Func[A, B], g: B => C): Func[A, C] = Func(a => g(fab.f(a)))
    def flatMap[A, B, C](fab: Func[A, B], g: B => Func[A, C]): Func[A, C] = Func(a => g(fab.f(a)).f(a))


    def map[A, B, C](fab: A => B, g: B => C): A => C = a => g(fab(a))
    def flatMap[A, B, C](fab: A => B, g: B => A => C): A => C = a => g(fab(a))(a)

    map[Int, Int, String](i => i +1, j => j.toString)
    flatMap[Int, String, Int](res10, s => i => s.toInt + i)
    res11(42)

    simplify functions using multiple argument list (currying) and type inference
    What about composing functions with effects like Maybe for example:

    def map[A, B](ma: Maybe[A], g: A => B): Maybe[B] = ???
    def flatMap[A, B](ma: Maybe[A], g: A => Maybe[B]): Maybe[B] = ???

    type Result[A] = Either[Exception, A]
    def map[A, B](ma: Result[A], g: A => B): Result[B] = ???
    def flatMap[A, B](ma: Result[A], g: A => Result[B]): Result[B] = ???

    // same logic, switch to algebra
</section>











<!--


     - Expressions
     - Let's talk about functions, functions are expressions
     - Referential Transparency and Side effects, What VS How etc...
     - Pattern Matching
     - Composition:
        * Composing Functions (Higher order functions, currying, partial application)
        * Returning types to make things more explicit and composition easier (what about more complex types?)
        * The need for generic combinators (map, filter, reduce)
        * Those combinators obeys laws.

        filter(_ == true) == same thing
        filter(_ == false) == emptyList
        filter(emptylist) == emptylist


        https://stackoverflow.com/questions/97637/good-explanation-of-combinators-for-non-mathematicians
        Basically so combinators allow you to construct your program's control flow (among other things) in a procedural and flexible fashion


        * Types have to align
        * Using composition to create pipeline, delay side-effect, and create effects while retrieving values
        * Returning types to make things more explicit and composition easier (what about more complex types?)

        * One abstraction: Functor.



     - Composition:
         * Composing Functions
         * Composing more complex types like Maybe
         * Functional Programming provides many patterns, and tonight we'll cover one
         * Functor: compose a computation without leaving the effect. Reduces boilerplate, and provides
           a small abstraction allowing to compose larger abstractions easily
         * Separating the what from the how (coming up with generic abstractions to express a concept without thinking about the way
           this is executed, evaluation order)
         * expression problem
         * Basic functions like map, filter, reduce etc.. (concepts of combinator and pipeline setup)

         Expressions have two main properties, they are immutable (like in Math where there is no concept
         of runtime), and referentially transparent. The direct consequence is they're easy to compose
         and prevent side-effects.

         Because RT, expressions are immutable (just like in math)
 -->






















<!-- ####################################################################################################### -->
<!-- ####################################################################################################### -->
<!-- ####################################################################################################### -->
<!-- ####################################################################################################### -->
<!-- ####################################################################################################### -->
<!-- ####################################################################################################### -->
<!-- ####################################################################################################### -->
<!-- ####################################################################################################### -->



<section data-transition="none none">
    <h2>Composition</h2>
    <section data-transition="none none">
        <aside class="notes">
            So far, we've seen how functions can become referentially transparent, but did not really
            addressed the problem of composition. Composition is the cornerstone of any successful design,
            and it's usually the lack of it that leads a software to a catastrophe. Let's go back to a previous
            example<br/><br/>

            As we've seen it, the Either type represents a value that may have one type or the other. We've
            also seen that Pattern Matching allows us to extract the value obtained through this kind of type.<br/><br/>

            So let's think about how expressions can be composed without losing all the benefits of Referential
            Transparency.Let's say we'd like to represent a computation that updates the result obtained through
            a successful Either<br/><br/>

            We basically need a function allowing the update of those
            containers values without having to extract them. This sounds a lot like polymorphism.
        </aside>
        <pre class="fragment"><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.2em">
trait Either[A, B]
case class Left[A, B](a: A)  extends Either[A, B]
case class Right[A, B](b: B) extends Either[A, B]
                </code></pre>
        <pre class="fragment"><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.2em">
val foo: Either[Exception, Int] = ???
val result = foo match {
  case Right(y) => y + 1
  case Left(ex) => ??? // what are we supposed to return here???
}
println(result)
                </code></pre>
    </section>
    <section data-transition="none none">
        <aside class="notes">
            Thanks to Pattern matching, this is pretty easy. The map function checks if the either passed
            in parameter is a success, and apply the mapping function if it's the case. Otherwise, it just
            returns the same value.

            This looks pretty good, but let's go a little bit further.
        </aside>
        <pre><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.2em">
val success: Either[Exception, Int] = Right(42)

val failure: Either[Exception, Int] =
  Left(new RuntimeException())

map( _ + 1 )(success) // returns 43
map( _ + 1 )(failure) // return failure

def map[A, B](f: A => B)
             (e: Either[Exception, A]): Either[Exception, B] =
  e match {
    case Right(v) => Right(f(v))
    case Left(e) => Left(e)
  }
                </code></pre>
    </section>
    <section data-transition="none none">
        <aside class="notes">
            So let's say, I'd like to chain two computations among which one results from the other. In order
            to do this, I could reuse the map function, but the problem is the resulting expression which is
            an Either of Either. Just think about what would be returned if you chain a dozen of Eithers.

            No. What I am really interested in is the final expression returned by the whole chain, and not
            the intermediary results.<br/><br/>

            So the chain function takes the function we'd like to chain the either with, along with the either itself.

            Questions?
        </aside>
        <pre><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.2em">
val foo: Either[Exception, Int] = ???
val bar: Int => Either[Exception, String] = ???

// meh !
val fooBar: Either[Exception, Either[Exception, String]] =
  map(bar)(foo)

val fooBar: Either[Exception, String] = chain(foo, bar)
                </code></pre>
        <pre class="fragment"><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.2em">
def chain[E, B, C](f: B => Either[E, C])
                  (e: Either[E, B]): Either[E, C] = e match {
  case Right(b) => f(b)
  case Left(e) => Left(e)
}
                </code></pre>
    </section>
    <section data-transition="none none">
        <aside class="notes">
            What's really interesting here, is that the same logic could be applied to a Maybe. So we clearly
            have a pattern here that could be abstracted. Let's get some steps back.
        </aside>
        <pre><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.2em">
def map[A, B](f: A => B)(m: Maybe[A]): Maybe[B] =
  m match {
    case Some(a) => Some(f(a))
    case None() => None()
  }

def chain[A, B](f: A => Maybe[B])(m: Maybe[A]): Maybe[B] =
  m match {
    case Some(a) => f(a)
    case None() => None()
  }
                </code></pre>
    </section>
    <section data-transition="none none">
        <aside class="notes">
            When you were in first grade, you learnt about the domain of numbers. Later, you also learnt that
            you can combine those numbers using specific operators, and that the domain of numbers is ruled by
            laws. Numbers, operators and laws, all together form an algebra. Numbers are actually what we call
            algebraic data types.<br/><br/>

            Back to our types, we probably can figure out some kind of algebra where the algebraic data
            types are the types themselves.
        </aside>
        <pre><code data-trim data-noescape style="font-size: 1.2em; line-height: 1.0em">
// Algebraic data types
1, 2, 3...

// Operations
1 + 2 = 3
3 * 2 = 6

// Laws
0 + x = x
1 * x = x
                </code></pre>
    </section>

    <section data-transition="none none">
        <aside class="notes">
            Let's first look at these mapping functions, and their characteristics. First, Just like when you
            sum 1 and 0, mapping a value with a no-op function returns the same original value, no matter
            its type.<br/><br/>

            Secondly, the map function is associative. So mapping a value over two functions sequentially is
            the same than mapping the value with a composition of those two functions.<br/><br/>

            These are the characteristics of a Functor.
        </aside>
        <pre><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.2em">
def map[A, B](f: A => B)(m: Maybe[A]): Maybe[B] = m match {
  case Some(a) => Some(f(a))
  case None() => None()
}
                </code></pre>
        <pre class="fragment"><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.2em">
def noop[A](a: A): A = a
map(noop)(foo) == foo
                </code></pre>
        <pre class="fragment"><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.2em">
val f: Int => Int = ???
val g: Int => String = ???

map(compose(f, g))(foo) == compose(map(f),map(g))(foo)
                </code></pre>
    </section>

    <section data-transition="none none">
        <aside class="notes">
            A Functor, is a type we can map on, and obeys to two laws, the identity law and the composition
            law we've just defined.<br/><br/>

            The F in the Functor trait is refered to as an effect or computational context, which, in our examples
            are Maybe or Either. Each of those can abstract different behaviors as long as they hold with the
            Functor's laws.<br/><br/>

            Concretely, a Functor is the ability to compose with a single effect without needing to “leave” the
            effect.
        </aside>
        <pre><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.0em">
trait Functor[F[_]] {
  def pure[A](a: A): F[A]
  def map[A, B](fa: F[A], f: A => B): F[A]
}               </code></pre>
        <pre><code class="haskell" data-trim data-noescape style="font-size: 1.1em; line-height: 1.0em">
# identity law
map(noop)(foo) == foo

# composition law
map(compose(f, g))(foo) == compose(map(f),map(g))(foo)
                </code></pre>
    </section>



















            <section data-transition="none none">
                <aside class="notes">
                    Alright, now we have these new tools, I'd like you to think about what a function really is compared to
                    other kind of computations like Maybe or Either. The Maybe type for instance represents a computation
                    resulting in a value or in its absence. In the same way, the Either type stands for a computation
                    resulting in a value of one type or another. So what's a function? Well it's a type that represents a
                    mapping from one value to another one which may have a different type.<br/><br/>

                    For the sake of readability, I've created a type alias for the Function type, which just like Either,
                    is parameterized with two type parameters<br/><br/>

                    Now let's say we'd like to compose a function with another one:

                    No big deal right? all we need is to create a function such as this one that maps the result of g to
                    another value using f. Let's actually rename this function to map.
                </aside>
Maybe[A]
Either[E, A]
A => B

type Function[A, B] = A => B

def f[A, B]: Function[A, B] = ???
def g[B, C]: Function[B, C] = ???

def map[E, A, B](f: A => B)
                (g: Function[E, A]): Function[E, B] =
  (a: A) => f(g(a))
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    What about other type of computations like Either or Maybe? Can we re-use the same principle? Well,
                    yes, this is possible thanks to Pattern Matching:<br/><br/>

                    Interesting. So the same logic can be re-used. Clearly, we have some kind of hidden pattern that
                    could be generalized like this:<br/><br/>

                    So Mappable represents a type that can be mapped over. Given a container of type F, it's possible to
                    modify its wrapped value while keeping its structure. What's the point of doing this?
                    Well, think about how we would compose a function with a Maybe. We would probably end up in a scenario
                    similar to this one:
                </aside>

def map[E, A, B](f: A => B)
                (e: Either[E, A]): Either[E, B] = e match {
  case Right(b) => Right(f(a))
  case Left(e)  => Left(e)
}

def map[A, B](f: A => B)
             (m: Maybe[A]): Maybe[B] = m match {
  case Some(a) => Some(f(a))
  case None    => None
}

trait Mappable[F[_]] {
  def map[A, B](f: A => B)(fa: F[A]): F[B]
}
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    The problem here is while pattern matching against the maybe value, we are providing information
                    about how the absence of value should be interpreted. What are we supposed to return in case of a None?
                    Should that be a default value? Of course not. We'd rather avoid taking any decision for the interpreters
                    of this computation, as they may interpret the absence of a value in very different ways. So we'd like
                    to preserve the structure of the Maybe, and therefore not loose any information, while keeping it
                    composable. That's the Mappable trait's purpose.
                </aside>
val f: Int => String = ???
val m: Maybe[Int] = ???

val x: ??? = m match {
  case Some(i) => f(i)
  case None => ???
}
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    Alright now, how can we implement an instance of the Mappable trait, well let's try with Maybe:

                    As this is a generic pattern, we can also do the same with the Either type:

                    The only trick here is that as Mappable works only with types parameterized with a single parameter, we
                    have to create a type alias of the Either type. So we bind the left value type to the Exception type.
                    In the same way, we created an alias for a functions returning a value from a configuration.
                </aside>

implicit val maybeMappable: Mappable[Maybe] = new Mappable[Maybe] {
  def map[A, B](f: A => B)(ma: Maybe[A]): Maybe[B] = ma match {
    case Some(a) => Some(f(a))
    case None => None
  }
}

type Result[A] = Either[Exception, A]

implicit val resultMappable: Mappable[Result] = new Mappable[Result] {
  def map[A, B](f: A => B)(ma: Result[A]): Result[B] = ma match {
    case Right(a) => Right(f(a))
    case Left(e) => Left(e)
  }
}

type Conf[A] = Configuration => A

implicit val configurationMappable: Mappable[Conf] = new Mappable[Conf] {
  def map[A, B](f: A => B)(ca: Conf[A]): Conf[B] = { (c: Configuration) => f(ca(c)) }
}
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    Let's go a bit further with this idea. Now that we've generalized this idea, we can re-use it in other
                    contexts. Let's say that we need to create a function that maps a wrapped Integer to a wrapped String
                    no matter the container, as long as an instance of Mappable typed with that container exists:<br/><br/>

                    This is pretty awesome right? So whenever you need the int2String function to handle a new type, all
                    you have to do is to write an instance of Mappable for that type. The int2String function does not
                    even need to be touched.<br/><br/>

                    Alright, I'd like you to take a few steps back now.
                </aside>
def int2String[F[_]: Mappable](fi: F[Int]): F[String] = {
  val mapper: Mappable[F] = implicitly[Mappable[F]] // explain implicits if needed.
  mapper.map(fi) { _.toString }
}

val mi: Maybe[Int] = ???
val ms: Maybe[String] = int2String(mi)

val ei: Either[Exception, Int] = ???
val es: Either[Exception, String] = int2String(ei)

val ci: Conf[Int] = ???
val cs: Conf[String] = int2String(ci)
            </section>

            <section data-transition="none none">
                <aside class="notes">
                    When you were in first grade, you learnt about the domain of numbers. Later, you also learnt that
                    you can combine those numbers using specific operators, and that the domain of numbers is ruled by
                    laws. Numbers, operators and laws, all together form an algebra. Numbers are actually what we call
                    algebraic data types.<br/><br/>

                    Back to our types, we probably can figure out some kind of algebra where the algebraic data
                    types are the types themselves.
                </aside>
                <pre><code data-trim data-noescape style="font-size: 1.2em; line-height: 1.0em">
// Algebraic data types
1, 2, 3...

// Operations
1 + 2 = 3
3 * 2 = 6

// Laws
0 + x = x
1 * x = x
                </code></pre>
            </section>

            <section data-transition="none none">
                <aside class="notes">
                    Let's first look at our Mappable trait, and its characteristics. First, Just like when you
                    sum 1 and 0, mapping a value with a no-op function returns the same original value, no matter
                    its type.<br/><br/>

                    Secondly, the map function is associative. So mapping a value over two functions sequentially is
                    the same than mapping the value with a composition of those two functions.<br/><br/>

                    These are the characteristics of a Functor.
                </aside>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.2em">
trait Mappable[F[_]] {
  def map[A, B](f: A => B)(fa: F[A]): F[B]
}

val m: Mappable[F] = ???
val fA: F[A] = ???
                </code></pre>
                <pre class="fragment"><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.2em">
def noop[A](a: A): A = a
m.map(noop)(fA) == fA
                </code></pre>
                <pre class="fragment"><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.2em">
val f: Int => Int = ???
val g: Int => String = ???

val fog : Int => String = compose(f, g)
val mFog: Int => String = compose(m.map(f), m.map(g))

m.map(gof)(fA) == mFog(fA)
                </code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    A Functor, is a type we can map over which obeys to two laws, the identity law and the composition
                    law we've just defined.<br/><br/>

                    The F in the Functor trait is referred to as an effect or computational context, which, in our examples
                    are Maybe or Either. Each of those can abstract different behaviors as long as they hold with the
                    Functor's laws.<br/><br/>

                    Concretely, a Functor is the ability to compose with a single effect without needing to “leave” the
                    effect.
                </aside>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.0em">
trait Functor[F[_]] { // similar to Mappable[F[_]]
  def pure[A](a: A): F[A]
  def map[A, B](f: A => B)(fa: F[A]): F[A]
}               </code></pre>
                <pre><code class="haskell" data-trim data-noescape style="font-size: 1.1em; line-height: 1.0em">
# identity law
m.map(noop)(fA) == fA

# composition law
m.map(gof)(fA) == mFog(fA)
                </code></pre>
            </section>
        </section>
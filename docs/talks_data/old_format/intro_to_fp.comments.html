<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">

    <title>Introduction to Functional Programming - by Francis Toth</title>

    <meta name="description" content="A framework for easily creating beautiful presentations using HTML">
    <meta name="author" content="Hakim El Hattab">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/custom.css">
    <link rel="stylesheet" href="css/theme/francis.css" id="theme">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
</head>

<body>


<aside style="display: block; position: fixed; bottom: 10px; right: 10px; z-index: 30;">
    <a href="http://www.yoppworks.com"><img src="images/yoppworks.logo-corner-dark.png"  height="30"></a>
</aside>
<aside style="display: block; position: fixed; bottom: 0px; left: 10px; z-index: 30;">
    <a href="https://www.meetup.com/lambda-montreal/"><img src="images/logo.lambda_montreal.jpeg"  height="100"></a>
</aside>

<div class="reveal">
    <div class="slides">
        <section>
            <aside class="notes">
                Hello everyone,<br/>

                First of all, thank you all for being here tonight. To be honest I wasn't expecting so many people, so I'm glad to
                see so much interest in Functional Programming. I've read somewhere that when you start understanding Functional
                Programming, you become unable to explain it. Well, I'll do my best tonight, and hope you'll be satisfied with it.
                <br/><br/>
                Before starting, how many of you guys are not familiar with Scala? Well, the examples in this talk are all in Scala
                but if you are not familiar with the language, that should be ok. In any case, if during this talk, there is
                something you don't understand, please interrupt me, I'll be glad to help you.
                <br/><br/>
                Secondly, I'm far from being a Functional Programming expert and I may not be accurate sometime. If this
                happens, and you think you can contribute to this talk, please do. You will be very welcome.
                <br/><br/>
                By the way, how many of you guys consider themselves as Functional Programming experts? Same question but for those
                who feel like intermediate? Alright, any beginners? So, I don't know about you guys, but the first time I've learnt
                about Functional Programming, It sounded like jibberish to me. Functional Programming can be indeed very
                obscure some time as it has deep abstract mathematical roots. Fortunately, we won't cover those today
                and will instead tackle Functional Programming from a very practical angle.
                <br/><br/>
                Alright, let's get this started.
            </aside>

            <h2 style="display: inline-block;"><img style="vertical-align: text-bottom; margin: -2px 0; border: 0; background-color: #243044" src="images/intro_to_fp/haskell-logo.png" width="11%"/> Functional Programming</h2>
        </section>

        <section>
            <h2>Expressions Oriented</h2>
            <section data-transition="none none">
                <aside class="notes">
                    Ok so first of all, Functional Programming is based on expressions. An expression, is a finite combination
                    of symbols well-formed according a set of rules which produces a value. Those symbols can be
                    constants, operators, functions or even other expressions:
                    <br/><br/>
                    In Functional code, an expression has to be referentially transparent. In other words, replacing it
                    by the value it produces should not affect a program's output in any way. This is referred to the
                    substitution model which is something you are actually all familiar with since first grade.
                    <br/><br/>
                    In Functional Programming, expressions are indeed evaluated just like mathematical
                    expressions. So the evaluation process of an expression, goes on and on until it cannot be reduced
                    no more and a value is produced.
                </aside>
                <pre><code data-trim data-noescape style="font-size: 1.5em; line-height: 1.2em">42
x = 41 + 1
y = x * 2
z = add(x, 2)</code></pre>
                <pre class="fragment"><code data-trim data-noescape style="font-size: 1.5em; line-height: 1.2em">x = 42
y = x + 1 == 42 + 1</code></pre>
                <pre class="fragment"><code data-trim data-noescape style="font-size: 1.5em; line-height: 1.2em">x = (2 * 2) + (3 * 4)
x = 2 * 2 + 3 * 4
x = 4 + 12
x = 16</code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    Let's talk a bit about functions now. We said that functions are also expressions, right?. Well, in
                    Functional Languages, Functions are first class citizens and are treated just like any other values.
                    So you can pass functions to other functions, return functions from other functions and so forth:
                    <br/><br/>
                    In this example, I've created two functions, that can be combined using the compose function, and
                    form another function called add1AndSub2. That's way too many functions in two sentences. Anyway.
                    Functions like compose are called Higher order functions. So whenever a function takes or return
                    another one, it is considered as a higher order function. Any question regarding the syntax ?
                </aside>
                <pre class="fragment"><code class="scala" data-trim data-noescape style="font-size: 1.5em; line-height: 1.2em">
val add1: Int => Int = (i:Int) => i + 1
val sub1: Int => Int = (i:Int) => i - 2

def compose[A, B, C](
  f: B => C,
  g: A => B,
): A => C = { a => f(g(a)) }

val add1AndSub2 = compose(add1, sub2)
add1AndSub1(1) == 0
                </code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    Alright. Functional Programming puts obviously a big focus on functions, and therefore provides
                    various ways to compose and decompose them. You can for example create a new function from another
                    one by decomposing it using currying:
                    <br/><br/>
                    Currying consists in transforming a function of arbitrary arity into a composition of unary
                    functions. So a function that takes two arguments, once curried, returns a one-argument function
                    returning another one argument function which finally produces the final result once called.
            </aside>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.5em; line-height: 1.2em">
&nbsp; (Int, Int) => Int becomes Int => Int => Int</code></pre>
            <pre><code class="scala" data-trim data-noescape style="font-size: 1.4em; line-height: 1.3em">
val sum:     (Int, Int) => Int = (x, y) => x + y
val curried: Int => Int => Int = x => (y => x + y)

curried(1)(3) == 4
            </code></pre><br/>
            <div style="font-size: 30px; margin:0; padding:0; text-align: left"><i>"Currying is the technique of translating the evaluation of
                a function that takes multiple arguments into evaluating a sequence of functions, each with a single
                argument."</i> - Wikipedia</div>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    A very close concept is Partial Application, which consists in producing a function of reduced
                    arity by binding fixed values to some of the original function's arguments.
                    <br/><br/>
                    So you can think about currying like a technique to create constructors for Functions, that let you
                    decouple construction from invocation.
                </aside>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.3em">
val f3: (Int, Int, Int) => Int = (x, y, z) => x + y + z
val f2: (Int, Int) => Int = f3(0, _, _)

f2(40, 2) == 42
                </code></pre><br/>
                <div style="font-size: 30px; margin:0; padding:0; text-align: left"><i>"Partial application refers to the process of fixing a number of arguments to a function, producing
                another function of smaller arity"</i> - Wikipedia</div>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    Now as they are expressions, functions also have to be Referentially Transparent. So how does a
                    Function can hold this contract?
                    <br/><br/>
                    Well in order to be Referentially Transparent, a Function must have three properties. It has to be
                    <br/><br/>
                    <b>Total</b>: that is every input has to be mapped with an output<br/>
                    <b>Pure</b>: A function's only effect is the computation of its returning value<br/>
                    <b>Deterministic</b>: Given the same input, a function has to always return the same output<br/>
                    <br/><br/>
                    In the next slides, we'll see what prevents a function to hold these rules, along with the solutions
                    to enforce them.
                </aside>
                <ul>
                    <li class="fragment"><span style="color:#42BAE8"><b>Total</b></span>: A function must yield a value for <i>every</i> possible input.</li>
                    <li class="fragment"><span style="color:#42BAE8"><b>Pure</b></span>: A function’s only effect must be the computation of its return value</li>
                    <li class="fragment"><span style="color:#42BAE8"><b>Deterministic</b></span>: A function must yield the <i>same</i> value for the <i>same</i> input.
                        <br/><br/><br/>
                        <div style="text-align: right"><span style="font-size: 20px">
                            Taken from <i>"A Beginner-Friendly Tour through Functional Programming in Scala"</i>.<br/><b>John A De Goes</b>.
                        </span></div>
                    </li>
                </ul>
            </section>
        </section>
        <section data-transition="none none">
            <h2>Inputs / Outputs</h2>
            <section data-transition="none none">
                <aside class="notes">
                    Alright, let's hold on a minute and think about what are the inputs and the outputs of a function.
                    <br/><br/>
                    The function 'foo' takes a String and returns an Integer. Simple enough. Now what about the 'bar'
                    function? Just like 'foo', it takes a String, returns an Integer but also outputs another String in
                    the console. So 'bar' has two outputs: the resulting integer and the String written in the console.
                    In Functional code, this is what we call a side-effect. Let's see some others examples:
                </aside>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.5em; line-height: 1.2em">
def foo(number: String): Int = number.toInt

def bar(input: String): Int = { 
  println("performing bar")
  foo(input)
}</code></pre>
            </section>
        </section>
        <section data-transition="none none">
            <h2>Side Effects</h2>
            <section data-transition="none none">
                <aside class="notes">
                    In those examples, beside returning a value, those two functions may respectfully throw an exception
                    or return a null value.
                    <br/><br/>
                    The problem with exceptions is that there is absolutely no guarantee about where they will occur.
                    So they can occur everywhere. Just like with nulls, exceptions lead you to set up aggressive
                    exception handling, even in cases where it doesn't make any sense, which lead you to even more weird
                    situations.
                    <br/><br/>
                    Those who worked on wide legacy codebases know what I am talking about. You know that situation
                    when you ask a guy why he is using a try-catch for no reason, and the guy answers, "Well, you know,
                    just in case of". Exceptions and Nulls prevent a function from being total, as given an input, they
                    may return nothing.
                </aside>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
def parse(integer: String): Int = {
  if(numberIsNotAString(number)) {
    throw new IllegalArgumentException(/*...*/)
  } else {
    // parsing logic returning parsed integer
  }
}</code></pre>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
def ask(question: String): String = {
  if(question == "What's the meaning of life?") {
    "42"
  else
    null // does not compile in Scala
}</code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    Another example, so here, the add1 function is responsible for incrementing the integer passed in argument.
                    But once called, it also gets the value of n, and increments it. Referential transparency is clearly
                    broken here as replacing the add1 function call by its resulting expression changes the output of
                    the program. So this function's effect cannot be obtain just by computing its resulting value
                    which means it's not pure.
                </aside>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
var n = 41
def add1(y: Int): Int = { 
  n = n + 1
  y + 1
}
// ...
val m = add1(41)
assert(n == 42)</code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    Last example, in this case, we still have a situation where exceptions could happen, but this
                    time, the problem could occur at any time during the call, as we rely on the local filesystem.
                    <br/><br/>
                    For various reasons, this function may throw an exception, maybe because the file is not available or
                    whatever else, which therefore prevent the function from always returning the same value given the
                    same input. This is another solid way to break Referential Transparency.
                </aside>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
def readIntegerFromFile(filePath: String): Int = { 
  // throws exceptions
  val content = readFromFile(filePath)
  // ...
}</code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    More generally, a side-effect is an observable interaction that a function has with its callers or
                    the outside world besides returning a value.
                    <br/><br/>
                    In other words, whenever a function requires or outputs more than what is suggested by its signature,
                    chances are that a side-effect is created, which breaks Referential Transparency along with the
                    substitution model. So Referential Transparency is not about programming without mutable state, it's
                    about whether or not a function call needs something which is not part of its argument list, or
                    outputs something that is not part of its returned value.
                </aside>
                <div style="text-align: justify">
                <i>"A function having a side-effect is a function which has an observable interaction with its calling
                    functions or the outside world besides returning a value"</i><br/>
                    <div style="text-align: right">Wikipedia.</div>
                </div>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    Scala for example, contains some functions which implementation have been optimized using mutable
                    variables. Despite that, these functions are still considered referentially transparent as they do
                    exactly what their signatures suggest. Strict Functional Programming does not allow mutable
                    variables, but from a pragmatic point of view, this sounds alright.
                </aside>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.5em; line-height: 1.2em">
// List.scala
override def drop(n: Int): List[A] = {
  var these = this
  var count = n
  while (!these.isEmpty && count > 0) {
    these = these.tail
    count -= 1
  }
  these
}</code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    Overall Side-effects introduce complexity as there is no way for you to know what a function
                    requires or does without looking inside it. When it comes to testing, it's even worse. Unlike a
                    circuit board, you can’t just plug into a function's inputs and check its outputs. You actually have
                    to break open the code, figure out its hidden causes and effects, and simulate the world it’s
                    supposed to exist in.
                    <br/><br/>
                    So Side-effects prevent functions from being total, deterministic and pure, and therefore referentially
                    transparent.
                    <br/><br/>
                    Now, the question is, how can we make sure that our functions are Referentially Transparent while
                    keeping our program useful? I mean, no matter how you design a program, side effects will be
                    required at some point, either to get some data from the user or to output some result. So how can
                    we reconcile side-effects with Referential Transparency?
                </aside>
                <img style="vertical-align: text-bottom;margin-top:40px; border: 0; background-color: #243044"
                     src="images/intro_to_fp/side-effects.png" width="330"/>
            </section>
        </section>
<!-- 12 mn ######################################################################################################### -->
        <section>
            <h2>Total Functions</h2>
            <span style="font-size: 30px">Total: A function must yield a value for <i>every</i> possible input.</span>
            <section data-transition="none none">
                <aside class="notes">
                    So first of all, let's see how we can make sure that our functions are total. As we've seen it
                    earlier, a total function must yield a value for every possible input. The problem here is that
                    these functions may never return if they are passed arguments leading them to throw an exception
                    or to return a null.<br/><br/>

                    So the whole challenge here is to model these situations so we can make them explicit.
                </aside>
                <div style="margin-top: 60px">&nbsp;</div>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
def parse(integer: String): Int = {
  if(numberIsNotAString(number)) {
    throw new IllegalArgumentException(/*...*/)
  } else { /* parsing logic */}
}</code></pre>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
def ask(question: String): String = {
  if(question == "What's the meaning of life?") {
    "42"
  else
    null // does not compile in Scala
}</code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    So let's create some types. Either represents a value that may have one type or the other. In
                    our first example, we can now tell the caller that the parse function may return an error in some
                    cases or an integer. So no matter what happens, the parse function will always return something
                    which makes it total, as for every possible input, it will return an output.<br/><br/>

                    In the same way, the ask function returns now a Maybe, which indicates that a question may not have
                    an appropriate answer.<br/><br/>

                    So the solution consists in bringing the complexity to the surface, and inform the caller about all
                    the situations that may happen by refining the result's type.

                    This is great, but how are we supposed now to get the value obtained with an Either or a Maybe.
                    Well we can use Pattern Matching.
                </aside>
                <div style="margin-top: 60px">&nbsp;</div>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
trait Either[A, B]
case class Left[A, B](a: A)  extends Either[A, B]
case class Right[A, B](b: B) extends Either[A, B]

def parse(integer: String): Either[Exception, Int]</code></pre>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
trait Maybe[A]
case class Some[A](a: A) extends Maybe[A]
case class None[A]()     extends Maybe[A]

def ask(question: String): Maybe[String]
                </code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    Briefly, Pattern Matching is way to decompose a data-structure using patterns, and to bind values to
                    successful matches. Here's an example.<br/><br/>

                    So we have a case class Foo composed of two fields, a String and an Integer. On the next line, we
                    instantiate the class and attempt to match the instance to a series of pattern. The first matching
                    attempt succeed, and therefore, x = 42 is printed.<br/><br/>

                    In the next example, the second field has been initialized to 74. As the first pattern does not
                    match, we go to the next matching attempt, which succeed. If none of these patterns match, the last
                    pattern is used as default case.
                </aside>
                <div style="margin-top: 60px">&nbsp;</div>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
case class Foo(first: String, second: Int)
                </code></pre>
                <pre class="fragment"><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
Foo("bar", 42) match {
  case Foo(x, 42)    => println(s"$x == 42")
  case Foo("bar", _) => println(s"bar != 42")
  case _             => println("Default case")
}
                </code></pre>
                <pre class="fragment"><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
Foo("bar", 74) match {
  case Foo(x, 42)    => println(s"$x == 42")
  case Foo("bar", _) => println(s"bar != 42")
  case _             => println("Default case")
}
                </code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    Back to our example, using Pattern Matching we could now do something like this. Any question
                    regarding what we've just seen? Alright, what about Purity now?
                </aside>
                <div style="margin-top: 60px">&nbsp;</div>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
def ask(question: String): Maybe[String] = {
  if(question == "What's the meaning of life?") {
    Some("42")
  else
    None
}

ask("What's the meaning of life?") match {
  case Some(answer)  =>
    println(s"The answer is: $answer")
  case None          =>
    println("I cannot answer this question.")
}
                </code></pre>
            </section>
        </section>
        <section>
            <h2>Pure Functions</h2>
            <span style="font-size: 30px">Pure: A function’s only effect must be the computation of its return value</span>
            <section data-transition="none none">
                <aside class="notes">
                    So we want to ensure that our functions always return an expression that capture all the effects
                    it generates. In this case, we are updating a variable outside the scope of the add1 function, which makes
                    it a global variable from the function's point of view. So the add1 function has two outputs,
                    the integer provided incremented by 1 along with a state update.<br/><br/>

                    Just like in the previous example, the solution consists in making this explicit in the signature.
                </aside>
                <div style="margin-top: 60px">&nbsp;</div>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
var n = 41
def add1(x: Int): Int = { 
  n = n + 1
  x + 1
}
// ...
val m = add1(41)
assert(n == 42)</code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    The interaction between the input and the output is now clear for the caller. So, instead of
                    modifying the variable n, we just create a function that increment and return both integers passed
                    in arguments, making the variable n useless. The add1 function is now pure as its result captures
                    all the effects it generates.
                </aside>
                <div style="margin-top: 60px">&nbsp;</div>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
def add1(x: Int, y: Int): (Int, Int) = { 
  (x + 1, n + 1)
}
// ...
val n = 41
val (m, n2) = add1(41, n)
assert(n2 == 42)</code></pre>
            </section>
        </section>
<!-- 14:00 ######################################################################################################### -->
        <section>
            <h2>Deterministic Functions</h2>
            <span style="font-size: 30px">Deterministic: A function must yield the <i>same</i> output for the <i>same</i> input.</span>
            <section data-transition="none none">
                <aside class="notes">
                    Finally, in order to be Referentially Transparent, a function has to be deterministic. Given the same
                    value, it should always return the same output. This works very well with simple functions like the
                    one in the previous example, but what about functions involving IO, like database queries or
                    file-system interactions.<br/><br/>

                    The problem is that this function cannot be deterministic as it interacts with a potentially
                    unstable environment. So it could crash for many different reasons, or even run forever. Fact is,
                    you cannot control everything, so instead of trying, let's think about another approach.<br/><br/>

                    Once again, let's think about how this problem could be modeled.
                </aside>
                <div style="margin-top: 60px">&nbsp;</div>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
val s: String = readInput()
printOnConsole(s)
                </code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    Just like earlier, we've created some types representing our domain. The class ReadLine represents
                    an interaction with the console, which at some point in the future will return a String we can
                    process. This is what the process function is for.<br/><br/>

                    Secondly, we've created a type that represents another interaction, which once processed, write
                    a line in the console. Now back to our problem, we can now write something like this.<br/><br/>

                    Alright, but you may say, this looks pretty nice, but so far nothing is performed. Well, wasn't
                    that the point of doing all of this? Earlier the problem was about figuring out how this code
                    could be represented without performing any side effect. This is a solution to this problem. This
                    allows to represent the computation we want to run without involving any side effect.
                </aside>
                <div style="margin-top: 60px">&nbsp;</div>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.2em">
trait ConsoleIO
case class Read(process: String => ConsoleIO) extends ConsoleIO
case class Write(line: String, then: ConsoleIO) extends ConsoleIO
case object End extends ConsoleIO
                </code></pre>
                <pre class="fragment"><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.2em">
val program: ConsoleIO = Read { line => Write(line, End) }
                </code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    Now if we want to run this computation, we need an interpreter. This interpreter is responsible
                    for executing the program we've created and for performing any side effect needed.

                    What did we just do here ? Well it's very simple. We kept the specification of the problem
                    free from side-effects, and therefore Referentially transparent. This allows us to compose it
                    in a pure way without dealing with any issue related to its execution. So, how can Referential
                    Transparency be reconciled with IO?
                </aside>
                <div style="margin-top: 60px">&nbsp;</div>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.2em">
def interpret(program: ConsoleIO): Unit = program match {
  case Read(process) => interpret(process(readLine()))
  case Write(line, next) => println(line); interpret(next)
  case End => println("Done !")
}
                </code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    Well just like with many software engineering problems, it's all about separating the concerns
                    properly. First, we declare the computations required to solve a problem and only then, we decide
                    to execute those using an interpreter. So the idea is to make a clear distinction between the
                    evaluation of a program and its execution, or said differently, to distinguish the 'what' from the
                    'how'.<br/><br/>

                    When you think about it, this is a very common software best practice. Anyone remembers of the
                    Command pattern? Well, this is exactly the same idea. This pattern makes it easy to construct
                    commands sequences which execution is delegated to an interpreter that can be implemented in
                    different ways.<br/><br/>

                    This idea is also the one suggested by the Onion Architecture, where the core of the onion is
                    responsible for setting up the business logic which is then performed by the outer layers. This
                    allows multiple interpretations of the same logic while keeping a high level of composition and
                    flexibility. In this case, we could for example write another interpreter that would interact
                    with a file instead of the console.
                </aside>
                <div style="margin-top: 60px">&nbsp;</div>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.2em">
trait ConsoleIO
case class Read(process: String => ConsoleIO) extends ConsoleIO
case class Write(line: String, then: ConsoleIO) extends ConsoleIO
case object End extends ConsoleIO

val program: ConsoleIO = Read { line => Write(line) }
interpret(program)
                </code></pre>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.2em">
def interpret(program: ConsoleIO): Unit = program match {
  case Read(process) => interpret(process(readLine()))
  case Write(line, next) => println(line); interpret(next)
  case End => println("Done !")
}
                </code></pre>
            </section>
        </section>

        <section data-transition="none none">
            <aside class="notes">
                So in order to be Referentially Transparent, a function has to be Total, Pure
                and Deterministic. We've also learnt that side-effects prevent a function to be referentially
                transparent if they are not managed properly.<br/><br/>

                For this reason, they have to be encapsulated and
                be explicit to the caller. This can be achieved by refining a function's signature and by separating
                the 'what' from the 'how'.<br/><br/>
            </aside>
            <ul style="list-style-type: none;">
                <li><ul>
                    <li><span style="font-size: 30px;color: #42BAE8;">Total</span>: A function must yield a value for <i>every</i> possible input.</li>
                    <li><span style="font-size: 30px;color: #42BAE8;">Pure</span>: A function only effect must be the computation of its return value</li>
                    <li><span style="font-size: 30px;color: #42BAE8;">Deterministic</span>: A function must yield the <i>same</i> value for the <i>same</i> input.</li>
                </ul></li>
                <li style="list-style-type: none;">&nbsp;</li>
                <li><ul>
                    <li>Side effects break Referential Transparency :(</li>
                    <li>Side-Effects must be explicit</li>
                    <li>Separate the 'what' from the 'how'</li>
                </ul></li>
            </ul>
        </section>

        <section data-transition="none none">
            <h2>Composition</h2>
            <section data-transition="none none">
                <aside class="notes">
                    So far, we've seen how functions can become referentially transparent, but did not really
                    addressed the problem of composition. Composition is the cornerstone of any successful design,
                    and it's usually the lack of it that leads a software to a catastrophe. Let's go back to a previous
                    example<br/><br/>

                    As we've seen it, the Either type represents a value that may have one type or the other. We've
                    also seen that Pattern Matching allows us to extract the value obtained through this kind of type.<br/><br/>

                    So let's think about how expressions can be composed without losing all the benefits of Referential
                    Transparency.Let's say we'd like to represent a computation that updates the result obtained through
                    a successful Either<br/><br/>

                    We basically need a function allowing the update of those
                    containers values without having to extract them. This sounds a lot like polymorphism.
                </aside>
                <pre class="fragment"><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.2em">
trait Either[A, B]
case class Left[A, B](a: A)  extends Either[A, B]
case class Right[A, B](b: B) extends Either[A, B]
                </code></pre>
                <pre class="fragment"><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.2em">
val foo: Either[Exception, Int] = ???
val result = foo match {
  case Right(y) => y + 1
  case Left(ex) => ??? // what are we supposed to return here???
}
println(result)
                </code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    Thanks to Pattern matching, this is pretty easy. The map function checks if the either passed
                    in parameter is a success, and apply the mapping function if it's the case. Otherwise, it just
                    returns the same value.

                    This looks pretty good, but let's go a little bit further.
                </aside>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.2em">
val success: Either[Exception, Int] = Right(42)

val failure: Either[Exception, Int] =
  Left(new RuntimeException())

map( _ + 1 )(success) // returns 43
map( _ + 1 )(failure) // return failure

def map[A, B](f: A => B)
             (e: Either[Exception, A]): Either[Exception, B] =
  e match {
    case Right(v) => Right(f(v))
    case Left(e) => Left(e)
  }
                </code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    So let's say, I'd like to chain two computations among which one results from the other. In order
                    to do this, I could reuse the map function, but the problem is the resulting expression which is
                    an Either of Either. Just think about what would be returned if you chain a dozen of Eithers.

                    No. What I am really interested in is the final expression returned by the whole chain, and not
                    the intermediary results.<br/><br/>

                    So the chain function takes the function we'd like to chain the either with, along with the either itself.

                    Questions?
                </aside>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.2em">
val foo: Either[Exception, Int] = ???
val bar: Int => Either[Exception, String] = ???

// meh !
val fooBar: Either[Exception, Either[Exception, String]] =
  map(bar)(foo)

val fooBar: Either[Exception, String] = chain(foo, bar)
                </code></pre>
                <pre class="fragment"><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.2em">
def chain[E, B, C](f: B => Either[E, C])
                  (e: Either[E, B]): Either[E, C] = e match {
  case Right(b) => f(b)
  case Left(e) => Left(e)
}
                </code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    What's really interesting here, is that the same logic could be applied to a Maybe. So we clearly
                    have a pattern here that could be abstracted. Let's get some steps back.
                </aside>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.2em">
def map[A, B](f: A => B)(m: Maybe[A]): Maybe[B] =
  m match {
    case Some(a) => Some(f(a))
    case None() => None()
  }

def chain[A, B](f: A => Maybe[B])(m: Maybe[A]): Maybe[B] =
  m match {
    case Some(a) => f(a)
    case None() => None()
  }
                </code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    When you were in first grade, you learnt about the domain of numbers. Later, you also learnt that
                    you can combine those numbers using specific operators, and that the domain of numbers is ruled by
                    laws. Numbers, operators and laws, all together form an algebra. Numbers are actually what we call
                    algebraic data types.<br/><br/>

                    Back to our types, we probably can figure out some kind of algebra where the algebraic data
                    types are the types themselves.
                </aside>
                <pre><code data-trim data-noescape style="font-size: 1.2em; line-height: 1.0em">
// Algebraic data types
1, 2, 3...

// Operations
1 + 2 = 3
3 * 2 = 6

// Laws
0 + x = x
1 * x = x
                </code></pre>
            </section>

            <section data-transition="none none">
                <aside class="notes">
                    Let's first look at these mapping functions, and their characteristics. First, Just like when you
                    sum 1 and 0, mapping a value with a no-op function returns the same original value, no matter
                    its type.<br/><br/>

                    Secondly, the map function is associative. So mapping a value over two functions sequentially is
                    the same than mapping the value with a composition of those two functions.<br/><br/>

                    These are the characteristics of a Functor.
                </aside>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.2em">
def map[A, B](f: A => B)(m: Maybe[A]): Maybe[B] = m match {
  case Some(a) => Some(f(a))
  case None() => None()
}
                </code></pre>
                <pre class="fragment"><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.2em">
def noop[A](a: A): A = a
map(noop)(foo) == foo
                </code></pre>
                <pre class="fragment"><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.2em">
val f: Int => Int = ???
val g: Int => String = ???

map(compose(f, g))(foo) == compose(map(f),map(g))(foo)
                </code></pre>
            </section>

            <section data-transition="none none">
                <aside class="notes">
                    A Functor, is a type we can map on, and obeys to two laws, the identity law and the composition
                    law we've just defined.<br/><br/>

                    The F in the Functor trait is refered to as an effect or computational context, which, in our examples
                    are Maybe or Either. Each of those can abstract different behaviors as long as they hold with the
                    Functor's laws.<br/><br/>

                    Concretely, a Functor is the ability to compose with a single effect without needing to “leave” the
                    effect.
                </aside>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.0em">
trait Functor[F[_]] {
  def pure[A](a: A): F[A]
  def map[A, B](fa: F[A], f: A => B): F[A]
}               </code></pre>
                <pre><code class="haskell" data-trim data-noescape style="font-size: 1.1em; line-height: 1.0em">
# identity law
map(noop)(foo) == foo

# composition law
map(compose(f, g))(foo) == compose(map(f),map(g))(foo)
                </code></pre>
            </section>

            <section data-transition="none none">
                <aside class="notes">
                    So we've seen how Functors can be mapped with unary functions. What about mapping a Functor
                    with a function of bigger arity? Well, let's see how this would look like.<br/><br/>

                    So here we have a function foo, that takes two integers, and which returns a String. Notice that
                    we are using a curried version here. Let's try to map a Maybe using this function:<br/><br/>

                    This would result in a Maybe of function taking an Integer and returning a String. So it's a Maybe
                    of a partially applied foo. But then, how can we pass the value of the second Maybe to this function?
                    Map is clearly not enough here, we actually need something more powerful:<br/><br/>

                    The function ap is designed for this purpose. It basically applies a function wrapped in a Maybe
                    to the wrapped value of another Maybe, using Pattern Matching. This is pretty
                    cool as this function allows us to combine the results of two independent computations. Once again
                    this is a well known pattern called Applicatives.
                </aside>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.0em">
val foo: Int => Int => String = x => y => s"$x, $y"

val m1: Maybe[Int] = Some(1)
val m2: Maybe[Int] = Some(2)
                </code></pre>
                <pre class="fragment"><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.0em">
val pFoo: Maybe[Int => String] =
  map(foo)(m1) // Some(y => "1, $y")
                </code></pre>

                <pre class="fragment"><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.0em">
def ap[A, B](mf: Maybe[A => B])(ma: Maybe[A]): Maybe[B] =
  ma match {
   case Some(a) => map(f => f(a))(mf)
   case None()  => None()
  }
                </code></pre>
                <pre class="fragment"><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.0em">
val result: Maybe[String] = ap(pFoo)(m2)
                </code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    In order to be an Applicative, a type has to hold the Functor contract. Secondly, it has to follow
                    a couple of laws, among which, one is really important<br/><br/>

                    Basically, applying a function to a Functor goes back to map this Functor with the same function.<br/><br/>

                    Applicatives are very useful when it comes to combine the results of several independent computations
                    like Futures for instance. Now what about combining the result of interdependent computations
                </aside>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.0em">
trait Applicative[F[_]] extends Functor[F] {
  def ap[A, B](ff: F[A => B])(fa: F[A]): F[B]
}
                </code></pre>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.0em">
ap(ff)(fx) == map(f)(fx)
                </code></pre>
            </section>

            <section data-transition="none none">
                <aside class="notes">
                    Earlier, without naming them, we saw  how Functors can be chained together sequentially through
                    the chain function. Just like the map function, chain can also be abstracted and obeys a couple
                    of laws.<br/><br/>

                    So here, I've added a function called pure, which just put its argument in the context of a Maybe.<br/><br/>

                    Now the first law of the chain function, is that chaining a Functor with the pure function goes back
                    to return the original Functor.<br/><br/>

                    Secondly, chaining a Functor with a function, is just like applying the function to the content of
                    of the Functor.<br/><br/>

                    Finally, chain is associative. So it doesn't master how nested chains are composed, just like
                    the map function. As you can guess, these laws are the characteristics of another well-know
                    pattern, Monads.
                </aside>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.0em">
def chain[A, B](f: A => Maybe[B])(m: Maybe[A]): Maybe[B] =
  m match {
    case Some(a) => f(a)
    case None() => None()
  }
                </code></pre>
                <pre class="fragment"><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.0em">
val f: Int => Maybe[Int] = ???
val pure: Int => Maybe[Int] = (i: Int) => Some(i)
                </code></pre>
                <pre class="fragment"><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.0em">
chain(pure)(Some(42)) == Some(42)
                </code></pre>
                <pre class="fragment"><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.0em">
chain(f)(Some(42)) == f(42)
                </code></pre>
                <pre class="fragment"><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.0em">
val g: Int => Maybe[Int] = ???

chain(chain(Some(42), f), g)
  == chain(Some(42), i => chain(f(i), g))
                </code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    Wow, I've just used the M word. Monads represent types that can be sequentially chained with each
                    other using the flatMap function which is our chain function, and are a great tool to represent
                    dependent computations. So whenever the result of a computation depends on the result of another one
                    of the same kind, you should think about Monads.
                </aside>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.0em">
trait Monad[M[_]] {
  def flatMap[A, B](ma: M[A], f: A => M[B]): M[A]
}               </code></pre>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.0em">
// Left identity law
chain(pure)(Some(42)) == Some(42)

// Right identity law
chain(f)(Some(42)) == f(42)

// Composition law
chain(chain(Some(42), f), g)
  == chain(Some(42), i => chain(f(i), g))
                </code></pre>
            </section>

            <section data-transition="none none">
                <aside class="notes">
                    Ok, so if this is the first time you hear about these patterns and laws, I guess you're a bit
                    confused. This takes a while before being comfortable with these concepts and that's alright.
                    However, I'd like you to keep a couple of stuff in mind, so here's a quick recap about what
                    those notions stand for.<br/><br/>

                    Functors are effects that can be mapped over. Applicatives represent independent computations that
                    can be combined together. Finally, Monads represent dependents computations that can be chained
                    sequentially. So you can use the result of one to define the other. Finally, <br/><br/>

                    These are some examples of the Functional Programming patterns, but there are many others.
                </aside>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.0em">
trait Functor[F[_]] {
  def pure[A](a: A): F[A]
  def map[A, B](fa: F[A], f: A => B): F[A]
}

trait Monad[M[_]] {
  def flatMap[A, B](ma: M[A], f: A => M[B]): M[A]
}

trait Applicative[F[_]] extends Functor[F] {
  def lift[A, B](ff: F[A => B])(fa: F[A]): F[B]
}
                </code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    Now why do we need all these laws? Well, just like with numbers, a flexible domain is
                    first of all about having small reusable blocks that can composed into larger blocks
                    following a set of rules.<br/><br/>

                    A set of building blocks with composition laws is a domain language. Domain languages are the
                    key to keep a codebase easy to extend and to adapt to problems that are not here yet.<br/><br/>

                    Just look at common languages that we use everyday like French and English. Without a proper
                    grammar those languages would be dead by today. This is why we need laws.
                </aside>
                <img style="vertical-align: text-bottom;margin-top:40px; border: 0; background-color: #243044"
                     src="images/intro_to_fp/g.png" width="550"/>
                <img class="fragment" style="vertical-align: text-bottom;margin-top:40px; border: 0; background-color: #243044"
                     src="images/intro_to_fp/39070116.jpg" width="387"/>
            </section>
        </section>
        <!--16:30-->
        <section data-transition="none none">
            <h2>Conclusion</h2>
            <aside class="notes">
                So, we are reaching the end of this talk, and I hope you've enjoyed it. Overall, Functional Programming
                can help you in lot of things like getting a stunning beard, an awesome moustache along with
                a couple of creepy t-shirts. More seriously.<br/><br/>

                I would really recommend every developer to learn about Functional Programming. Not because some consider
                it's better than any other paradigm, but because it's a matter of design. The more ways you can tackle a
                problem, the more relevant your solution for this problem will be.<br/><br/>

                Now when it comes to Functional Programming, you can quickly feel overwhelmed by the amount of
                resources on the Internet. So here's a couple of them I've considered really useful...
            </aside>
            <ul>
                <li><span style="font-size: 30px;color: #42BAE8;">Learn You a Haskell for Great Good! : </span><span style="font-size: 25px">by Miran Lipovaca</span></li>
                <li><span style="font-size: 30px;color: #42BAE8;">Functional Programming in Scala : </span><span style="font-size: 25px">by Paul Chiusano and Rúnar Bjarnason</span></li>
                <li><span style="font-size: 30px;color: #42BAE8;">http://degoes.net/: </span><span style="font-size: 25px">by John A De Goes</span></li>
                <li><span style="font-size: 30px;color: #42BAE8;">https://wiki.haskell.org/Typeclassopedia: </span><span style="font-size: 25px">by Brent Yorgey</span></li>
                <li><span style="font-size: 30px;color: #42BAE8;">Functional and Reactive Domain Modeling: </span><span style="font-size: 25px">by Debasish Ghosh</span></li>
                <li><span style="font-size: 30px;color: #42BAE8;">Real World Haskell: </span><span style="font-size: 25px">by Bryan O'Sullivan, Don Stewart, and John Goerzen</span></li>
                <li style="list-style-type: none;">&nbsp;</li>
                <li class="fragment"><span style="font-size: 30px;color: #42BAE8;">Lambda Montreal </span><span style="font-size: 25px">by reaaaallllly nice folks :)</span></li>
            </ul>
        </section>
        <section data-transition="none none">
            <aside class="notes">
                I haven't introduced my self, my name is Francis Toth, I'm a happy Scala developer working at Yoppworks,
                and one of the co-organizer of this meetup. As my fellow co-workers along with the best boss I've ever had,
                and I'm not saying this because you're my boss, stated it, we are a company providing consulting and
                training services in partnership with Hortonworks and Lightbend. If you are interested, just come see
                us and we'll be glad to talk about a potential collaboration with you. Thank you again, and now it's time
                for questions.
            </aside>
            <img style="background-color: transparent"
                 src="images/yoppworks.logo-corner-dark.png"/>
            Thank you ! Questions ?
        </section>
    </div>
</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>

<script>

    // Full list of configuration options available at:
    // https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
            { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
            { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
            { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
            { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
            { src: 'plugin/zoom-js/zoom.js', async: true },
            { src: 'plugin/notes/notes.js', async: true }
        ]
    });

</script>
</body>
</html>

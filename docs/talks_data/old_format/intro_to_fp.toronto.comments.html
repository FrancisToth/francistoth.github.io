<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">

    <title>Introduction to Functional Programming - by Francis Toth</title>

    <meta name="description" content="A framework for easily creating beautiful presentations using HTML">
    <meta name="author" content="Hakim El Hattab">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/custom.css">
    <link rel="stylesheet" href="css/theme/francis.css" id="theme">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
</head>

<body>


<aside style="display: block; position: fixed; bottom: 10px; right: 10px; z-index: 30;">
    <a href="http://www.yoppworks.com"><img src="images/yoppworks.logo-corner-dark.png"  height="30"></a>
</aside>
<aside style="display: block; position: fixed; bottom: 0px; left: 10px; z-index: 30;">
    <a href="https://www.meetup.com/lambda-montreal/"><img src="images/logo.lambda_montreal.jpeg"  height="100"></a>
</aside>

<div class="reveal">
    <div class="slides">
        <section>
            <aside class="notes">
                Hello everyone,<br/>

                First of all, thank you all for being here tonight. To be honest I wasn't expecting so many people, so I'm glad to
                see so much interest in Functional Programming. I've read somewhere that when you start understanding Functional
                Programming, you become unable to explain it. Well, this is my second attempt, and I really hope you'll
                be satisfied with it.
                <br/><br/>
                Before starting, how many of you guys are not familiar with Scala at all? Well, the examples in this talk are all in Scala
                but if you are not familiar with the language, that should be ok. In any case, if during this talk, there is
                something you don't understand, please interrupt me, I'll be glad to help you.
                <br/><br/>
                Secondly, I'm far from being a Functional Programming expert and I may not be accurate sometime. If this
                happens, and if you think you can contribute to this talk, please do. You will be very welcome.
                <br/><br/>
                By the way, how many of you guys consider themselves as Functional Programming experts? Same question but for those
                who feel like intermediate? Alright, any beginners? So, I don't know about you guys, but the first time I've learnt
                about Functional Programming, It sounded like jibberish to me. Functional Programming can be indeed very
                obscure some time as it has deep abstract mathematical roots. Fortunately, we won't cover those today
                and will instead tackle Functional Programming from a very practical angle.
                <br/><br/>
                Alright, let's get this started.
            </aside>

            <h2 style="display: inline-block;"><img style="vertical-align: text-bottom; margin: -2px 0; border: 0; background-color: #243044" src="images/intro_to_fp/haskell-logo.png" width="11%"/> Functional Programming</h2>
        </section>
        <section>
            <h2>Expressions Oriented</h2>
            <section data-transition="none none">
                <aside class="notes">
                    Ok so first of all, Functional Programming is based on expressions. An expression, is a finite combination
                    of symbols well-formed according a set of rules which produces a value. Those symbols can be
                    constants, operators, or functions.
                    <br/><br/>
                    In Functional code, an expression has to be referentially transparent. In other words, replacing it
                    by the value it produces should not affect a program's output in any way. This is referred to the
                    substitution model which is something you are actually all familiar with since first grade.
                    <br/><br/>
                    In Functional Programming, expressions are indeed evaluated just like mathematical
                    expressions. So the evaluation process of an expression, goes on and on until it cannot be reduced
                    no more and produces a value.
                </aside>
                <pre><code data-trim data-noescape style="font-size: 1.5em; line-height: 1.2em">42
x = 41 + 1
y = x * 2
z = add(x, 2)</code></pre>
                <pre class="fragment"><code data-trim data-noescape style="font-size: 1.5em; line-height: 1.2em">x = 42
y = x + 1 == 42 + 1</code></pre>
                <pre class="fragment"><code data-trim data-noescape style="font-size: 1.5em; line-height: 1.2em">x = (2 * 2) + (3 * 4)
x = 2 * 2 + 3 * 4
x = 4 + 12
x = 16</code></pre>
            </section>

            <section data-transition="none none">
                <aside class="notes">
                    What about functions now? We just said that functions are also expressions right? Therefore they
                    also have to be referentially transparent. So how does a Function can hold this contract?
                    <br/><br/>
                    Well in order to be Referentially Transparent, a Function must have three properties. It has to be
                    <br/><br/>
                    <b>Total</b>: that is every input has to be mapped with an output<br/>
                    <b>Pure</b>: A function's only effect is the computation of its returning value<br/>
                    <b>Deterministic</b>: Given the same input, a function has to always return the same output<br/>
                    <br/><br/>
                    In the next slides, we'll see what prevents a function to hold these rules, along with the solutions
                    to enforce them.
                </aside>
                <ul>
                    <li class="fragment"><span style="color:#42BAE8"><b>Total</b></span>: A function must yield a value for <i>every</i> possible input.</li>
                    <li class="fragment"><span style="color:#42BAE8"><b>Pure</b></span>: A function’s only effect must be the computation of its return value</li>
                    <li class="fragment"><span style="color:#42BAE8"><b>Deterministic</b></span>: A function must yield the <i>same</i> value for the <i>same</i> input.
                        <br/><br/><br/>
                        <div style="text-align: right"><span style="font-size: 20px">
                            Taken from <i>"A Beginner-Friendly Tour through Functional Programming in Scala"</i>.<br/><b>John A De Goes</b>.
                        </span></div>
                    </li>
                </ul>
            </section>
        </section>
        <section data-transition="none none">
            <h2>Inputs / Outputs</h2>
            <section data-transition="none none">
                <aside class="notes">
                    Let's hold on a minute and think about what are the inputs and the outputs of a function.
                    <br/><br/>
                    The function 'foo' takes a String and returns an Integer. Simple enough. Now what about the 'bar'
                    function? Just like 'foo', it takes a String, returns an Integer but also outputs another String in
                    the console. So 'bar' has two outputs: the resulting integer and the String written in the console.
                    In Functional code, this is what we call a side-effect. Let's see some others examples:
                </aside>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.5em; line-height: 1.2em">
def foo(number: String): Int = number.toInt

def bar(input: String): Int = { 
  println("performing bar")
  foo(input)
}</code></pre>
            </section>
        </section>
        <section data-transition="none none">
            <h2>Side Effects</h2>
            <section data-transition="none none">
                <aside class="notes">
                    In those examples, beside returning a value, those two functions may respectfully throw an exception
                    or return a null value.
                    <br/><br/>
                    The problem with exceptions is that there is absolutely no guarantee about where they will occur.
                    So they can occur everywhere. Just like with nulls, exceptions lead you to set up aggressive
                    exception handling, even in cases where it doesn't make any sense.
                    <br/><br/>
                    Those who worked on wide legacy codebases know what I am talking about. You know that situation
                    when you ask a guy why he is using a try-catch for no reason, and the guy answers, "Well, you know,
                    just in case of". Exceptions and Nulls prevent a function from being total, as given an input, they
                    may return nothing.
                </aside>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
def parse(integer: String): Int = {
  if(numberIsNotAString(number)) {
    throw new IllegalArgumentException(/*...*/)
  } else {
    // parsing logic returning parsed integer
  }
}</code></pre>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
def ask(question: String): String = {
  if(question == "What's the meaning of life?") {
    "42"
  else
    null // does not compile in Scala
}</code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    Another example, so here, the add1 function is responsible for incrementing by 2 the integer passed in argument.
                    But once called, it also gets the value of n, and increments it. Referential transparency is clearly
                    broken here as replacing the add2 function call by its resulting expression changes the output of
                    the program. So this function's effect cannot be obtain just by computing its resulting value
                    which means it's not pure.
                </aside>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
var n = 0
def add2(x: Int): Int = { 
  n = n + 1
  x + 2
}
// ...
val y = add2(40)
assert(n == 1)</code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    Last example, in this case, we still have a situation where exceptions could happen, but this
                    time, the problem could occur at any time during the call, as we rely on the local filesystem.
                    <br/><br/>
                    For various reasons, this function may throw an exception, maybe because the file is not available or
                    whatever else, which therefore prevents the function from always returning the same value given the
                    same input. Non-determinism is another solid way to break Referential Transparency.
                </aside>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
def readIntegerFromFile(filePath: String): Int = { 
  // throws exceptions
  val content = readFromFile(filePath)
  // ...
}</code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    More generally, a side-effect is an observable interaction that a function has with its callers or
                    the outside world besides returning a value.
                    <br/><br/>
                    In other words, whenever a function requires or outputs more than what is suggested by its signature,
                    chances are that a side-effect is created, which breaks Referential Transparency along with the
                    substitution model. So Referential Transparency is not about programming without mutable state, it's
                    about whether or not a function call needs something which is not part of its argument list, or
                    outputs something that is not part of its returned value.
                </aside>
                <div style="text-align: justify">
                <i>"A function having a side-effect is a function which has an observable interaction with its calling
                    functions or the outside world besides returning a value"</i><br/>
                    <div style="text-align: right">Wikipedia.</div>
                </div>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    Scala for example, contains some functions which implementation have been optimized using mutable
                    variables. Despite that, these functions are still considered referentially transparent as they do
                    exactly what their signatures suggest. Pure Functional Programming does not allow mutable
                    variables, but from a pragmatic point of view, this sounds alright.
                </aside>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
// List.scala
override def drop(n: Int): List[A] = {
  var these = this
  var count = n
  while (!these.isEmpty && count > 0) {
    these = these.tail
    count -= 1
  }
  these
}</code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    Overall Side-effects introduce complexity as there is no way for you to know what a function
                    requires or does without looking inside it. When it comes to testing, it's even worse. Unlike a
                    circuit board, you can’t just plug into a function's inputs and check its outputs. You actually have
                    to break open the code, figure out its hidden causes and effects, and simulate the world it’s
                    supposed to exist in.
                    <br/><br/>
                    So Side-effects prevent functions from being total, deterministic and pure, and therefore referentially
                    transparent.
                    <br/><br/>
                    Now, the question is, how can we make sure that our functions are Referentially Transparent while
                    keeping our program useful? I mean, no matter how you design a program, side effects will be
                    required at some point, either to get some data from the user or to output some result. So how can
                    we reconcile side-effects with Referential Transparency?
                </aside>
                <img style="vertical-align: text-bottom;margin-top:40px; border: 0; background-color: #243044"
                     src="images/intro_to_fp/side-effects.png" width="330"/>
            </section>
        </section>
        <section>
            <h2>Total Functions</h2>
            <span style="font-size: 30px">Total: A function must yield a value for <i>every</i> possible input.</span>
            <section data-transition="none none">
                <aside class="notes">
                    So first of all, let's see how we can make sure that our functions are total. As we've seen it
                    earlier, a total function must yield a value for every possible input. The problem here is that
                    these functions may never return if they are passed arguments leading them to throw an exception
                    or to return a null.<br/><br/>

                    So the whole challenge here is to model these situations so we can make them explicit.
                </aside>
                <div style="margin-top: 60px">&nbsp;</div>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
def parse(integer: String): Int = {
  if(numberIsNotAString(number)) {
    throw new IllegalArgumentException(/*...*/)
  } else { /* parsing logic */}
}</code></pre>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
def ask(question: String): String = {
  if(question == "What's the meaning of life?") {
    "42"
  else
    null // does not compile in Scala
}</code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    So let's create some types. Either represents a value that may have one type or the other. In
                    our first example, we can now tell the caller that the parse function may return an error in some
                    cases or an integer. So no matter what happens, the parse function will always return something
                    which makes it total, as for every possible input, it will return an output.<br/><br/>

                    In the same way, the ask function returns now a Maybe, which indicates that a question may not have
                    an appropriate answer.<br/><br/>

                    So the solution consists in bringing the complexity to the surface, and in informing the caller about all
                    the situations that may happen during the function call by refining the result's type.

                    This is great, but how are we supposed now to get the value obtained with an Either or a Maybe.
                    Well we can use Pattern Matching.
                </aside>
                <div style="margin-top: 60px">&nbsp;</div>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
trait Either[A, B]
case class Left[A, B](a: A)  extends Either[A, B]
case class Right[A, B](b: B) extends Either[A, B]

def parse(integer: String): Either[Exception, Int]</code></pre>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
trait Maybe[A]
case class Some[A](a: A) extends Maybe[A]
case class None[A]()     extends Maybe[A]

def ask(question: String): Maybe[String]
                </code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    Briefly, Pattern Matching is way to decompose a data-structure using patterns, and to bind values to
                    successful matches. Here's an example.<br/><br/>

                    So we have a case class Foo composed of two fields, a String and an Integer. On the next line, we
                    instantiate the class and attempt to match the instance to a series of pattern. The first matching
                    attempt succeed, and therefore, bar = 42 is printed.<br/><br/>

                    In the next example, the second field has been initialized to 74. As the first pattern does not
                    match, we go to the next matching attempt, which succeed. If none of these patterns match, the last
                    pattern is used as default case.
                </aside>
                <div style="margin-top: 60px">&nbsp;</div>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
case class Foo(first: String, second: Int)
                </code></pre>
                <pre class="fragment"><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
Foo("bar", 42) match {
  case Foo(x, 42)    => println(s"$x == 42")
  case Foo("bar", _) => println(s"bar != 42")
  case _             => println("Default case")
}
                </code></pre>
                <pre class="fragment"><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
Foo("bar", 74) match {
  case Foo(x, 42)    => println(s"$x == 42")
  case Foo("bar", _) => println(s"bar != 42")
  case _             => println("Default case")
}
                </code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    Back to our example, using Pattern Matching we could now do something like this. Any question
                    regarding what we've just seen? Alright, what about Purity now?
                </aside>
                <div style="margin-top: 60px">&nbsp;</div>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
def ask(question: String): Maybe[String] = {
  if(question == "What's the meaning of life?") {
    Some("42")
  else
    None
}

ask("What's the meaning of life?") match {
  case Some(answer)  =>
    println(s"The answer is: $answer")
  case None          =>
    println("I cannot answer this question.")
}
                </code></pre>
            </section>
        </section>
        <section>
            <h2>Pure Functions</h2>
            <span style="font-size: 30px">Pure: A function’s only effect must be the computation of its return value</span>
            <section data-transition="none none">
                <aside class="notes">
                    So we want to ensure that our functions always return an expression that capture all the effects
                    it generates. In this case, we are updating a variable outside the scope of the add1 function, which makes
                    it a global variable from the function's point of view. So the add1 function has two outputs,
                    the integer provided incremented by 1 along with a state update.<br/><br/>

                    Just like in the previous example, the solution consists in making this explicit in the signature.
                </aside>
                <div style="margin-top: 60px">&nbsp;</div>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
var n = 0
def add2(x: Int): Int = { 
  n = n + 1
  x + 2
}
// ...
val y = add2(40)
assert(n == 1)
                </code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    The interaction between the input and the output is now clear for the caller. So, instead of
                    modifying the variable n, we just create a function that increment and return both integers passed
                    in arguments, making the variable n useless. The add1 function is now pure as its result captures
                    all the effects it generates.
                </aside>
                <div style="margin-top: 60px">&nbsp;</div>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
def add2(x: Int, n: Int): (Int, Int) = { 
  (x + 2, n + 1)
}
// ...
val (y, n) = add2(40, 0)
assert(n == 1)
                </code></pre>
            </section>
        </section>
        <section>
            <h2>Deterministic Functions</h2>
            <span style="font-size: 30px">Deterministic: A function must yield the <i>same</i> output for the <i>same</i> input.</span>
            <section data-transition="none none">
                <aside class="notes">
                    Finally, in order to be Referentially Transparent, a function has to be deterministic. Given the same
                    value, it should always return the same output. This works very well with simple functions like the
                    one in the previous example, but what about functions involving IO, like database queries or
                    file-system interactions.<br/><br/>

                    The problem is that this function cannot be deterministic as it interacts with a potentially
                    unstable environment. So it could crash for many different reasons, or even run forever. Fact is,
                    you cannot control everything, so instead of trying, let's think about another approach.<br/><br/>

                    Once again, let's think about how this problem could be modeled.
                </aside>
                <div style="margin-top: 60px">&nbsp;</div>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
val s: String = readInput()
printOnConsole(s)
                </code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    Just like earlier, we've created some types representing our domain. The class Read represents
                    an interaction with the console, which at some point in the future will return a String we can
                    process. This is what the process function is for.<br/><br/>

                    Secondly, we've created a type that represents another interaction, which once processed, write
                    a line in the console. Now back to our problem, we can now write something like this.<br/><br/>

                    Which is really cool.

                    <!--Now just for the sake of it, how would we represent a program that reads a-->
                    <!--line and prints it back on the console over and over without stopping. Well using recursion.-->
                    <!--That's really neat. No while loop required here.<br/><br/>-->

                    Alright, but you may say, this looks pretty nice, but so far nothing is performed. Well, wasn't
                    that the point of doing all of this? Earlier the problem was about figuring out how this code
                    could be represented without performing any side effect. This is a solution to this problem. This
                    allows to represent the computation we want to run without involving any side effect.
                </aside>
                <div style="margin-top: 60px">&nbsp;</div>
                <pre style="width: 100%"><code class="scala" data-trim data-noescape style="font-size: 1.2em; line-height: 1.2em">
trait ConsoleIO
case class Read(process: String => ConsoleIO) extends ConsoleIO
case class Write(line: String, then: ConsoleIO) extends ConsoleIO
case object End extends ConsoleIO
                </code></pre>
                <pre class="fragment" style="width: 100%"><code class="scala" data-trim data-noescape style="font-size: 1.2em; line-height: 1.2em">
val program: ConsoleIO = Read { line => Write(line, End) }
                </code></pre>

                <!--<pre class="fragment"><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.2em">-->
<!--val loop: ConsoleIO = Read { line => Write(line, loop) }-->
                <!--</code></pre>-->
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    Now if we want to run this computation, we need an interpreter. This interpreter is responsible
                    for executing the program we've created and for performing any side effect needed.

                    What did we just do here ? Well it's very simple. We kept the specification of the problem
                    free from side-effects, and therefore Referentially transparent. This allows us to compose it
                    in a pure way without dealing with any issue related to its execution. So, how can Referential
                    Transparency be reconciled with IO?
                </aside>
                <div style="margin-top: 60px">&nbsp;</div>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.2em; line-height: 1.2em">
def interpret(program: ConsoleIO): Unit = program match {
  case Read(process) => interpret(process(readLine()))
  case Write(line, next) => println(line); interpret(next)
  case End => println("Done !")
}
                </code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    Well just like with many software engineering problems, it's all about separating the concerns
                    properly. First, we declare the computations required to solve a problem and only then, we decide
                    to execute those using an interpreter. So the idea is to make a clear distinction between the
                    evaluation of a program and its execution, or said differently, to distinguish the 'what' from the
                    'how'.<br/><br/>

                    When you think about it, this is a very common software best practice. Anyone remembers of the
                    Command pattern? Well, this is exactly the same idea. This pattern makes it easy to construct
                    commands sequences which execution is delegated to an interpreter that can be implemented in
                    different ways.<br/><br/>

                    This idea is also the one suggested by the Onion Architecture, where the core of the onion is
                    responsible for setting up the business logic which is then performed by the outer layers. This
                    allows multiple interpretations of the same logic while keeping a high level of composition and
                    flexibility. In this case, we could for example write another interpreter that would interact
                    with a file instead of the console.
                </aside>
                <div style="margin-top: 60px">&nbsp;</div>
                <pre style="width: 100%"><code class="scala" data-trim data-noescape style="font-size: 1.2em; line-height: 1.2em">
trait ConsoleIO
case class Read(process: String => ConsoleIO) extends ConsoleIO
case class Write(line: String, then: ConsoleIO) extends ConsoleIO
case object End extends ConsoleIO

val program: ConsoleIO = Read { line => Write(line) }
interpret(program)
                </code></pre>
                <pre style="width: 100%"><code class="scala" data-trim data-noescape style="font-size: 1.2em; line-height: 1.2em">
def interpret(program: ConsoleIO): Unit = program match {
  case Read(process) => interpret(process(readLine()))
  case Write(line, next) => println(line); interpret(next)
  case End => println("Done !")
}
                </code></pre>
            </section>
        </section>
        <section data-transition="none none">
            <aside class="notes">
                So in order to be Referentially Transparent, a function has to be Total, Pure and Deterministic. We've
                also learnt that side-effects prevent a function to be referentially transparent if they are not managed
                properly.<br/><br/>

                For this reason, they have to be encapsulated and be explicit to the caller. This can be achieved by
                refining a function's signature and by separating the 'what' from the 'how'.<br/><br/>

                So Referential Transparency is a powerful tool to organize code, to separate a concept from how it's
                actually being implemented, and to expose the effects generated at runtime by a function. But that's
                actually far from being the end. Indeed, Referential Transparency deeply affects the way we design
                programs<br/><br/>
            </aside>
            <ul style="list-style-type: none;">
                <li><ul>
                    <li><span style="font-size: 30px;color: #42BAE8;">Total</span>: A function must yield a value for <i>every</i> possible input.</li>
                    <li><span style="font-size: 30px;color: #42BAE8;">Pure</span>: A function only effect must be the computation of its return value</li>
                    <li><span style="font-size: 30px;color: #42BAE8;">Deterministic</span>: A function must yield the <i>same</i> value for the <i>same</i> input.</li>
                </ul></li>
                <li style="list-style-type: none;">&nbsp;</li>
                <li><ul>
                    <li>Side effects break Referential Transparency :(</li>
                    <li>Side-Effects must be explicit</li>
                    <li>Separate the 'what' from the 'how'</li>
                </ul></li>
            </ul>
        </section>
        <!--15:47-->
<!--#################################################################################################################-->
<!--#################################################################################################################-->
<!--#################################################################################################################-->
        <section data-transition="none none">
            <h2>Correctness</h2>
            <aside class="notes">
                Just think about how you would make sure this program is correct. In this example, nothing tells you
                that something may go wrong if you switch those expressions. You know this program is correct because
                you are mentally representing the state of the program at runtime, and you know that once
                cracked, the eggs can be safely beaten as their state allow it.<br/><br/>

                In Functional Programming on the other hand, a function can only read what it's being provided with and the
                only way it can have an effect on the world is through the value it returns. As a consequence, the data
                dependency graph becomes obvious, and beating eggs before cracking them is no longer an option.
            </aside>
            <pre style="width: 100%"><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
def cookOmelette(eggs: List[Egg]): Unit = {
  crackEggs(eggs)
  beatEggs(eggs)
  makeOmelette(eggs)
}
            </code></pre>
            <pre class="fragment" style="width: 100%"><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
def cookOmelette(eggs: List[Egg]): Omelette = {
  val crackedEggs    : List[CrackedEgg] = crackEggs(eggs)
  val beatenEggs     : List[BeatenEgg] = beatEggs(crackedEggs)
  val omelette       : Omelette = makeOmelette(beatenEggs)
}
            </code></pre>
        </section>
        <section data-transition="none none">
            <h2>Order of evaluation</h2>
            <section data-transition="none none">
                <aside class="notes">
                    Another important outcome of Referential Transparency is the way a program is evaluated. In Imperative
                    programming, the order of execution of each instruction of a program cannot be altered in any way.
                    Simply, because each of them may interact with the global state of the program, and changing their
                    order of execution may impact the resulting output. This is actually not the case in Functional
                    Programming.<br/><br/>

                    As an expression does not generate any side-effect, the order in which two expressions are evaluated
                    doesn't matter. Here we have two functions, which are respectfully responsible for multiplying the
                    argument by 3 and for incrementing it by one. As those functions are referentially transparent, no matter if
                    we first evaluate f or g, we'll always get a 6 in the end.<br/><br/>
                    <!--As the order of evaluation is irrelevant, the interpreter can now decide about how and when an expression should be executed,-->
                    <!--which creates opportunities for runtime optimizations. In the last piece of code there, an-->
                    <!--interpreter could decide to run those computations in parallel or in sequence, it would not really-->
                    <!--matter, the program would still be specified the same way.-->
                </aside>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
def f(x: Int) = x * 3
def g(y: Int) = y + 1

f(g(1))
                </code></pre>
                <div>
                    <table style="width: 100%">
                        <tr><td>
                            <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
f(g(1))
= f(1+1)
= f(2)
= 2*3
= 6
                            </code></pre>
                        </td>
                        <td>
                            <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
f(g(1))
= g(1)*3
= (1+1)*3
= 2*3
= 6
                            </code></pre>
                        </td></tr>
                    </table>
                </div>
                <!--<pre class="fragment"><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.2em">-->
<!--val program = f(3) + g(1)-->
                <!--</code></pre>-->

                <!--<pre><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.2em">-->
<!--trait Program-->
<!--case class Uppercase(s: String)            extends Program-->
<!--case class Concat(a: Program, b: Program)  extends Program-->
<!--case class Return(s: String)               extends Program-->

<!--interpret(Concat(Uppercase("hello"), UpperCase("world")))-->

<!--def interpret(program: Program): Unit = program match {-->
   <!--case Concat(a, b) => parallel(interpret(a), interpret(b)).reduce(_ + _)-->
   <!--case Uppercase(s) => Return(s.toUpperCase)-->
   <!--case Return(r)    => println(r)-->
<!--}-->

<!--def parallel(ps: Program*): List[String] = ???-->
                <!--</code></pre>-->
            </section>
        </section>

        <section data-transition="none none">
            <h2>Composition</h2>
            <section data-transition="none none">
                <aside class="notes">
                    So Referential Transparency compels us to use explicit types and remove the burden of
                    evaluation order in a program. Those two aspects happen to be the pre-requisites for a very
                    important aspect in software programming which is composition. Composition is the cornerstone of
                    any successful design, and it's usually the lack of it that leads a software to a catastrophe.
                    <br/><br/>

                    In order to achieve Composition, two important rules have to be followed. Chaining and Associativity.
                    Two functions for example can only be combined together if the output of the first one has the same
                    type than the output of the second one. This is the chaining rule. Secondly, no matter if we
                    evaluate a function or the other first, we should still get the same result. This is the Associativity
                    rule.<br/><br/>

                    So in the next slides, we'll cover the basic composition mechanisms provided by Functional
                    Programming, first using pure functions only, and then using functions involving effects. So let's
                    start with the basics.
                </aside>
                <pre class="fragment"><code class="scala" data-trim data-noescape style="font-size: 1.5em; line-height: 1.2em">
f : X => Y
g : Y => Z
                </code></pre>
                <pre class="fragment"><code class="scala" data-trim data-noescape style="font-size: 1.5em; line-height: 1.2em">
g ∘ f : X => Z = x => g(f(x))
                </code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    As you probably know, in Functional Programming, functions are first class citizens and are treated just
                    like any other values. So you can pass functions to other functions, return functions from other functions
                    and so forth<br/><br/>

                    In this example, I've created two functions, that can be combined using the compose function, and
                    form another function called add1AndSub2. Functions like compose are called Higher order functions.
                    So whenever a function takes or return another one, it is considered as a higher order function.
                </aside>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.5em; line-height: 1.2em">
val add1: Int => Int = (i:Int) => i + 1
val sub2: Int => Int = (i:Int) => i - 2

def compose[A, B, C](
  f: B => C,
  g: A => B,
): A => C = { a => f(g(a)) }

val add1AndSub2 = compose(add1, sub2)
add1AndSub1(1) == 0
               </code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    Functional Programming puts obviously much emphasis on functions, and therefore provides various ways to
                    compose and decompose them. You can for example create a new function from another one by decomposing it
                    using currying:
                    <br/><br/>
                    Currying consists in transforming a function of arbitrary arity into a composition of unary functions.
                    So a function that takes two arguments, once curried, returns a unary function which returns another
                    unary function which once called, produces the final result that would have been produced by the
                    original function before being curried.
                </aside>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.5em; line-height: 1.2em">
                &nbsp; (Int, Int) => Int becomes Int => Int => Int</code></pre>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.4em; line-height: 1.3em">
val sum:     (Int, Int) => Int = (x, y) => x + y
val curried: Int => Int => Int = x => y => x + y

// Applies the first argument (x)
val f: Int => Int = curried(1)
// Applies the second argument (y) and sum x and y
val g: Int = f(2) // g is now equal to 3
                </code></pre><br/>
                <div style="font-size: 30px; margin:0; padding:0; text-align: left"><i>"Currying is the technique of translating the evaluation of
                    a function that takes multiple arguments into evaluating a sequence of functions, each with a single
                    argument."</i> - Wikipedia</div>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    A very close concept is Partial Application, which consists in producing a function of reduced
                    arity by binding fixed values to some of the original function's arguments.
                    <br/><br/>
                    So you can think about currying and partial-application as techniques to create constructors for
                    Functions, that let you decouple construction from invocation.<br/><br/>

                    Alright. So using these tools, it's actually easy to represent a program through a series of pure
                    function passing data from one to the other. But what about effects?
                </aside>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.3em">
val sum: (Int, Int) => Int = (x, y) => x + y

// Fixes the first argument of sum (x) to 0
val pfs: Int => Int = sum(0, _)

// The 2nd argument (y) is provided, and x + y
// is performed
pfs(42) == 42
                </code></pre><br/>
                <div style="font-size: 30px; margin:0; padding:0; text-align: left"><i>"Partial application refers to the
                    process of fixing a number of arguments to a function, producing another function of smaller
                    arity"</i> - Wikipedia</div>
            </section>

            <section data-transition="none none">
                <aside class="notes">
                    Let's take the example of a FileIO effect, responsible for wrapping a function which interacts with
                    the file system. The problem here, is that we'd like to compose this kind of computation just like
                    we did with pure functions.<br/><br/>

                    Let's look at our compose function. How would work a composition of a pure function and a FileIO
                    value? Well, basically, this would consist in composing the pure function with the one wrapped inside
                    the FileIO effect.<br/><br/>

                    Wasn't that bad after all. Let's look at this function for a bit. So first, we've wrapped a
                    Function in a Computational Context which is FileIO. The goal of this context is to encapsulate the
                    effect generated by the wrapped function. Secondly, we've provided a way to compose this function
                    with other pure functions without having to perform the effect.<br/><br/>

                    Is that alright, or do you need some time to process this? Do you have any question?
                </aside>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.3em">
case class FileIO[A](run: FileSystem => A)
                </code></pre>

                <pre class="fragment"><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.3em">
// Curried version of compose
def compose[Z, A, B](f: A => B)
                    (g: Z => A): Z => B
                </code></pre>
                <pre class="fragment"><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.3em">
def compose[A, B](f: A => B)
                 (io: FileIO[A]): FileIO[B] =
  FileIO { fs: FileSystem =>  f(io.run(fs)) }
                </code></pre>
            </section>

            <section data-transition="none none">
                <aside class="notes">
                    What about generalizing this idea to other effects. After all, the FileIO type is an effect among
                    others just like Maybe or Either, right? Ideally, we'd like to create
                    some kind of interface or contract defining how an effect can be composed.<br/><br/>

                    What is this thing? Let's go step by step. So this trait represents a Composable effect in general.
                    The compose function is responsible for mapping a function wrapped in a effect using a pure
                    function. The E parameter represents the effect's type we are mapping over, so in our case a FileIO
                    or a Maybe. Let's look now at how we could implement this trait.<br/><br/>

                    Now this is great but what's the point of all this abstraction?
                </aside>
                <pre class="fragment" style="width: 100%;"><code class="scala" data-trim data-noescape style="font-size: 1.2em; line-height: 1.1em">
trait Composable[E[_]] {
  def compose[A, B](f: A => B)(fa: E[A]): E[B]
}
                </code></pre>
                <pre class="fragment" style="width: 100%;"><code class="scala" data-trim data-noescape style="font-size: 1.2em; line-height: 1.1em">
implicit val fileIo: Composable[FileIO] = new Composable[FileIO] {
  def compose[A, B](f: A => B)(fa: FileIO[A]): FileIO[B] =
    FileIO { fs: FileSystem =>  f(io.run(fs)) }
}

implicit val maybe: Composable[Maybe] = new Composable[Maybe] {
  def compose[A, B](f: A => B)(ma: Maybe[A]): Maybe[B] =
    ma match {
      case Some(a) => Some(f(a))
      case None => None
    }
}
                </code></pre>
            </section>

            <section data-transition="none none">
                <aside class="notes">
                    Well, let's say that we need to create a function that converts a wrapped Integer to a wrapped String
                    no matter the wrapper's type, as long as an instance of Composable for this type exists<br/><br/>

                    Does anyone here is not familiar with the implicits mechanisms? This is actually pretty awesome, as
                    whenever you need the int2String function to handle a new type, all you have to do is to write an
                    implicit instance of Composable trait for that type. The int2String function does not even need to
                    be touched. This is in my opinion the best way to achieve the open-close principle<br/><br/>

                    Any question? Alright, let's take some steps back now.
                </aside>
                <pre style="width: 100%"><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
def int2String[E[_]: Composable](fi: E[Int]): E[String] = {
  implicitly[Composable[E]].compose(_.toString)(fi)
}
                </code></pre>
                <pre style="width: 100%"><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
val mi: Maybe[Int] = ???
val ms: Maybe[String] = int2String(mi)

val fi: FileIO[Int] = ???
val fs: FileIO[String] = int2String(fi)
                </code></pre>
            </section>

            <section data-transition="none none">
                <aside class="notes">
                    When you were in first grade, you learnt about the domain of numbers. Later, you also learnt that
                    you can combine those numbers using specific operators, and that the domain of numbers is ruled by
                    laws. Numbers, operators and laws, all together form an algebra. Numbers are actually what we call
                    algebraic data types.<br/><br/>

                    Back to our types, we probably can figure out some kind of algebra where the algebraic data
                    types are the types themselves.
                </aside>
                <pre><code data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
// Algebraic data types
1, 2, 3...

// Operations
1 + 2 = 3
3 * 2 = 6

// Laws
0 + x = x
1 * x = x
                </code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    Let's first look at our Composable trait. First, Just like when you sum 1 and 0, composing an effect
                    with a no-op function returns the same original effect, no matter its type.<br/><br/>

                    Secondly, the compose function is associative. So composing an effect with two functions sequentially
                    is the same than composing it with a composition of those two functions.<br/><br/>

                    Ok, I don't expect you to understand those laws right now, just keep in mind that they exist. Now
                    what we've just described is actually called a Functor.
                </aside>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
trait Composable[C[_]] {
  def compose[A, B](f: A => B)(fa: C[A]): C[B]
}

val c: Composable[Maybe] = ???
val mi: Maybe[Int] = ???

                </code></pre>
                <pre class="fragment"><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.1em">
def noop[A](a: A): A = a
c.compose(noop, mi) == mi
                </code></pre>
                <pre class="fragment"><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.1em">
val f: Int => String = ???
val g: Int => Int = ???

c.compose(f ∘ g, mi)
==
c.compose(c.compose(f) ∘ c.compose(g), mi)
                </code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    A Functor, is a type we can map over which obeys to two laws, the identity law and the composition
                    law we've just defined.<br/><br/>

                    The F in the Functor trait is referred to as an effect or computational context, which, in our examples
                    are Maybe or FileIO. Each of those can abstract different behaviors as long as they hold with the
                    Functor's laws.<br/><br/>

                    The pure function let you put a value inside the context of the Functor. It basically allows you
                    to get Functor of A given an A<br/><br/>

                    Concretely, a Functor is the ability to compose with a single effect without needing to “leave” the
                    effect.
                </aside>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
trait Functor[F[_]] {
  def pure[A](a: A): F[A]
  def map[A, B](f: A => B)(fa: F[A]): F[A]
}               </code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    So let's say now that, we'd like to compose a Functor with a function returning another Functor
                    of the same type. Why would we even do that in the first place?<br/><br/>

                    Well, think about two computations among which one results from the other. In this example, we'd like
                    to compose the next function with mi value. This could be done using the map function, however,
                    the result type does not really make sense.<br/><br/>

                    Thing is, we are not interested by the intermediary results generate by the chain of computation bu
                    only by its final result. So let's define a function that implements this behaviour<br/><br/>

                    Nothing new here. We just re-use the same principle than for the map function. What's really
                    interesting here, is that this logic could be actually applied to other effects, just like with the
                    map function. So we clearly have another pattern here. Well, introducing the Monad.
                </aside>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
val F: Functor[Maybe] = ???
val mi: Maybe[Int] = ???
val next: Int => Maybe[String] = ???

val result: Maybe[Maybe[String]] = mf.map(next)(mi)
                </code></pre>
                <pre class="fragment"><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
def chain[A, B](f: A => Maybe[B])
               (ma: Maybe[A]): Maybe[A] = ma match {
  case Some(a) => f(a)
  case None    => None
}
                </code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    Monads represent types that can be sequentially chained with each other using the flatMap function
                    which is our chain function, and are a great tool to represent dependent computations. So whenever
                    the result of a computation depends on the result of another one of the same kind, you should think
                    about Monads.<br/><br/>

                    A Monad has to hold the Functor's contract but also has to obey some other laws we won't cover
                    tonight, just keep in mind they exist.<br/><br/>

                    <!--Won't explain these laws, just know they exist-->

                    <!--The first law of the Monad, is that chaining a Monad with the pure function goes back to return the-->
                    <!--original Monad.<br/><br/>-->

                    <!--Secondly, chaining a Monad with a function, is just like applying the function to the content of-->
                    <!--of the Monad.<br/><br/>-->

                    <!--Finally, flatMap is associative. So it doesn't master how nested chains are composed, just like-->
                    <!--the map function. Once again, I don't expect you to understand all this law tonight. Just keep in mind-->
                    <!--they exist, and take the time to go over them later.-->
                </aside>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
trait Monad[M[_]] {
  def flatMap[A, B](ma: M[A], f: A => M[B]): M[A]
}
                </code></pre>
                <!--<pre><code class="haskell" data-trim data-noescape style="font-size: 1.1em; line-height: 1.0em">-->
<!--val mF: Functor[Maybe] = ???-->
<!--val f1: Int => Maybe[Int] = ???-->
<!--val f2: Int => Maybe[Int] = ???-->
                 <!--</code></pre>-->

                <!--<pre class="fragment"><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.0em">-->
<!--// Left identity law-->
<!--mf.flatMap(mf.pure)(Some(42)) == Some(42)-->
                <!--</code></pre>-->
            <!--<pre class="fragment"><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.0em">-->
<!--// Right identity law-->
<!--mf.flatMap(f1)(Some(42)) == f1(42)-->
                <!--</code></pre>-->
            <!--<pre class="fragment"><code class="scala" data-trim data-noescape style="font-size: 1.1em; line-height: 1.0em">-->
<!--// Composition law-->
<!--mf.flatMap(mf.flatMap(Some(42), f1), f2)-->
<!--==-->
<!--mf.flatMap(Some(42), i => mf.flatMap(f1(i), f2))-->
                <!--</code>-->
            </section>

            <section data-transition="none none">
                <aside class="notes">
                    Ok, so if this is the first time you hear about these patterns and laws, I guess you're a bit
                    confused. This takes a while before being comfortable with these concepts and that's alright.
                    Just keep in mind that Functors are effects that can be mapped over and that Monads are effect
                    that can be chained sequentially. That's all<br/><br/>

                    These are some examples of the Functional Programming patterns, but there are many others.
                </aside>
                <pre><code class="scala" data-trim data-noescape style="font-size: 1.3em; line-height: 1.2em">
trait Functor[F[_]] {
  def pure[A](a: A): F[A]
  def map[A, B](f: A => B)(fa: F[A]): F[A]
}

trait Monad[M[_]] {
  def flatMap[A, B](f: A => M[B])(ma: M[A]): M[A]
}
                </code></pre>
            </section>
            <section data-transition="none none">
                <aside class="notes">
                    Now why do we need all these laws? Well, just like with numbers, a flexible domain is
                    first of all about having small reusable blocks that can composed into larger blocks
                    following a set of rules.<br/><br/>

                    So you can see those rules as some kind of Grammar which specify how one block can be composed
                    with another. And this is actually the secret for keeping a codebase maintainable.<br/><br/>

                    Just look at common languages that we use everyday like French or English. Without a proper
                    grammar those languages would be dead by today. This is why we need laws.
                </aside>
                <img style="vertical-align: text-bottom;margin-top:40px; border: 0; background-color: #243044"
                     src="images/intro_to_fp/g.png" width="550"/>
                <img class="fragment" style="vertical-align: text-bottom;margin-top:40px; border: 0; background-color: #243044"
                     src="images/intro_to_fp/39070116.jpg" width="387"/>
            </section>
        </section>
        <section data-transition="none none">
            <h2>Conclusion</h2>
            <aside class="notes">
                So, we are reaching the end of this talk, and I hope you've enjoyed it. Overall, Functional Programming
                can help you in lot of things like getting a stunning beard, an awesome moustache along with
                a couple of creepy t-shirts. More seriously.<br/><br/>

                I would really recommend every developer to learn about Functional Programming. Not because some consider
                it's better than any other paradigm, but because it's a matter of design. The more ways you can tackle a
                problem, the more relevant your solution for this problem will be.<br/><br/>

                Now when it comes to Functional Programming, you can quickly feel overwhelmed by the amount of
                resources on the Internet. So here's a couple of them I've considered really useful...
            </aside>
            <ul>
                <li><span style="font-size: 30px;color: #42BAE8;">Learn You a Haskell for Great Good! : </span><span style="font-size: 25px">by Miran Lipovaca</span></li>
                <li><span style="font-size: 30px;color: #42BAE8;">Functional Programming in Scala : </span><span style="font-size: 25px">by Paul Chiusano and Rúnar Bjarnason</span></li>
                <li><span style="font-size: 30px;color: #42BAE8;">http://degoes.net/: </span><span style="font-size: 25px">by John A De Goes</span></li>
                <li><span style="font-size: 30px;color: #42BAE8;">https://wiki.haskell.org/Typeclassopedia: </span><span style="font-size: 25px">by Brent Yorgey</span></li>
                <li><span style="font-size: 30px;color: #42BAE8;">Functional and Reactive Domain Modeling: </span><span style="font-size: 25px">by Debasish Ghosh</span></li>
                <li><span style="font-size: 30px;color: #42BAE8;">Real World Haskell: </span><span style="font-size: 25px">by Bryan O'Sullivan, Don Stewart, and John Goerzen</span></li>
            </ul>
        </section>
        <section data-transition="none none">
            <aside class="notes">
                I haven't introduced my self, my name is Francis Toth, I'm a happy Scala developer working at Yoppworks,
                and one of the co-organizer of the Lambda Montreal meetup. A couple of words regarding Yoppworks, well
                we are a company providing consulting and training services in partnership with Hortonworks and
                Lightbend and are looking for people interested by Big Data, Functional Programming And Scala related
                technologies. If you are interested, just come see me and I'll be glad to talk about a potential
                collaboration with you. Thank you again, and now it's time for questions.
            </aside>
            <img style="background-color: transparent"
                 src="images/yoppworks.logo-corner-dark.png"/>
            <span style="font-size: 40px">Thank you ! Questions ?</span><br/>
            <span style="font-size: 25px">francis.toth@yoppworks.com</span>
        </section>
    </div>
</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>

<script>

    // Full list of configuration options available at:
    // https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
            { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
            { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
            { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
            { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
            { src: 'plugin/zoom-js/zoom.js', async: true },
            { src: 'plugin/notes/notes.js', async: true }
        ]
    });

</script>
</body>
</html>

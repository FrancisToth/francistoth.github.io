<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Composition | Francis Toth / Contramap</title>

<meta name="keywords" content="" />
<meta name="description" content="An efficient software design is one allowing its components to be separated and recombined without introducing unexpected behaviors. This topic has been tackled over and over in the past and different approaches like the SOLID principles or the GOF patterns eventually came up to address this problem. Despite their value, these tend to confuse many software developers however. Taken separately, they may indeed sound incomplete and often fail to convey what ties them all together.">
<meta name="author" content="">
<link rel="canonical" href="https://www.contramap.dev/posts/2020-09-22-composition/" />
<link href="https://www.contramap.dev/assets/css/stylesheet.min.d1bc2b736056bd5698d770eeedc08a73bce9e6cebb30810f6f1b2c2048e46ab8.css" integrity="sha256-0bwrc2BWvVaY13Du7cCKc7zp5s67MIEPbxssIEjkarg=" rel="preload stylesheet"
    as="style">

<link rel="icon" href="https://www.contramap.dev/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://www.contramap.dev/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://www.contramap.dev/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://www.contramap.dev/apple-touch-icon.png">
<link rel="mask-icon" href="https://www.contramap.dev/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.68.3" />



<script>
    function openCity(evt, cityName, ref) {
        var i = 0;
        var bar = ref.parentElement;
        var tab = ref.parentElement.parentElement;

        var tabs = tab.getElementsByClassName("city");
        for (i = 0; i < tabs.length; i++) {
            tabs[i].style.display = "none";
            if (tabs[i].id == cityName)
                tabs[i].style.display = "block";
        }

        var tablinks = bar.getElementsByClassName("tablink");
        for (i = 0; i < tabs.length; i++) {
            tablinks[i].className = tablinks[i].className.replace(" white0", "");
        }
        evt.currentTarget.className += " white0";
    }


hljs.registerLanguage("scala", function(e) {
  return {   
    k: {
      keyword: 'type yield lazy override def with val var sealed abstract private trait object if forSome for while throw finally protected extends import final return else break new catch super class case package default try this match continue throws implicit',
      literal: 'true false null'
    },
    c: [
        hljs.QUOTE_STRING_MODE,
        hljs.COMMENT(
          "//",      
          "*"        
        ),
        hljs.COMMENT(
          "/\*",      
          "\*/"        
        )
      ]
  }
});


















































</script>
<style>

    .dark {
        --hljs-bg: rgb(30, 40, 45);
    }
    .post-content .highlight,
    .post-content pre {
        margin-left: 0;
        margin-right: 0;
        background: var(--hljs-bg) !important;
        border-radius: var(--radius);
        background-color: rgb(30, 40, 45) !important;
    }
    .btn {
        -webkit-border-radius: 5;
        -moz-border-radius: 5;
        border-radius: 5px;
        font-family: Arial;
        color: #ffffff;
        font-size: 13px;
        padding: 2px 7px 2px 7px;
        text-decoration: none;
    }

     

    
    .grey0 {
        background: #8a8a8a;
    }
    
    .white0 {
        background: #68899e;
    }

    .dark {
    --hljs-bg: #263238;
    }

    .post-content code {
        font-family: Hack, monospace !important;
    }

    .first-entry {
        position: relative;
        display: flex;
        flex-direction: column;
        justify-content: center;
        min-height: 0px;
        margin: var(--gap) 0 calc(var(--gap) * 2) 0;
        margin-bottom: 0;
    }

.highlight .hll { background-color: #ffffcc }
.highlight  { background: rgb(30, 40, 45); }
.highlight .c { color: #546E7A; font-style: italic }  
.highlight .err { color: #a61717; background-color: #e3d2d2 }  
.highlight .k { color:rgb(194, 136, 232);  }  
.hljs-keyword { color:rgb(194, 136, 232);  }  

.highlight .ch { color: #546E7A; font-style: italic }  
.highlight .cm { color: rgb(167, 159, 148); font-style: italic }  
.highlight .cp { color: #546E7A }  
.highlight .cpf { color: #546E7A; font-style: italic }  
.highlight .c1 { color: rgb(167, 159, 148); font-style: italic }  
.highlight .cs { color: #546E7A; font-weight: bold }  
.highlight .gd { color: #000000; background-color: #ffdddd }  
.highlight .ge { font-style: italic }  
.highlight .gr { color: #aa0000 }  
.highlight .gh { color: #999999 }  
.highlight .gi { color: #000000; background-color: #ddffdd }  
.highlight .go { color: #888888 }  
.highlight .gp { color: #555555 }  
.highlight .gs { font-weight: bold }  
.highlight .gu { color: #aaaaaa }  
.highlight .gt { color: #aa0000 }  
.highlight .kc { color: #F77669; font-weight: bold }  
.highlight .kd { color: rgba(233, 237, 237, 1); font-weight: bold }  
.highlight .kn { color: #000080; font-weight: bold }  
.highlight .kp { color: #000080; font-weight: bold }  
.highlight .kr { color: #000080; font-weight: bold }  
.highlight .kt { color: rgb(127, 174, 255); }  
.highlight .m { color: #F77669 }  
.highlight .s { color: rgb(195, 232, 141) }  
.highlight .n { color: rgba(233, 237, 237, 1); }  
.highlight .na { color: #FF0000 }  
.highlight .nc { color: rgba(233, 237, 237, 1); }  
.highlight .nt { color: #000080; font-weight: bold }  
.highlight .ow { font-weight: bold }  
.highlight .w { color: #bbbbbb }  
.highlight .mb { color: #0000FF }  
.highlight .mf { color: #0000FF }  
.highlight .mh { color: #0000FF }  
.highlight .mi { color:rgb(247, 118, 105) }  
.highlight .mo { color: #0000FF }  
.highlight .sa { color: #0000FF }  
.highlight .sb { color: #0000FF }  
.highlight .sc { color: #800080 }  
.highlight .dl { color: #0000FF }  
.highlight .sd { color: #0000FF }  
.highlight .s2 { color: #0000FF }  
.highlight .se { color: #0000FF }  
.highlight .sh { color: #0000FF }  
.highlight .si { color: #0000FF }  
.highlight .sx { color: #0000FF }  
.highlight .sr { color: #0000FF }  
.highlight .s1 { color: #0000FF }  
.highlight .ss { color: #0000FF }  
.highlight .il { color: #0000FF }  

</style>
<meta property="og:title" content="Composition" />
<meta property="og:description" content="An efficient software design is one allowing its components to be separated and recombined without introducing unexpected behaviors. This topic has been tackled over and over in the past and different approaches like the SOLID principles or the GOF patterns eventually came up to address this problem. Despite their value, these tend to confuse many software developers however. Taken separately, they may indeed sound incomplete and often fail to convey what ties them all together." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.contramap.dev/posts/2020-09-22-composition/" />
<meta property="article:published_time" content="2020-09-22T08:51:48-05:00" />
<meta property="article:modified_time" content="2020-09-22T08:51:48-05:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Composition"/>
<meta name="twitter:description" content="An efficient software design is one allowing its components to be separated and recombined without introducing unexpected behaviors. This topic has been tackled over and over in the past and different approaches like the SOLID principles or the GOF patterns eventually came up to address this problem. Despite their value, these tend to confuse many software developers however. Taken separately, they may indeed sound incomplete and often fail to convey what ties them all together."/>

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Composition",
  "name": "Composition",
  "description": "An efficient software design is one allowing its components to be separated and recombined without introducing unexpected behaviors. This topic has been tackled over and over in …",
  "keywords": [
    
  ],
  "articleBody": "An efficient software design is one allowing its components to be separated and recombined without introducing unexpected behaviors. This topic has been tackled over and over in the past and different approaches like the SOLID principles or the GOF patterns eventually came up to address this problem. Despite their value, these tend to confuse many software developers however. Taken separately, they may indeed sound incomplete and often fail to convey what ties them all together.\nIf we look at this from a higher perspective, they all share the same goal: Making it easier to introduce new business requirements and modify existing ones, while preserving certain properties. In other words: Composition. In this post, we’ll look at some simple composition techniques along with some of the perspectives they offer in terms of design.\nPapers, please  Papers, please is a game created by Lucas Pope in which the player takes on the role of a border-crossing immigration officer in a fictional dystopian country. The game takes place at a migration checkpoint. As the immigration officer, the player must review each immigrant and return citizen’s passports and other supporting paperwork against an ever-growing list of rules using a number of tools and guides, allowing in only those with the proper paperwork while rejecting those without all proper forms, and at times detaining those with falsified information, while also balancing personal finances.\n In the next sections, we’ll model a simplified version of this game to illustrate different patterns you may come across while writing software.\nThe domain Papers, please‘s domain is pretty simple in essence and can be thought about like a business rule engine where each rule defines whether a person can be let through the border or not. First, we need to model the different documents that could be required by the immigration office:\ntype Date = Long type UID = String /* (firstName, lastName, Date Of Birth) */ type Id = (String, String, Date) sealed trait Document object Document { /* * Required by any person attempting to cross the border except * in the case of a asylum request. */ final case class Passport( uid: UID, // A unique id tying a person's papers  id: Id, // The owner's identity  expiration: Date, // the passport's expiration date  foreign: Boolean // tells if the passport is foreign or not  ) extends Document /* Required by all foreigners */ final case class EntryPermit(uid: UID, id: Id, expiration: Date) extends Document /* Required by citizens getting back in the country */ final case class IdCard(uid: UID, id: Id) extends Document /* Required by asylum seekers */ final case class FingerPrints(data: String) extends Document /* Required by asylum seekers */ final case class GrantOfAsylum( uid: UID, id: Id, fingerPrints: FingerPrints ) extends Document } A Rule defines in what circumstances a person is allowed to cross the border. It’s essentially a function taking some input and returning a Result.\ncase class Rule[A](run: A = Result) A Result states whether a person can cross the border or not (Approved or Denied). If it comes out that some papers have been forged, their owner ends up in custody (Detained). Finally, the game defines that the checking process can be aborted in case of extreme circumstances like a terrorist attack (Aborted).\nsealed trait Result object Result { case object Approved extends Result // Visitor can be let through  case object Denied extends Result // Requirements are not met  case object Detained extends Result // Papers are forged  case object Aborted extends Result // In case of a terrorist attack } The rules Having this in mind, let’s try to model some rules:\nobject Rule { /* Creates a `Rule` from a boolean function */ def isTrue[A](f: A = Boolean): Rule[A] = Rule(a = if (f(a)) Approved else Denied) /* Succeeds if the passport is not expired */ val notExpired: Rule[(Date, Date)] = isTrue { case (left, right) = left  right } /* Succeeds if the passport belongs to a citizen */ val citizenPassport: Rule[Passport] = isTrue(p = !p.foreign) /* Succeeds if the passport belongs to a foreigner */ val foreignPassport: Rule[Passport] = isTrue(_.foreign) /* Succeeds if the passport matches the id card */ val passportMatchesIdCard: Rule[(Passport, IdCard)] = isTrue { case (passport, idCard) = passport.id == idCard.id \u0026\u0026 passport.uid == idCard.uid } /* Succeeds if the passport matches the entry permit */ val passportMatchesEntryPermit: Rule[(Passport, EntryPermit)] = isTrue { case (passport, permit) = passport.uid == permit.uid \u0026\u0026 passport.id == permit.id } } In Papers, please, the border can only be crossed if the visitor provides:\n a non-expired citizen passport and a matching id card a non-expired foreign passport and a matching entry permit a grant of asylum and matching fingerprints In any other case, the visitor either provided the wrong documents or attempted to cross the border with forged papers.  The above rules provide solutions for the most basic cases, but cannot cover more complex ones like we just described.\nComposing rules Ideally we’d like to avoid duplication and make these rules composable. Let’s try to model the citizen rule which requires a non-expired citizen passport along with a matching id-card:\nobject Rule { // ...  val citizen: Rule[(Date, Passport, IdCard)] = Rule { case (now, passport, id) = val result0 = citizenPassport.run(passport) val result1 = notExpired.run((passport.expiration, now)) val result2 = passportMatchesIdCard.run((passport, id)) // No way to combine results so far  ??? } } We currently have no way to combine results, and therefore need to add some machinery to achieve that. Let’s add an operator \u0026\u0026 to Result:\nsealed trait Result { self = def \u0026\u0026(that: Result): Result = (self, that) match { case (_, Aborted) = that // process has been aborted  case (Approved, _) = that // left side is ok, keep proceeding  case _ = self // left side is not ok, do not proceed  } } The citizen rule can be now built like this:\nobject Rule { // ...  val citizen: Rule[(Date, Passport, IdCard)] = Rule { ctx = case (now, passport, id) = val result0 = citizenPassport.run(passport) val result1 = notExpired.run((passport.expiration, now)) val result2 = passportMatchesIdCard.run((passport, id)) result0 \u0026\u0026 result1 \u0026\u0026 result2 } } This leads us to a first best practice to make a DSL composable: provide binary operators returning their inputs type:\n(A, A) = A This is exactly what we’ve done with Result.\u0026\u0026 which takes two Result's (self and that) and returns another Result combining them. This operator helped us implementing the citizen but we can do better. To simplify the addition of other rules, we should also provide a combinator to Rule so that:\n// Pseudo code: val citizen = citizenPassport \u0026\u0026 passportNotExpired \u0026\u0026 passportMatchesIdCard Let’s build this step by step. First we need to add the operator in question:\ncase class Rule[A](run: A = Result) { self = /* * Combines two rules and returns another one requiring a product * of their input */ def \u0026\u0026[B](that: Rule[B]): Rule[(A, B)] = Rule { case (a, b) = self.run(a) \u0026\u0026 that.run(b) } } The citizen rule can now be formed like following:\nval citizen: Rule[((Passport, (Date, Date)), (Passport, IdCard))] = citizenPassport \u0026\u0026 notExpired \u0026\u0026 passportMatchesIdCard citizen's type is awkward however and contains many redundancies. Ideally, we’d like something closer to:\nval citizen: Rule[(Passport, Date, IdCard)] = ??? In order to run this rule, we would have to provide a tuple containing the passport, the current date, and a matching id card. These inputs could be then redistributed to the different underlying rules forming the resulting composition. This operator would therefore look like this:\ndef bothWith[B, C](that: Rule[B])(f: C = (A, B)): Rule[C] = ??? In other words, as long as we know how to decompose an input C into a product of A and B, we can combine two rules taking respectively an A and a B. The implementation happens to be quite straightforward:\ncase class Rule[-A](run: A = Result) { self = // ...  /* * Combines two rules respectively requiring an `A` and a `B` * into a rule requiring a `(A, B)`. */ def bothWith[B, C]( that: Rule[B] )(f: C = (A, B)): Rule[C] = Rule { c = val (a, b) = f(c) self.run(a) \u0026\u0026 that.run(b) } } As a matter of fact, \u0026\u0026 can be expressed in terms of bothWith making it a derived operator:\ncase class Rule[A](run: A = Result) { self = /* * Alias for `both` */ def \u0026\u0026[B](that: Rule[B]): Rule[(A, B)] = both(that) /* Alias for `bothWith` provided with the `identity` function */ def both[B](that: Rule[B]): Rule[(A, B)] = bothWith(that)(identity) /* * Combines two rules respectively requiring an `A` and a `B` * into a rule requiring a product of A and B. */ def bothWith[B, C]( that: Rule[B] )(f: C = (A, B)): Rule[C] = Rule { c = // As long as we know how to extract `A` et `B` from `C`,  // we can build a `Rule[C]` from a `Rule[A]` and a `Rule[B]`  val (a, b) = f(c) self.run(a) \u0026\u0026 that.run(b) } } bothWith is one of the typical composition patterns you may come across while writing composable software. It fits well with data-structures being invariant or contravariant in A, that is which provide functions taking/consuming A's. bothWith happens to be the solution required to model the citizen rule:\n/* * A citizen must provide a non-expired passport along with a matching * id card */ val citizen: Rule[(Date, Passport, IdCard)] = (citizenPassport \u0026\u0026 notExpired) // Rule[(Passport, (Date, Date))]  .bothWith(passportMatchesIdCard) { // Rule[(Passport, IdCard)]  case (now, passport, idCard) = ((passport, (passport.expiration, now)), (passport, idCard)) // ^ ^ ^  // citizenPassport notExpired passportMatchesIdCard  } We first combine citizenPassport and notExpired into a Rule[(Passport, (Date, Date))], then call bothWith to combine the result into a Rule[(Date, Passport, IdCard)] using a function taking the provided input and returning a tuple containing each underlying rule’s input. We can proceed the same way to define the foreigner rule (We decomposed the process into more steps for learning purpose):\n/* * A foreigner must provide a non-expired passport and a matching * entry permit */ val foreigner: Rule[(Date, Passport, EntryPermit)] = { val step1: Rule[(Passport, (Date, Date))] = foreignPassport \u0026\u0026 notExpired val step2: Rule[(Passport, EntryPermit)] = passportMatchesEntryPermit step1.bothWith(step2) { case (now, passport, permit) = ((passport, (passport.expiration, now)), (passport, permit)) // ^ ^ ^  // foreignPassport notExpired passportMatchesEntryPermit  } } We now have almost all the pieces to define the general rule of the game. To do so, we have to compose the citizen with the foreigner so that:\n// Pseudo code val visitorRule: Rule[???] = citizen || foreigner We don’t have any operator for doing such composition yet, but before coding anything let’s ask ourselves what the return type of that operator should be. If we think about it, the resulting type should capture the idea that the rule requires one or another input. For this reason, Either is a natural choice:\ntype Citizen = (Date, Passport, IdCard) type Foreigner = (Date, Passport, EntryPermit) type ||[A, B] = Either[A, B] val visitorRule: Rule[Citizen || Foreigner] = ??? Let’s now implement the operator needed to do such composition:\ncase class Rule[A](run: A = Result) { self = // ...  def ||[B](that: Rule[B]): Rule[Either[A, B]] = Rule { case Left(a) = self.run(a) case Right(b) = that.run(b) } } The implementation is pretty straightforward, but the result is not that great:\ntype Citizen = (Date, Passport, IdCard) type Foreigner = (Date, Passport, EntryPermit) type ||[A, B] = Either[A, B] val visitorRule: Rule[Citizen || Foreigner] = citizen || foreigner /* which is equivalent to val visitorRule: Rule[ (Date, Passport, IdCard) || (Date, Passport, EntryPermit) ] = citizen || foreigner */ Just like earlier we have too many redundancies in the resulting type and some refinement is required. Let’s implement a more generic version of ||:\ncase class Rule[A](run: A = Result) { self = /* * Combines two rules respectively requiring an `A` and a `B` * into a rule requiring either an `A` or a `B`. */ def eitherWith[B, C]( that: Rule[B] )(f: C = Either[A, B]): Rule[C] = Rule { c = f(c) match { case Left(a) = self.run(a) case Right(b) = that.run(b) } } } In other words, as long as we know how to convert an input C into an either of A and B, we can combine two rules taking respectively an A and a B. Just like bothWith, eitherWith happens to be a primary operator from which || is derived:\ncase class Rule[-A](run: A = Result) { self = /* * Alias for `either` */ def ||[B](that: Rule[B]): Rule[Either[A, B]] = either(that) /* * Alias for `eitherWith` with the identity function provided */ def either[B](that: Rule[B]): Rule[Either[A, B]] = eitherWith(that)(identity) } eitherWith is another typical composition pattern you may come across while writing composable software. It fits well with data-structures being invariant or covariant in A, that is which provide functions returning/producing A's. This new operator happens to be exactly what we need to compose the visitor rule:\n/* * A visitor other than a refugee must either: * - provide a valid passport and an id card (citizen rule) * - or provide a valid passport and an entry permit (foreigner rule) */ val visitor: Rule[(Date, Passport, IdCard || EntryPermit)] = citizen.eitherWith(foreigner) { case (now, passport, Left(idCard)) = Left((now, passport, idCard)) case (now, passport, Right(permit)) = Right((now, passport, permit)) } Sum and Product composition You may notice a certain similarity between bothWith and eitherWith. This is not surprising, as they both define two kinds of composition patterns respectively known as product composition and sum composition:\ndef bothWith[B, C] (that: Rule[B])(f: C = (A, B)): Rule[C] = /* ... */ def eitherWith[B, C](that: Rule[B])(f: C = A || B): Rule[C] = /* ... */ These two patterns mirror each others in regards to composition, and it’s overall a best practice to look for them whenever you write a composable DSL.\nFallback rule In some cases, the game may be aborted under extreme circumstances such as a terrorist attack. Let’s see how we could reflect that in our model:\n// Pseudo code val game: Rule[(Passport, IdCard || EntryPermit)] = visitor + terroristAttack First let’s think about how terroristAttack should be represented. Overall, this rule does not care about the document provided. So technically it could take any document, and as an output always return Aborted:\nRule(_ = Aborted) Secondly, combining terroristAttack with another rule should not change the type of the latter. So the combination of terroristAttack with visitorRule should have the same type than visitorRule. This can be implemented in different ways, using contravariance for example:\n// Note the - in front of A case class Rule[-A](run: A = Result) { /* ... */ } val terroristAttack: Rule[Any] = Rule(_ = Aborted) Let’s now encode the operator combining visitor with terroristAttack:\ncase class Rule[-A](run: A = Result) { self = def orElse[A0  A](that: Rule[A0]): Rule[A0] = Rule { a = val r0 = self.run(a) val r1 = that.run(a) ??? } } To finish this implementation, we’ll need to provide a way to combine Result so that r0 falls back to r1 whenever it’s not Approved:\nsealed trait Result { self = // ...  def ||(that: Result): Result = self match { case Detained | Denied = that case _ = self } } Using this new combinator, we can now finish orElse's implementation:\ncase class Rule[-A](run: A = Result) { self = // ...  def orElse[A0  A](that: Rule[A0]): Rule[A0] = Rule { a = val r0 = self.run(a) val r1 = that.run(a) r0 || r1 } } As you can guess, this is another typical composition pattern that can be generalized like following:\ncase class Rule[-A](run: Context[A] = Result) { self = // ...  def orElse[A0  A](that: Rule[A0]): Rule[A0] = zipWith(that)(_ || _) def zipWith[A0  A]( that: Rule[A0] )(f: (Result, Result) = Result): Rule[A0] = Rule { ctx = val r0 = self.run(ctx) val r1 = that.run(ctx) f(r0, r1) } } This implementation of zipWith is specific to our domain. Generally, zipWith looks more like the following:\ncase class Data[A](value: A) { self = // ...  def zip[A, B](that: Data[B]): Data[(A, B)] = zipWith(that)((_, _)) def zipWith[B, C]( that: Data[B] )(f: (A, B) = C): Data[C] = Data { ctx = f(self.value, that.value) } } In our example however, having a Rule returning a product of Result (that is a (Result, Result)) is unsound from a domain perspective. zipWith is a covariant analogue of bothWith. It is mostly found in invariant and covariant data-structures and is probably one of the most common composition pattern. With this new tool in our belt, we can finish the description of the game’s rules:\nval game: Rule[(Passport, IdCard || EntryPermit)] = visitor.orElse(terroristAttack) Hold on, what about the refugee rule? Thanks to our new combinators, introducing that one is a piece of cake:\ntype Refugee = (GrantOfAsylum, FingerPrints) type Visitor = (Date, Passport, IdCard || EntryPermit) val game: Rule[Visitor || Refugee] = (visitor || refugee).orElse(terroristAttack) Going further Is that it? Well, actually there’s more we can talk about regarding this topic. So far we represented every terms of our DSL using a simple function:\nA = Result In other words, the evaluation of the solution is embedded in the resulting data-structure. This happened to be pretty useful but there are some drawbacks:\n Testability: the solution being a function, there is no way to inspect its content without executing it. If the function has unexpected side-effects, we would lose the ability to reason about it locally. Optimization: rules can currently only be composed using function composition. This prevents us to perform any optimization in the way these functions are called and run. Extendability: if we had to provide another way to evaluate the solution, we would have to change every operator (bothWith, eitherWith, zipWith) and primitive (notExpired, refugee, passportMatchesIdCard, …) provided by this DSL.  Another way to encode this domain would be to solely rely on pure data-structures. Instead of embedding the evaluation function, we can put that one aside and represent the output of each operator using a date-structure:\nobject DSL { type ||[A, B] = Either[A, B] final case class Always[F[_]](result: Result) extends DSL[Any, F] final case class OrElse[A, F[_]]( left: DSL[A, F], right: DSL[A, F] ) extends SL[A, F] final case class BothWith[A, B, C, F[_]]( left: DSL[A, F], right: DSL[B, F], f: C = (A, B) ) extends DSL[C, F] final case class EitherWith[A, B, C, F[_]]( left: DSL[A, F], right: DSL[B, F], f: C = A || B ) extends DSL[C, F] case class Pure[F[_], A](fa: F[A]) extends DSL[A, F] } But what is that F[_]? F[_] is a way to compose this dsl with another one, like Rule for example:\nsealed trait Rule[-A] object Rule { final case object CitizenPassport extends Rule[Passport] final case object ForeignPassport extends Rule[Passport] final case object Refugee extends Rule[(GrantOfAsylum, FingerPrints)] final case object PassportMatchesIdCard extends Rule[(Passport, IdCard)] final case object PassportMatchesEntryPermit extends Rule[(Passport, EntryPermit)] final case object NotExpired extends Rule[(Date, Date)] final case object TerroristAttack extends Rule[Any] } The combination of these two DSLs would look like this:\ntype RuleF[A] = DSL[A, Rule] val notExpired: RuleF[(Date, Date)] = Pure(NotExpired) val citizenPassport: RuleF[Passport] = Pure(CitizenPassport) val foreignPassport: RuleF[Passport] = Pure(ForeignPassport) val terroristAttack: RuleF[Any] = Pure(TerroristAttack) val refugee: RuleF[(GrantOfAsylum, FingerPrints)] = Pure(Refugee) val passportMatchesIdCard: RuleF[(Passport, IdCard)] = Pure(PassportMatchesIdCard) val passportMatchesEntryPermit: RuleF[(Passport, EntryPermit)] = Pure(PassportMatchesEntryPermit) What about the combinators? These actually do not need to change that much:\nsealed trait DSL[-A, F[_]] { self = def \u0026\u0026[B](that: DSL[B, F]): DSL[(A, B), F] = bothWith(that)(identity) def eitherWith[B, C]( that: DSL[B, F] )(f: C = Either[A, B]): DSL[C, F] = EitherWith(self, that, f) def ||[B](that: DSL[B, F]): DSL[Either[A, B], F] = eitherWith(that)(identity) def bothWith[B, C](that: DSL[B, F])(f: C = (A, B)): DSL[C, F] = BothWith(self, that, f) def orElse[A0  A](that: DSL[A0, F]): DSL[A0, F] = OrElse(self, that) } and the remaining rules can be left as is, as they are expressed only using existing solutions (refugee, citizenPassport…) and operators (\u0026\u0026, ||. eitherWith, …):\nval game: RuleF[Visitor || Refugee] = (visitor || refugee).orElse(terroristAttack) Once we have the right data-structure, we need a function to evaluate it:\ndef run[A, F[_]](rule: DSL[A, Rule])(ctx: A): Result = rule match { case Always(r) = r case oe: OrElse[A, Rule] = run(oe.left)(ctx) || run(oe.right)(ctx) case bw: BothWith[a, b, A, Rule] = val (a, b) = bw.f(ctx) run(bw.left)(a) \u0026\u0026 run(bw.right)(b) case ew: EitherWith[a, b, A, Rule] = ew.f(ctx) match { case Left(a) = run(ew.left)(a) case Right(b) = run(ew.right)(b) } case Pure(fa) = eval(fa)(ctx) } def eval[A](rule: Rule[A])(value: A): Result = rule match { case CitizenPassport = if (value.foreign) Denied else Approved case ForeignPassport = if (value.foreign) Approved else Denied case NotExpired = val (l, r) = value if (l  r) Approved else Denied case PassportMatchesIdCard = val (passport, idCard) = value if (passport.uid == idCard.uid) Approved else Detained case PassportMatchesEntryPermit = val (passport, permit) = value if (passport.uid == permit.uid) Approved else Detained case Refugee = val (grant, prints) = value if (grant.fingerPrints.data == prints.data) Approved else Detained case TerroristAttack = Aborted } Note that we use two functions here, one for each DSL. Secondly, these are not stack-safe and would crash if recursive rules are created. We can fix this using techniques such as Trampolining, but this will be the topic of another post.\nTaking some steps back No matter the approach, we ended up using three types of block:\n primitives: which model simple solutions (notExpired, CitizenPassport…) constructors: which build solutions from existing solutions (citizen, foreigner, …) operators: which transform/combine solutions into other solutions (eitherWith, bothWith, …).  As explained by John DeGoes and Ruurtjan Pul in this post, there are some best practices regarding how primitives should be designed:\n  Composable: to build complex solutions using simple components; Orthogonal: such that there’s no overlap in capabilities between primitives; Minimal: in terms of the number of primitives.   Secondly, in terms of encoding, we first embedded the evaluation function within the resulting data-structure. Later on we decided to pull it apart and use pure data-structures only. The first type of encoding is referred to as an executable encoding. It implies that every constructor and operators of the model is expressed in terms of its execution. It’s defined in opposition with the declarative encoding used in the second implementation, where every constructor and operator of the model is expressed as pure data in a recursive tree structure.\nBoth types of encoding have their trade-offs. With an executable encoding, adding new constructors and operators is easy, as they are all defined using the same function, while adding new evaluation functions is harder, as it potentially requires changing every operator and constructors of the DSL. It’s the exact opposite with a declarative encoding where adding new evaluation functions is easy (as these are defined separately), but adding new constructors and operators is painful. You may recognize the expression problem here which is the very reason why Object Oriented Programming and Functional Programming exist.\nMoreover, both encodings tend to perform better in specific cases. The declarative encoding will usually be a better fit for use-cases involving optimizations (thanks to inspections capabilities) and/or persistence (thanks to pure data-structures), while the executable encoding is a better choice when it comes to improve legacy code. If you would like to go further, it is highly suggested to read the following post, which inspired this article a lot.\nWrapping Up This post was rather long, so here is a quick recap:\n To improve composition, define primitives, constructors and operators using the best practices described above Provide these with binary operators to compose them forever (bothWith, eitherWith, zipWith, …) Use the adequate encoding (executable/declarative) depending on your use-case but keep in mind that a declarative encoding suits a greenfield project better.  The code of this post is all available here. Thank you for reading, and thanks to John De Goes for all his time teaching us writing better code.\n",
  "wordCount" : "3980",
  "inLanguage": "en",
  "datePublished": "2020-09-22T08:51:48-05:00",
  "dateModified": "2020-09-22T08:51:48-05:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://www.contramap.dev/posts/2020-09-22-composition/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Francis Toth / Contramap",
    "logo": {
      "@type": "ImageObject",
      "url": "https://www.contramap.dev/favicon.ico"
    }
  }
}
</script>



</head>

<body class=" dark">
<noscript>
    <style type="text/css">
        .theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://www.contramap.dev/" accesskey="h" title="Francis Toth / Contramap (Alt + H)">Francis Toth / Contramap</a>
            <span class="logo-switches">
                
            </span>
        </div>
        <ul class="menu" id="menu" onscroll="menu_on_scroll()">
            <li>
                <a href="https://www.contramap.dev/about/" title="about">
                    <span>about</span>
                </a>
            </li>
            <li>
                <a href="https://www.contramap.dev/talks/" title="talks">
                    <span>talks</span>
                </a>
            </li>
            <li>
                <a href="https://www.contramap.dev/cv/" title="resume">
                    <span>resume</span>
                </a>
            </li><li>
                <a style="display: inline;" target="_blank" href="https://twitter.com/francistoth?lang=en">
                    <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" style="height: 20px; width: 30px; fill: currentColor; transition: transform .1s">
                        <path
                            d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
                    </svg>
                </a>
                <a style="display: inline;" target="_blank" href="https://ca.linkedin.com/in/francistoth/en-us">
                    <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" style="height: 20px; width: 30px; fill: currentColor; transition: transform .1s">
                        <path
                            d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
                    </svg>
                </a>
                <a style="display: inline;" target="_blank" href="https://github.com/FrancisToth">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round", style="height: 20px; width: 30px; fill: currentColor; transition: transform .1s">
                        <path
                            d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22">
                        </path>
                    </svg>
                </a>
            </li>
            
        </ul>
    </nav>
</header>

    <main class="main">

<article class="post-single">
  <header class="post-header">
    <h1 class="post-title">
      Composition
    </h1>
    <div class="post-meta">September 22, 2020

    </div>
  </header> 

  <div class="post-content">
<p><strong>An efficient software design is one allowing its components to be separated and recombined without introducing unexpected behaviors</strong>. This topic has been tackled over and over in the past and different approaches like the <a href="https://en.wikipedia.org/wiki/SOLID">SOLID principles</a> or the <a href="https://en.wikipedia.org/wiki/Design_Patterns">GOF patterns</a> eventually came up to address this problem. Despite their value, these tend to confuse many software developers however. Taken separately, they may indeed sound incomplete and often fail to convey what ties them all together.</p>
<p>If we look at this from a higher perspective, they all share the same goal: <strong>Making it easier to introduce new business requirements and modify existing ones, while preserving certain properties</strong>. In other words: <strong>Composition</strong>. In this post, we&rsquo;ll look at some simple composition techniques along with some of the perspectives they offer in terms of design.</p>
<h2 id="papers-please">Papers, please<a hidden class="anchor" aria-hidden="true" href="#papers-please">#</a></h2>
<blockquote>
<p><a href="https://en.wikipedia.org/wiki/Papers,_Please">Papers, please</a> is a game created by Lucas Pope in which the player takes on the role of a border-crossing immigration officer in a fictional dystopian country. The game takes place at a migration checkpoint. As the immigration officer, the player must review each immigrant and return citizen&rsquo;s passports and other supporting paperwork against an ever-growing list of rules using a number of tools and guides, allowing in only those with the proper paperwork while rejecting those without all proper forms, and at times detaining those with falsified information, while also balancing personal finances.</p>
</blockquote>
<p>In the next sections, we&rsquo;ll model a simplified version of this game to illustrate different patterns you may come across while writing software.</p>
<h2 id="the-domain">The domain<a hidden class="anchor" aria-hidden="true" href="#the-domain">#</a></h2>
<p><a href="https://en.wikipedia.org/wiki/Papers,_Please">Papers, please</a>&lsquo;s domain is pretty simple in essence and can be thought about like a business rule engine where each rule defines whether a person can be let through the border or not. First, we need to model the different documents that could be required by the immigration office:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">type</span> <span class="kt">Date</span> <span class="o">=</span> <span class="nc">Long</span>
<span class="k">type</span> <span class="kt">UID</span>  <span class="o">=</span> <span class="nc">String</span>

<span class="cm">/* (firstName, lastName, Date Of Birth) */</span>
<span class="k">type</span> <span class="kt">Id</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">,</span> <span class="nc">Date</span><span class="o">)</span>
<span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Document</span>
<span class="k">object</span> <span class="nc">Document</span> <span class="o">{</span>
  <span class="cm">/*
</span><span class="cm">   * Required by any person attempting to cross the border except 
</span><span class="cm">   * in the case of a asylum request.
</span><span class="cm">   */</span>
  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Passport</span><span class="o">(</span>
    <span class="n">uid</span><span class="k">:</span> <span class="kt">UID</span><span class="o">,</span>         <span class="c1">// A unique id tying a person&#39;s papers
</span><span class="c1"></span>    <span class="n">id</span><span class="k">:</span> <span class="kt">Id</span><span class="o">,</span>           <span class="c1">// The owner&#39;s identity
</span><span class="c1"></span>    <span class="n">expiration</span><span class="k">:</span> <span class="kt">Date</span><span class="o">,</span> <span class="c1">// the passport&#39;s expiration date
</span><span class="c1"></span>    <span class="n">foreign</span><span class="k">:</span> <span class="kt">Boolean</span>  <span class="c1">// tells if the passport is foreign or not
</span><span class="c1"></span>  <span class="o">)</span> <span class="k">extends</span> <span class="nc">Document</span>

  <span class="cm">/* Required by all foreigners */</span>
  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">EntryPermit</span><span class="o">(</span><span class="n">uid</span><span class="k">:</span> <span class="kt">UID</span><span class="o">,</span> <span class="n">id</span><span class="k">:</span> <span class="kt">Id</span><span class="o">,</span> <span class="n">expiration</span><span class="k">:</span> <span class="kt">Date</span><span class="o">)</span> 
    <span class="k">extends</span> <span class="nc">Document</span>

  <span class="cm">/* Required by citizens getting back in the country */</span>
  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">IdCard</span><span class="o">(</span><span class="n">uid</span><span class="k">:</span> <span class="kt">UID</span><span class="o">,</span> <span class="n">id</span><span class="k">:</span> <span class="kt">Id</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Document</span>

  <span class="cm">/* Required by asylum seekers */</span>
  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">FingerPrints</span><span class="o">(</span><span class="n">data</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Document</span>

  <span class="cm">/* Required by asylum seekers */</span>
  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">GrantOfAsylum</span><span class="o">(</span>
    <span class="n">uid</span><span class="k">:</span> <span class="kt">UID</span><span class="o">,</span>
    <span class="n">id</span><span class="k">:</span> <span class="kt">Id</span><span class="o">,</span>
    <span class="n">fingerPrints</span><span class="k">:</span> <span class="kt">FingerPrints</span>
  <span class="o">)</span> <span class="k">extends</span> <span class="nc">Document</span>
<span class="o">}</span>
</code></pre></div><p>A <code>Rule</code> defines in what circumstances a person is allowed to cross the border. It&rsquo;s essentially a function taking some input and returning a <code>Result</code>.</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">case</span> <span class="k">class</span> <span class="nc">Rule</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">run</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Result</span><span class="o">)</span>
</code></pre></div><p>A <code>Result</code> states whether a person can cross the border or not (<code>Approved</code> or <code>Denied</code>). If it comes out that some papers have been forged, their owner ends up in custody (<code>Detained</code>). Finally, the game defines that the checking process can be aborted in case of extreme circumstances like a terrorist attack (<code>Aborted</code>).</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Result</span>
<span class="k">object</span> <span class="nc">Result</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">Approved</span> <span class="k">extends</span> <span class="nc">Result</span> <span class="c1">// Visitor can be let through
</span><span class="c1"></span>  <span class="k">case</span> <span class="k">object</span> <span class="nc">Denied</span>   <span class="k">extends</span> <span class="nc">Result</span> <span class="c1">// Requirements are not met
</span><span class="c1"></span>  <span class="k">case</span> <span class="k">object</span> <span class="nc">Detained</span> <span class="k">extends</span> <span class="nc">Result</span> <span class="c1">// Papers are forged
</span><span class="c1"></span>  <span class="k">case</span> <span class="k">object</span> <span class="nc">Aborted</span>  <span class="k">extends</span> <span class="nc">Result</span> <span class="c1">// In case of a terrorist attack
</span><span class="c1"></span><span class="o">}</span>
</code></pre></div><h2 id="the-rules">The rules<a hidden class="anchor" aria-hidden="true" href="#the-rules">#</a></h2>
<p>Having this in mind, let&rsquo;s try to model some rules:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">object</span> <span class="nc">Rule</span> <span class="o">{</span>

  <span class="cm">/* Creates a `Rule` from a boolean function */</span>
  <span class="k">def</span> <span class="n">isTrue</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Rule</span><span class="o">(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="k">if</span> <span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">))</span> <span class="nc">Approved</span> <span class="k">else</span> <span class="nc">Denied</span><span class="o">)</span>

  <span class="cm">/* Succeeds if the passport is not expired */</span>
  <span class="k">val</span> <span class="n">notExpired</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[(</span><span class="kt">Date</span>, <span class="kt">Date</span><span class="o">)]</span> <span class="k">=</span> <span class="n">isTrue</span> <span class="o">{</span>
    <span class="k">case</span> <span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span>
  <span class="o">}</span>

  <span class="cm">/* Succeeds if the passport belongs to a citizen */</span>
  <span class="k">val</span> <span class="n">citizenPassport</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[</span><span class="kt">Passport</span><span class="o">]</span> <span class="k">=</span> <span class="n">isTrue</span><span class="o">(</span><span class="n">p</span> <span class="k">=&gt;</span> <span class="o">!</span><span class="n">p</span><span class="o">.</span><span class="n">foreign</span><span class="o">)</span>

  <span class="cm">/* Succeeds if the passport belongs to a foreigner */</span>
  <span class="k">val</span> <span class="n">foreignPassport</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[</span><span class="kt">Passport</span><span class="o">]</span> <span class="k">=</span> <span class="n">isTrue</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">foreign</span><span class="o">)</span>

  <span class="cm">/* Succeeds if the passport matches the id card */</span>
  <span class="k">val</span> <span class="n">passportMatchesIdCard</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[(</span><span class="kt">Passport</span>, <span class="kt">IdCard</span><span class="o">)]</span> <span class="k">=</span> 
    <span class="n">isTrue</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">passport</span><span class="o">,</span> <span class="n">idCard</span><span class="o">)</span> <span class="k">=&gt;</span> 
      <span class="n">passport</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">idCard</span><span class="o">.</span><span class="n">id</span> <span class="o">&amp;&amp;</span> <span class="n">passport</span><span class="o">.</span><span class="n">uid</span> <span class="o">==</span> <span class="n">idCard</span><span class="o">.</span><span class="n">uid</span> 
    <span class="o">}</span>
    
  <span class="cm">/* Succeeds if the passport matches the entry permit */</span>
  <span class="k">val</span> <span class="n">passportMatchesEntryPermit</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[(</span><span class="kt">Passport</span>, <span class="kt">EntryPermit</span><span class="o">)]</span> <span class="k">=</span> 
    <span class="n">isTrue</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">passport</span><span class="o">,</span> <span class="n">permit</span><span class="o">)</span> <span class="k">=&gt;</span> 
      <span class="n">passport</span><span class="o">.</span><span class="n">uid</span> <span class="o">==</span> <span class="n">permit</span><span class="o">.</span><span class="n">uid</span> <span class="o">&amp;&amp;</span> <span class="n">passport</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">permit</span><span class="o">.</span><span class="n">id</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>In <a href="https://en.wikipedia.org/wiki/Papers,_Please">Papers, please</a>, the border can only be crossed if the visitor provides:</p>
<ul>
<li>a non-expired citizen passport and a matching id card</li>
<li>a non-expired foreign passport and a matching entry permit</li>
<li>a grant of asylum and matching fingerprints
In any other case, the visitor either provided the wrong documents or attempted to cross the border with forged papers.</li>
</ul>
<p>The above rules provide solutions for the most basic cases, but cannot cover more complex ones like we just described.</p>
<h2 id="composing-rules">Composing rules<a hidden class="anchor" aria-hidden="true" href="#composing-rules">#</a></h2>
<p>Ideally we&rsquo;d like to avoid duplication and make these rules composable. Let&rsquo;s try to model the citizen rule which requires a non-expired citizen passport along with a matching id-card:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">object</span> <span class="nc">Rule</span> <span class="o">{</span>
  <span class="c1">// ...
</span><span class="c1"></span>  <span class="k">val</span> <span class="n">citizen</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[(</span><span class="kt">Date</span>, <span class="kt">Passport</span>, <span class="kt">IdCard</span><span class="o">)]</span> <span class="k">=</span> <span class="nc">Rule</span> <span class="o">{</span>
    <span class="k">case</span> <span class="o">(</span><span class="n">now</span><span class="o">,</span> <span class="n">passport</span><span class="o">,</span> <span class="n">id</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="n">result0</span> <span class="k">=</span> <span class="n">citizenPassport</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">passport</span><span class="o">)</span>
      <span class="k">val</span> <span class="n">result1</span> <span class="k">=</span> <span class="n">notExpired</span><span class="o">.</span><span class="n">run</span><span class="o">((</span><span class="n">passport</span><span class="o">.</span><span class="n">expiration</span><span class="o">,</span> <span class="n">now</span><span class="o">))</span>
      <span class="k">val</span> <span class="n">result2</span> <span class="k">=</span> <span class="n">passportMatchesIdCard</span><span class="o">.</span><span class="n">run</span><span class="o">((</span><span class="n">passport</span><span class="o">,</span> <span class="n">id</span><span class="o">))</span>
      <span class="c1">// No way to combine results so far
</span><span class="c1"></span>      <span class="o">???</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>We currently have no way to combine results, and therefore need to add some machinery to achieve that. Let&rsquo;s add an operator <code>&amp;&amp;</code> to <code>Result</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Result</span> <span class="o">{</span> <span class="n">self</span> <span class="k">=&gt;</span>
  <span class="k">def</span> <span class="o">&amp;&amp;(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Result</span><span class="o">)</span><span class="k">:</span> <span class="kt">Result</span> <span class="o">=</span>
    <span class="o">(</span><span class="n">self</span><span class="o">,</span> <span class="n">that</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="nc">Aborted</span><span class="o">)</span>  <span class="k">=&gt;</span> <span class="n">that</span> <span class="c1">// process has been aborted
</span><span class="c1"></span>      <span class="k">case</span> <span class="o">(</span><span class="nc">Approved</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">that</span> <span class="c1">// left side is ok, keep proceeding
</span><span class="c1"></span>      <span class="k">case</span> <span class="k">_</span>             <span class="k">=&gt;</span> <span class="n">self</span> <span class="c1">// left side is not ok, do not proceed
</span><span class="c1"></span>    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>The citizen rule can be now built like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">object</span> <span class="nc">Rule</span> <span class="o">{</span>
  <span class="c1">// ...
</span><span class="c1"></span>  <span class="k">val</span> <span class="n">citizen</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[(</span><span class="kt">Date</span>, <span class="kt">Passport</span>, <span class="kt">IdCard</span><span class="o">)]</span> <span class="k">=</span> <span class="nc">Rule</span> <span class="o">{</span> <span class="n">ctx</span> <span class="k">=&gt;</span>
    <span class="k">case</span> <span class="o">(</span><span class="n">now</span><span class="o">,</span> <span class="n">passport</span><span class="o">,</span> <span class="n">id</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="n">result0</span> <span class="k">=</span> <span class="n">citizenPassport</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">passport</span><span class="o">)</span>
      <span class="k">val</span> <span class="n">result1</span> <span class="k">=</span> <span class="n">notExpired</span><span class="o">.</span><span class="n">run</span><span class="o">((</span><span class="n">passport</span><span class="o">.</span><span class="n">expiration</span><span class="o">,</span> <span class="n">now</span><span class="o">))</span>
      <span class="k">val</span> <span class="n">result2</span> <span class="k">=</span> <span class="n">passportMatchesIdCard</span><span class="o">.</span><span class="n">run</span><span class="o">((</span><span class="n">passport</span><span class="o">,</span> <span class="n">id</span><span class="o">))</span>
      <span class="n">result0</span> <span class="o">&amp;&amp;</span> <span class="n">result1</span> <span class="o">&amp;&amp;</span> <span class="n">result2</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>This leads us to a first best practice to make a DSL composable: <strong>provide binary operators returning their inputs type</strong>:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">A</span>
</code></pre></div><p>This is exactly what we&rsquo;ve done with <code>Result.&amp;&amp;</code> which takes two <code>Result</code>'s (<code>self</code> and <code>that</code>) and returns another <code>Result</code> combining them. This operator  helped us implementing the <code>citizen</code> but we can do better. To simplify the addition of other rules, we should also provide a combinator to <code>Rule</code> so that:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// Pseudo code:
</span><span class="c1"></span><span class="k">val</span> <span class="n">citizen</span> <span class="k">=</span> 
  <span class="n">citizenPassport</span> <span class="o">&amp;&amp;</span> <span class="n">passportNotExpired</span> <span class="o">&amp;&amp;</span> <span class="n">passportMatchesIdCard</span>
</code></pre></div><p>Let&rsquo;s build this step by step. First we need to add the operator in question:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">case</span> <span class="k">class</span> <span class="nc">Rule</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">run</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Result</span><span class="o">)</span> <span class="o">{</span> <span class="n">self</span> <span class="k">=&gt;</span>
  <span class="cm">/* 
</span><span class="cm">   * Combines two rules and returns another one requiring a product 
</span><span class="cm">   * of their input
</span><span class="cm">   */</span>
  <span class="k">def</span> <span class="o">&amp;&amp;[</span><span class="kt">B</span><span class="o">](</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="k">=</span> <span class="nc">Rule</span> <span class="o">{</span>
    <span class="k">case</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">self</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">that</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">b</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>The citizen rule can now be formed like following:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">citizen</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[((</span><span class="kt">Passport</span>, <span class="o">(</span><span class="kt">Date</span>, <span class="kt">Date</span><span class="o">))</span>, <span class="o">(</span><span class="kt">Passport</span>, <span class="kt">IdCard</span><span class="o">))]</span> <span class="k">=</span> 
  <span class="n">citizenPassport</span> <span class="o">&amp;&amp;</span> <span class="n">notExpired</span> <span class="o">&amp;&amp;</span> <span class="n">passportMatchesIdCard</span>
</code></pre></div><p><code>citizen</code>'s type is awkward however and contains many redundancies. Ideally, we&rsquo;d like something closer to:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">citizen</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[(</span><span class="kt">Passport</span>, <span class="kt">Date</span>, <span class="kt">IdCard</span><span class="o">)]</span> <span class="k">=</span> <span class="o">???</span>
</code></pre></div><p>In order to run this rule, we would have to provide a tuple containing the passport, the current date, and a matching id card. These inputs could be then redistributed to the different underlying rules forming the resulting composition. This operator would therefore look like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">def</span> <span class="n">bothWith</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">C</span><span class="o">](</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[</span><span class="kt">B</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">C</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">B</span><span class="o">))</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[</span><span class="kt">C</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</code></pre></div><p>In other words, as long as we know how to decompose an input <code>C</code> into a product of <code>A</code> and <code>B</code>, we can combine two rules taking respectively an <code>A</code> and a <code>B</code>. The implementation happens to be quite straightforward:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">case</span> <span class="k">class</span> <span class="nc">Rule</span><span class="o">[</span><span class="kt">-A</span><span class="o">](</span><span class="n">run</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Result</span><span class="o">)</span> <span class="o">{</span> <span class="n">self</span> <span class="k">=&gt;</span>
  <span class="c1">// ...
</span><span class="c1"></span>  <span class="cm">/*
</span><span class="cm">   * Combines two rules respectively requiring an `A` and a `B`
</span><span class="cm">   * into a rule requiring a `(A, B)`.
</span><span class="cm">   */</span>
  <span class="k">def</span> <span class="n">bothWith</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">C</span><span class="o">](</span>
    <span class="n">that</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
  <span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="kt">C</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">B</span><span class="o">))</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[</span><span class="kt">C</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Rule</span> <span class="o">{</span> <span class="n">c</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="k">=</span> <span class="n">f</span><span class="o">(</span><span class="n">c</span><span class="o">)</span>
    <span class="n">self</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">that</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">b</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>As a matter of fact, <code>&amp;&amp;</code> can be expressed in terms of <code>bothWith</code> making it a <strong>derived operator</strong>:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">case</span> <span class="k">class</span> <span class="nc">Rule</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">run</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Result</span><span class="o">)</span> <span class="o">{</span> <span class="n">self</span> <span class="k">=&gt;</span>
  <span class="cm">/*
</span><span class="cm">   * Alias for `both`
</span><span class="cm">   */</span>
  <span class="k">def</span> <span class="o">&amp;&amp;[</span><span class="kt">B</span><span class="o">](</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="k">=</span>
    <span class="n">both</span><span class="o">(</span><span class="n">that</span><span class="o">)</span>
  
  <span class="cm">/* Alias for `bothWith` provided with the `identity` function */</span>
  <span class="k">def</span> <span class="n">both</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="k">=</span>
    <span class="n">bothWith</span><span class="o">(</span><span class="n">that</span><span class="o">)(</span><span class="n">identity</span><span class="o">)</span>
  
  <span class="cm">/*
</span><span class="cm">   * Combines two rules respectively requiring an `A` and a `B`
</span><span class="cm">   * into a rule requiring a product of A and B.
</span><span class="cm">   */</span>
  <span class="k">def</span> <span class="n">bothWith</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">C</span><span class="o">](</span>
    <span class="n">that</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
  <span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="kt">C</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">B</span><span class="o">))</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[</span><span class="kt">C</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Rule</span> <span class="o">{</span> <span class="n">c</span> <span class="k">=&gt;</span>
    <span class="c1">// As long as we know how to extract `A` et `B` from `C`, 
</span><span class="c1"></span>    <span class="c1">// we can build a `Rule[C]` from a `Rule[A]` and a `Rule[B]`
</span><span class="c1"></span>    <span class="k">val</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="k">=</span> <span class="n">f</span><span class="o">(</span><span class="n">c</span><span class="o">)</span>
    <span class="n">self</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">that</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">b</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p><code>bothWith</code> is one of the typical composition patterns you may come across while writing composable software. It fits well with data-structures being <a href="https://contramap.dev/2020/02/12/variance.html"><strong>invariant</strong> or <strong>contravariant</strong></a> in <code>A</code>, that is which provide functions taking/consuming <code>A</code>'s. <code>bothWith</code>  happens to be the solution required to model the citizen rule:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="cm">/*
</span><span class="cm"> * A citizen must provide a non-expired passport along with a matching
</span><span class="cm"> * id card
</span><span class="cm"> */</span>
<span class="k">val</span> <span class="n">citizen</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[(</span><span class="kt">Date</span>, <span class="kt">Passport</span>, <span class="kt">IdCard</span><span class="o">)]</span> <span class="k">=</span>
  <span class="o">(</span><span class="n">citizenPassport</span> <span class="o">&amp;&amp;</span> <span class="n">notExpired</span><span class="o">)</span>      <span class="c1">// Rule[(Passport, (Date, Date))]
</span><span class="c1"></span>    <span class="o">.</span><span class="n">bothWith</span><span class="o">(</span><span class="n">passportMatchesIdCard</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// Rule[(Passport, IdCard)]
</span><span class="c1"></span>      <span class="k">case</span> <span class="o">(</span><span class="n">now</span><span class="o">,</span> <span class="n">passport</span><span class="o">,</span> <span class="n">idCard</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="o">((</span><span class="n">passport</span><span class="o">,</span> <span class="o">(</span><span class="n">passport</span><span class="o">.</span><span class="n">expiration</span><span class="o">,</span> <span class="n">now</span><span class="o">)),</span> <span class="o">(</span><span class="n">passport</span><span class="o">,</span> <span class="n">idCard</span><span class="o">))</span>
      <span class="c1">//     ^                    ^                      ^
</span><span class="c1"></span>      <span class="c1">// citizenPassport     notExpired          passportMatchesIdCard
</span><span class="c1"></span>    <span class="o">}</span>
</code></pre></div><p>We first combine <code>citizenPassport</code> and <code>notExpired</code> into a <code>Rule[(Passport, (Date, Date))]</code>, then call <code>bothWith</code> to combine the result into a <code>Rule[(Date, Passport, IdCard)]</code> using a function taking the provided input and returning a tuple containing each underlying rule&rsquo;s input. We can proceed the same way to define the foreigner rule (We decomposed the process into more steps for learning purpose):</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="cm">/*
</span><span class="cm"> * A foreigner must provide a non-expired passport and a matching
</span><span class="cm"> * entry permit
</span><span class="cm"> */</span>
<span class="k">val</span> <span class="n">foreigner</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[(</span><span class="kt">Date</span>, <span class="kt">Passport</span>, <span class="kt">EntryPermit</span><span class="o">)]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">step1</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[(</span><span class="kt">Passport</span>, <span class="o">(</span><span class="kt">Date</span>, <span class="kt">Date</span><span class="o">))]</span> <span class="k">=</span> 
    <span class="n">foreignPassport</span> <span class="o">&amp;&amp;</span> <span class="n">notExpired</span>

  <span class="k">val</span> <span class="n">step2</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[(</span><span class="kt">Passport</span>, <span class="kt">EntryPermit</span><span class="o">)]</span>  <span class="k">=</span> 
    <span class="n">passportMatchesEntryPermit</span>

  <span class="n">step1</span><span class="o">.</span><span class="n">bothWith</span><span class="o">(</span><span class="n">step2</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">case</span> <span class="o">(</span><span class="n">now</span><span class="o">,</span> <span class="n">passport</span><span class="o">,</span> <span class="n">permit</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="o">((</span><span class="n">passport</span><span class="o">,</span> <span class="o">(</span><span class="n">passport</span><span class="o">.</span><span class="n">expiration</span><span class="o">,</span> <span class="n">now</span><span class="o">)),</span> <span class="o">(</span><span class="n">passport</span><span class="o">,</span> <span class="n">permit</span><span class="o">))</span>
    <span class="c1">//     ^                   ^                        ^
</span><span class="c1"></span>    <span class="c1">// foreignPassport     notExpired       passportMatchesEntryPermit
</span><span class="c1"></span>  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>We now have almost all the pieces to define the general rule of the game. To do so, we have to compose the <code>citizen</code> with the <code>foreigner</code> so that:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// Pseudo code
</span><span class="c1"></span><span class="k">val</span> <span class="n">visitorRule</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[</span><span class="kt">???</span><span class="o">]</span> <span class="k">=</span> <span class="n">citizen</span> <span class="o">||</span> <span class="n">foreigner</span>
</code></pre></div><p>We don&rsquo;t have any operator for doing such composition yet, but before coding anything let&rsquo;s ask ourselves what the return type of that operator should be. If we think about it, the resulting type should capture the idea that the rule requires one <strong>or</strong> another input. For this reason, <code>Either</code> is a natural choice:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">type</span> <span class="kt">Citizen</span>   <span class="o">=</span> <span class="o">(</span><span class="nc">Date</span><span class="o">,</span> <span class="nc">Passport</span><span class="o">,</span> <span class="nc">IdCard</span><span class="o">)</span>
<span class="k">type</span> <span class="kt">Foreigner</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Date</span><span class="o">,</span> <span class="nc">Passport</span><span class="o">,</span> <span class="nc">EntryPermit</span><span class="o">)</span>
<span class="k">type</span> <span class="kt">||</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span>  <span class="k">=</span> <span class="nc">Either</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span>

<span class="k">val</span> <span class="n">visitorRule</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[</span><span class="kt">Citizen</span> <span class="kt">||</span> <span class="kt">Foreigner</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</code></pre></div><p>Let&rsquo;s now implement the operator needed to do such composition:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">case</span> <span class="k">class</span> <span class="nc">Rule</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">run</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Result</span><span class="o">)</span> <span class="o">{</span> <span class="n">self</span> <span class="k">=&gt;</span>
  <span class="c1">// ...
</span><span class="c1"></span>  <span class="k">def</span> <span class="o">||[</span><span class="kt">B</span><span class="o">](</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]]</span> <span class="k">=</span>
    <span class="nc">Rule</span> <span class="o">{</span> 
      <span class="k">case</span> <span class="nc">Left</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>  <span class="k">=&gt;</span> <span class="n">self</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
      <span class="k">case</span> <span class="nc">Right</span><span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">that</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">b</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>The implementation is pretty straightforward, but the result is not that great:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">type</span> <span class="kt">Citizen</span>   <span class="o">=</span> <span class="o">(</span><span class="nc">Date</span><span class="o">,</span> <span class="nc">Passport</span><span class="o">,</span> <span class="nc">IdCard</span><span class="o">)</span>
<span class="k">type</span> <span class="kt">Foreigner</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Date</span><span class="o">,</span> <span class="nc">Passport</span><span class="o">,</span> <span class="nc">EntryPermit</span><span class="o">)</span>
<span class="k">type</span> <span class="kt">||</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span>  <span class="k">=</span> <span class="nc">Either</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span>

<span class="k">val</span> <span class="n">visitorRule</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[</span><span class="kt">Citizen</span> <span class="kt">||</span> <span class="kt">Foreigner</span><span class="o">]</span> <span class="k">=</span> <span class="n">citizen</span> <span class="o">||</span> <span class="n">foreigner</span>
<span class="cm">/* which is equivalent to
</span><span class="cm">val visitorRule: Rule[
</span><span class="cm">  (Date, Passport, IdCard) || 
</span><span class="cm">  (Date, Passport, EntryPermit)
</span><span class="cm">] = citizen || foreigner
</span><span class="cm">*/</span>
</code></pre></div><p>Just like earlier we have too many redundancies in the resulting type and some refinement is required. Let&rsquo;s implement a more generic version of <code>||</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">case</span> <span class="k">class</span> <span class="nc">Rule</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">run</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Result</span><span class="o">)</span> <span class="o">{</span> <span class="n">self</span> <span class="k">=&gt;</span>
  <span class="cm">/*
</span><span class="cm">   * Combines two rules respectively requiring an `A` and a `B`
</span><span class="cm">   * into a rule requiring either an `A` or a `B`.
</span><span class="cm">   */</span>
  <span class="k">def</span> <span class="n">eitherWith</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">C</span><span class="o">](</span>
    <span class="n">that</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
  <span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="kt">C</span> <span class="o">=&gt;</span> <span class="nc">Either</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[</span><span class="kt">C</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Rule</span> <span class="o">{</span> <span class="n">c</span> <span class="k">=&gt;</span>
      <span class="n">f</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Left</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>  <span class="k">=&gt;</span> <span class="n">self</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
        <span class="k">case</span> <span class="nc">Right</span><span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">that</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">b</span><span class="o">)</span>
      <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>In other words, as long as we know how to convert an input <code>C</code> into an either of <code>A</code> and <code>B</code>, we can combine two rules taking respectively an <code>A</code> and a <code>B</code>. Just like <code>bothWith</code>, <code>eitherWith</code> happens to be a primary operator from which <code>||</code> is derived:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">case</span> <span class="k">class</span> <span class="nc">Rule</span><span class="o">[</span><span class="kt">-A</span><span class="o">](</span><span class="n">run</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Result</span><span class="o">)</span> <span class="o">{</span> <span class="n">self</span> <span class="k">=&gt;</span>
  <span class="cm">/*
</span><span class="cm">   * Alias for `either`
</span><span class="cm">   */</span>
  <span class="k">def</span> <span class="o">||[</span><span class="kt">B</span><span class="o">](</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]]</span> <span class="k">=</span>
    <span class="n">either</span><span class="o">(</span><span class="n">that</span><span class="o">)</span>

  <span class="cm">/*
</span><span class="cm">   * Alias for `eitherWith` with the identity function provided
</span><span class="cm">   */</span>
  <span class="k">def</span> <span class="n">either</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]]</span> <span class="k">=</span>
    <span class="n">eitherWith</span><span class="o">(</span><span class="n">that</span><span class="o">)(</span><span class="n">identity</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div><p><code>eitherWith</code> is another typical composition pattern you may come across while writing composable software. It fits well with data-structures being <a href="https://contramap.dev/2020/02/12/variance.html"><strong>invariant</strong> or <strong>covariant</strong></a> in <code>A</code>, that is which provide functions returning/producing <code>A</code>'s. This new operator happens to be exactly what we need to compose the visitor rule:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="cm">/*
</span><span class="cm"> * A visitor other than a refugee must either:
</span><span class="cm"> * - provide a valid passport and an id card (citizen rule)
</span><span class="cm"> * - or provide a valid passport and an entry permit (foreigner rule)
</span><span class="cm"> */</span>
<span class="k">val</span> <span class="n">visitor</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[(</span><span class="kt">Date</span>, <span class="kt">Passport</span>, <span class="kt">IdCard</span> <span class="kt">||</span> <span class="kt">EntryPermit</span><span class="o">)]</span> <span class="k">=</span>
  <span class="n">citizen</span><span class="o">.</span><span class="n">eitherWith</span><span class="o">(</span><span class="n">foreigner</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">case</span> <span class="o">(</span><span class="n">now</span><span class="o">,</span> <span class="n">passport</span><span class="o">,</span> <span class="nc">Left</span><span class="o">(</span><span class="n">idCard</span><span class="o">))</span>  <span class="k">=&gt;</span> <span class="nc">Left</span><span class="o">((</span><span class="n">now</span><span class="o">,</span> <span class="n">passport</span><span class="o">,</span> <span class="n">idCard</span><span class="o">))</span>
    <span class="k">case</span> <span class="o">(</span><span class="n">now</span><span class="o">,</span> <span class="n">passport</span><span class="o">,</span> <span class="nc">Right</span><span class="o">(</span><span class="n">permit</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="nc">Right</span><span class="o">((</span><span class="n">now</span><span class="o">,</span> <span class="n">passport</span><span class="o">,</span> <span class="n">permit</span><span class="o">))</span>
  <span class="o">}</span>
</code></pre></div><h2 id="sum-and-product-composition">Sum and Product composition<a hidden class="anchor" aria-hidden="true" href="#sum-and-product-composition">#</a></h2>
<p>You may notice a certain similarity between <code>bothWith</code> and <code>eitherWith</code>. This is not surprising, as they both define two kinds of composition patterns respectively known as <strong>product composition</strong> and <strong>sum composition</strong>:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">def</span> <span class="n">bothWith</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">C</span><span class="o">]</span>  <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[</span><span class="kt">B</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">C</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">B</span><span class="o">))</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[</span><span class="kt">C</span><span class="o">]</span> <span class="k">=</span> <span class="cm">/* ... */</span>

<span class="k">def</span> <span class="n">eitherWith</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">C</span><span class="o">](</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[</span><span class="kt">B</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">C</span> <span class="o">=&gt;</span> <span class="n">A</span> <span class="o">||</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[</span><span class="kt">C</span><span class="o">]</span> <span class="k">=</span> <span class="cm">/* ... */</span>
</code></pre></div><p>These two patterns mirror each others in regards to composition, and it&rsquo;s overall a best practice to look for them whenever you write a composable DSL.</p>
<h2 id="fallback-rule">Fallback rule<a hidden class="anchor" aria-hidden="true" href="#fallback-rule">#</a></h2>
<p>In some cases, the game may be aborted under extreme circumstances such as a terrorist attack. Let&rsquo;s see how we could reflect that in our model:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// Pseudo code
</span><span class="c1"></span><span class="k">val</span> <span class="n">game</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[(</span><span class="kt">Passport</span>, <span class="kt">IdCard</span> <span class="kt">||</span> <span class="kt">EntryPermit</span><span class="o">)]</span> <span class="k">=</span>
  <span class="n">visitor</span> <span class="o">+</span> <span class="n">terroristAttack</span>
</code></pre></div><p>First let&rsquo;s think about how <code>terroristAttack</code> should be represented. Overall, this rule does not care about the document provided. So technically it could take any document, and as an output always return <code>Aborted</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="nc">Rule</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">Aborted</span><span class="o">)</span>
</code></pre></div><p>Secondly, combining <code>terroristAttack</code> with another rule should not change the type of the latter. So the combination of <code>terroristAttack</code> with <code>visitorRule</code> should have the same type than <code>visitorRule</code>. This can be implemented in different ways, using <strong>contravariance</strong> for example:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// Note the - in front of A
</span><span class="c1"></span><span class="k">case</span> <span class="k">class</span> <span class="nc">Rule</span><span class="o">[</span><span class="kt">-A</span><span class="o">](</span><span class="n">run</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Result</span><span class="o">)</span> <span class="o">{</span> <span class="cm">/* ... */</span> <span class="o">}</span>
<span class="k">val</span> <span class="n">terroristAttack</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Rule</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">Aborted</span><span class="o">)</span>
</code></pre></div><p>Let&rsquo;s now encode the operator combining <code>visitor</code> with <code>terroristAttack</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">case</span> <span class="k">class</span> <span class="nc">Rule</span><span class="o">[</span><span class="kt">-A</span><span class="o">](</span><span class="n">run</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Result</span><span class="o">)</span> <span class="o">{</span> <span class="n">self</span> <span class="k">=&gt;</span>
  <span class="k">def</span> <span class="n">orElse</span><span class="o">[</span><span class="kt">A0</span> <span class="k">&lt;:</span> <span class="kt">A</span><span class="o">](</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[</span><span class="kt">A0</span><span class="o">])</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[</span><span class="kt">A0</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Rule</span> <span class="o">{</span> <span class="n">a</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="n">r0</span> <span class="k">=</span> <span class="n">self</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
      <span class="k">val</span> <span class="n">r1</span> <span class="k">=</span> <span class="n">that</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
      <span class="o">???</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>To finish this implementation, we&rsquo;ll need to provide a way to combine <code>Result</code> so that <code>r0</code> falls back to <code>r1</code> whenever it&rsquo;s not <code>Approved</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Result</span> <span class="o">{</span> <span class="n">self</span> <span class="k">=&gt;</span>
  <span class="c1">// ...
</span><span class="c1"></span>  <span class="k">def</span> <span class="o">||(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Result</span><span class="o">)</span><span class="k">:</span> <span class="kt">Result</span> <span class="o">=</span>
    <span class="n">self</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">Detained</span> <span class="o">|</span> <span class="nc">Denied</span> <span class="k">=&gt;</span> <span class="n">that</span>
      <span class="k">case</span> <span class="k">_</span>                 <span class="k">=&gt;</span> <span class="n">self</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>Using this new combinator, we can now finish <code>orElse</code>'s implementation:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">case</span> <span class="k">class</span> <span class="nc">Rule</span><span class="o">[</span><span class="kt">-A</span><span class="o">](</span><span class="n">run</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Result</span><span class="o">)</span> <span class="o">{</span> <span class="n">self</span> <span class="k">=&gt;</span>
  <span class="c1">// ...
</span><span class="c1"></span>  <span class="k">def</span> <span class="n">orElse</span><span class="o">[</span><span class="kt">A0</span> <span class="k">&lt;:</span> <span class="kt">A</span><span class="o">](</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[</span><span class="kt">A0</span><span class="o">])</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[</span><span class="kt">A0</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Rule</span> <span class="o">{</span> <span class="n">a</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="n">r0</span> <span class="k">=</span> <span class="n">self</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
      <span class="k">val</span> <span class="n">r1</span> <span class="k">=</span> <span class="n">that</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
      <span class="n">r0</span> <span class="o">||</span> <span class="n">r1</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>As you can guess, this is another typical composition pattern that can be generalized like following:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">case</span> <span class="k">class</span> <span class="nc">Rule</span><span class="o">[</span><span class="kt">-A</span><span class="o">](</span><span class="n">run</span><span class="k">:</span> <span class="kt">Context</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Result</span><span class="o">)</span> <span class="o">{</span> <span class="n">self</span> <span class="k">=&gt;</span>
  <span class="c1">// ...
</span><span class="c1"></span>  <span class="k">def</span> <span class="n">orElse</span><span class="o">[</span><span class="kt">A0</span> <span class="k">&lt;:</span> <span class="kt">A</span><span class="o">](</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[</span><span class="kt">A0</span><span class="o">])</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[</span><span class="kt">A0</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">zipWith</span><span class="o">(</span><span class="n">that</span><span class="o">)(</span><span class="k">_</span> <span class="o">||</span> <span class="k">_</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">zipWith</span><span class="o">[</span><span class="kt">A0</span> <span class="k">&lt;:</span> <span class="kt">A</span><span class="o">](</span>
    <span class="n">that</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[</span><span class="kt">A0</span><span class="o">]</span>
  <span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">Result</span><span class="o">,</span> <span class="kt">Result</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Result</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[</span><span class="kt">A0</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Rule</span> <span class="o">{</span> <span class="n">ctx</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="n">r0</span> <span class="k">=</span> <span class="n">self</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">ctx</span><span class="o">)</span>
      <span class="k">val</span> <span class="n">r1</span> <span class="k">=</span> <span class="n">that</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">ctx</span><span class="o">)</span>
      <span class="n">f</span><span class="o">(</span><span class="n">r0</span><span class="o">,</span> <span class="n">r1</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>This implementation of <code>zipWith</code> is specific to our domain. Generally, <code>zipWith</code> looks more like the following:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">case</span> <span class="k">class</span> <span class="nc">Data</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="o">{</span> <span class="n">self</span> <span class="k">=&gt;</span>
  <span class="c1">// ...
</span><span class="c1"></span>  <span class="k">def</span> <span class="n">zip</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">that</span><span class="k">:</span> <span class="kt">Data</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Data</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="k">=</span>
    <span class="n">zipWith</span><span class="o">(</span><span class="n">that</span><span class="o">)((</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">))</span>

  <span class="k">def</span> <span class="n">zipWith</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">C</span><span class="o">](</span>
    <span class="n">that</span><span class="k">:</span> <span class="kt">Data</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
  <span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">C</span><span class="o">)</span><span class="k">:</span> <span class="kt">Data</span><span class="o">[</span><span class="kt">C</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Data</span> <span class="o">{</span> <span class="n">ctx</span> <span class="k">=&gt;</span>
      <span class="n">f</span><span class="o">(</span><span class="n">self</span><span class="o">.</span><span class="n">value</span><span class="o">,</span> <span class="n">that</span><span class="o">.</span><span class="n">value</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>In our example however, having a <code>Rule</code> returning a product of <code>Result</code> (that is a <code>(Result, Result)</code>) is unsound from a domain perspective. <code>zipWith</code> is a <strong>covariant analogue</strong> of <code>bothWith</code>. It is mostly found in invariant and covariant data-structures and is probably one of the most common composition pattern. With this new tool in our belt, we can finish the description of the game&rsquo;s rules:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">game</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[(</span><span class="kt">Passport</span>, <span class="kt">IdCard</span> <span class="kt">||</span> <span class="kt">EntryPermit</span><span class="o">)]</span> <span class="k">=</span>
  <span class="n">visitor</span><span class="o">.</span><span class="n">orElse</span><span class="o">(</span><span class="n">terroristAttack</span><span class="o">)</span>
</code></pre></div><p>Hold on, what about the refugee rule? Thanks to our new combinators, introducing that one is a piece of cake:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">type</span> <span class="kt">Refugee</span> <span class="o">=</span> <span class="o">(</span><span class="nc">GrantOfAsylum</span><span class="o">,</span> <span class="nc">FingerPrints</span><span class="o">)</span>
<span class="k">type</span> <span class="kt">Visitor</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Date</span><span class="o">,</span> <span class="nc">Passport</span><span class="o">,</span> <span class="nc">IdCard</span> <span class="o">||</span> <span class="nc">EntryPermit</span><span class="o">)</span>

<span class="k">val</span> <span class="n">game</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[</span><span class="kt">Visitor</span> <span class="kt">||</span> <span class="kt">Refugee</span><span class="o">]</span> <span class="k">=</span>
  <span class="o">(</span><span class="n">visitor</span> <span class="o">||</span> <span class="n">refugee</span><span class="o">).</span><span class="n">orElse</span><span class="o">(</span><span class="n">terroristAttack</span><span class="o">)</span>
</code></pre></div><h2 id="going-further">Going further<a hidden class="anchor" aria-hidden="true" href="#going-further">#</a></h2>
<p>Is that it? Well, actually there&rsquo;s more we can talk about regarding this topic. So far we represented every terms of our DSL using a simple function:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">A</span> <span class="k">=&gt;</span> <span class="nc">Result</span>
</code></pre></div><p>In other words, the evaluation of the solution is embedded in the resulting data-structure. This happened to be pretty useful but there are some drawbacks:</p>
<ul>
<li><strong>Testability</strong>: the solution being a function, there is no way to inspect its content without executing it. If the function has unexpected side-effects, we would lose the ability to reason about it locally.</li>
<li><strong>Optimization</strong>: rules can currently only be composed using function composition. This prevents us to perform any optimization in the way these functions are called and run.</li>
<li><strong>Extendability</strong>: if we had to provide another way to evaluate the solution, we would have to change every operator (<code>bothWith</code>, <code>eitherWith</code>, <code>zipWith</code>) and primitive (<code>notExpired</code>, <code>refugee</code>, <code>passportMatchesIdCard</code>, &hellip;) provided by this DSL.</li>
</ul>
<p>Another way to encode this domain would be to solely rely on pure data-structures. Instead of embedding the evaluation function, we can put that one aside and represent the output of each operator using a date-structure:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">object</span> <span class="nc">DSL</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">||</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Either</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span>

  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Always</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">result</span><span class="k">:</span> <span class="kt">Result</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">DSL</span><span class="o">[</span><span class="kt">Any</span>, <span class="kt">F</span><span class="o">]</span>

  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">OrElse</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span>
    <span class="n">left</span><span class="k">:</span> <span class="kt">DSL</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">F</span><span class="o">],</span> 
    <span class="n">right</span><span class="k">:</span> <span class="kt">DSL</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">F</span><span class="o">]</span>
  <span class="o">)</span> <span class="k">extends</span>   <span class="nc">SL</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">F</span><span class="o">]</span>

  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">BothWith</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">C</span>, <span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span>
    <span class="n">left</span><span class="k">:</span> <span class="kt">DSL</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">F</span><span class="o">],</span>
    <span class="n">right</span><span class="k">:</span> <span class="kt">DSL</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">F</span><span class="o">],</span>
    <span class="n">f</span><span class="k">:</span> <span class="kt">C</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">B</span><span class="o">)</span>
  <span class="o">)</span> <span class="k">extends</span> <span class="nc">DSL</span><span class="o">[</span><span class="kt">C</span>, <span class="kt">F</span><span class="o">]</span>

  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">EitherWith</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">C</span>, <span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span>
    <span class="n">left</span><span class="k">:</span> <span class="kt">DSL</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">F</span><span class="o">],</span>
    <span class="n">right</span><span class="k">:</span> <span class="kt">DSL</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">F</span><span class="o">],</span>
    <span class="n">f</span><span class="k">:</span> <span class="kt">C</span> <span class="o">=&gt;</span> <span class="n">A</span> <span class="o">||</span> <span class="n">B</span>
  <span class="o">)</span> <span class="k">extends</span> <span class="nc">DSL</span><span class="o">[</span><span class="kt">C</span>, <span class="kt">F</span><span class="o">]</span>

  <span class="k">case</span> <span class="k">class</span> <span class="nc">Pure</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">DSL</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">F</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div><p>But what is that <code>F[_]</code>? <code>F[_]</code> is a way to compose this dsl with another one, like <code>Rule</code> for example:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Rule</span><span class="o">[</span><span class="kt">-A</span><span class="o">]</span>
<span class="nc">object</span> <span class="nc">Rule</span> <span class="o">{</span>
  <span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">CitizenPassport</span> <span class="k">extends</span> <span class="nc">Rule</span><span class="o">[</span><span class="kt">Passport</span><span class="o">]</span>
  <span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">ForeignPassport</span> <span class="k">extends</span> <span class="nc">Rule</span><span class="o">[</span><span class="kt">Passport</span><span class="o">]</span>

  <span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">Refugee</span>
    <span class="k">extends</span> <span class="nc">Rule</span><span class="o">[(</span><span class="kt">GrantOfAsylum</span>, <span class="kt">FingerPrints</span><span class="o">)]</span>

  <span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">PassportMatchesIdCard</span> 
    <span class="k">extends</span> <span class="nc">Rule</span><span class="o">[(</span><span class="kt">Passport</span>, <span class="kt">IdCard</span><span class="o">)]</span>

  <span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">PassportMatchesEntryPermit</span> 
    <span class="k">extends</span> <span class="nc">Rule</span><span class="o">[(</span><span class="kt">Passport</span>, <span class="kt">EntryPermit</span><span class="o">)]</span>

  <span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">NotExpired</span>      <span class="k">extends</span> <span class="nc">Rule</span><span class="o">[(</span><span class="kt">Date</span>, <span class="kt">Date</span><span class="o">)]</span>
  <span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">TerroristAttack</span> <span class="k">extends</span> <span class="nc">Rule</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div><p>The combination of these two DSLs would look like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">type</span> <span class="kt">RuleF</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">DSL</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">Rule</span><span class="o">]</span>

<span class="k">val</span> <span class="n">notExpired</span><span class="k">:</span> <span class="kt">RuleF</span><span class="o">[(</span><span class="kt">Date</span>, <span class="kt">Date</span><span class="o">)]</span>  <span class="k">=</span> <span class="nc">Pure</span><span class="o">(</span><span class="nc">NotExpired</span><span class="o">)</span>
<span class="k">val</span> <span class="n">citizenPassport</span><span class="k">:</span> <span class="kt">RuleF</span><span class="o">[</span><span class="kt">Passport</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Pure</span><span class="o">(</span><span class="nc">CitizenPassport</span><span class="o">)</span>
<span class="k">val</span> <span class="n">foreignPassport</span><span class="k">:</span> <span class="kt">RuleF</span><span class="o">[</span><span class="kt">Passport</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Pure</span><span class="o">(</span><span class="nc">ForeignPassport</span><span class="o">)</span>
<span class="k">val</span> <span class="n">terroristAttack</span><span class="k">:</span> <span class="kt">RuleF</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span>      <span class="k">=</span> <span class="nc">Pure</span><span class="o">(</span><span class="nc">TerroristAttack</span><span class="o">)</span>

<span class="k">val</span> <span class="n">refugee</span><span class="k">:</span> <span class="kt">RuleF</span><span class="o">[(</span><span class="kt">GrantOfAsylum</span>, <span class="kt">FingerPrints</span><span class="o">)]</span> <span class="k">=</span>
  <span class="nc">Pure</span><span class="o">(</span><span class="nc">Refugee</span><span class="o">)</span>

<span class="k">val</span> <span class="n">passportMatchesIdCard</span><span class="k">:</span> <span class="kt">RuleF</span><span class="o">[(</span><span class="kt">Passport</span>, <span class="kt">IdCard</span><span class="o">)]</span> <span class="k">=</span>
  <span class="nc">Pure</span><span class="o">(</span><span class="nc">PassportMatchesIdCard</span><span class="o">)</span>

<span class="k">val</span> <span class="n">passportMatchesEntryPermit</span><span class="k">:</span> <span class="kt">RuleF</span><span class="o">[(</span><span class="kt">Passport</span>, <span class="kt">EntryPermit</span><span class="o">)]</span> <span class="k">=</span>
  <span class="nc">Pure</span><span class="o">(</span><span class="nc">PassportMatchesEntryPermit</span><span class="o">)</span>
</code></pre></div><p>What about the combinators? These actually do not need to change that much:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">DSL</span><span class="o">[</span><span class="kt">-A</span>, <span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span> <span class="n">self</span> <span class="k">=&gt;</span>
  <span class="k">def</span> <span class="o">&amp;&amp;[</span><span class="kt">B</span><span class="o">](</span><span class="n">that</span><span class="k">:</span> <span class="kt">DSL</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">DSL</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)</span>, <span class="kt">F</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">bothWith</span><span class="o">(</span><span class="n">that</span><span class="o">)(</span><span class="n">identity</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">eitherWith</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">C</span><span class="o">](</span>
    <span class="n">that</span><span class="k">:</span> <span class="kt">DSL</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">F</span><span class="o">]</span>
  <span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="kt">C</span> <span class="o">=&gt;</span> <span class="nc">Either</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">DSL</span><span class="o">[</span><span class="kt">C</span>, <span class="kt">F</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">EitherWith</span><span class="o">(</span><span class="n">self</span><span class="o">,</span> <span class="n">that</span><span class="o">,</span> <span class="n">f</span><span class="o">)</span>

  <span class="k">def</span> <span class="o">||[</span><span class="kt">B</span><span class="o">](</span><span class="n">that</span><span class="k">:</span> <span class="kt">DSL</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">DSL</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span>, <span class="kt">F</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">eitherWith</span><span class="o">(</span><span class="n">that</span><span class="o">)(</span><span class="n">identity</span><span class="o">)</span>
  
  <span class="k">def</span> <span class="n">bothWith</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">C</span><span class="o">](</span><span class="n">that</span><span class="k">:</span> <span class="kt">DSL</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">F</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">C</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">B</span><span class="o">))</span><span class="k">:</span> <span class="kt">DSL</span><span class="o">[</span><span class="kt">C</span>, <span class="kt">F</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">BothWith</span><span class="o">(</span><span class="n">self</span><span class="o">,</span> <span class="n">that</span><span class="o">,</span> <span class="n">f</span><span class="o">)</span>
  
  <span class="k">def</span> <span class="n">orElse</span><span class="o">[</span><span class="kt">A0</span> <span class="k">&lt;:</span> <span class="kt">A</span><span class="o">](</span><span class="n">that</span><span class="k">:</span> <span class="kt">DSL</span><span class="o">[</span><span class="kt">A0</span>, <span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">DSL</span><span class="o">[</span><span class="kt">A0</span>, <span class="kt">F</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">OrElse</span><span class="o">(</span><span class="n">self</span><span class="o">,</span> <span class="n">that</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div><p>and the remaining rules can be left as is, as they are expressed only using existing solutions (<code>refugee</code>, <code>citizenPassport</code>&hellip;) and operators (<code>&amp;&amp;</code>, <code>||</code>. <code>eitherWith</code>, &hellip;):</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">game</span><span class="k">:</span> <span class="kt">RuleF</span><span class="o">[</span><span class="kt">Visitor</span> <span class="kt">||</span> <span class="kt">Refugee</span><span class="o">]</span> <span class="k">=</span>
  <span class="o">(</span><span class="n">visitor</span> <span class="o">||</span> <span class="n">refugee</span><span class="o">).</span><span class="n">orElse</span><span class="o">(</span><span class="n">terroristAttack</span><span class="o">)</span>
</code></pre></div><p>Once we have the right data-structure, we need a function to evaluate it:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">def</span> <span class="n">run</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">rule</span><span class="k">:</span> <span class="kt">DSL</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">Rule</span><span class="o">])(</span><span class="n">ctx</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Result</span> <span class="o">=</span>
  <span class="n">rule</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Always</span><span class="o">(</span><span class="n">r</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">r</span>

    <span class="k">case</span> <span class="n">oe</span><span class="k">:</span> <span class="kt">OrElse</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">Rule</span><span class="o">]</span> <span class="k">=&gt;</span>
      <span class="n">run</span><span class="o">(</span><span class="n">oe</span><span class="o">.</span><span class="n">left</span><span class="o">)(</span><span class="n">ctx</span><span class="o">)</span> <span class="o">||</span> <span class="n">run</span><span class="o">(</span><span class="n">oe</span><span class="o">.</span><span class="n">right</span><span class="o">)(</span><span class="n">ctx</span><span class="o">)</span>

    <span class="k">case</span> <span class="n">bw</span><span class="k">:</span> <span class="kt">BothWith</span><span class="o">[</span><span class="kt">a</span>, <span class="kt">b</span>, <span class="kt">A</span>, <span class="kt">Rule</span><span class="o">]</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="k">=</span> <span class="n">bw</span><span class="o">.</span><span class="n">f</span><span class="o">(</span><span class="n">ctx</span><span class="o">)</span>
      <span class="n">run</span><span class="o">(</span><span class="n">bw</span><span class="o">.</span><span class="n">left</span><span class="o">)(</span><span class="n">a</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">run</span><span class="o">(</span><span class="n">bw</span><span class="o">.</span><span class="n">right</span><span class="o">)(</span><span class="n">b</span><span class="o">)</span>

    <span class="k">case</span> <span class="n">ew</span><span class="k">:</span> <span class="kt">EitherWith</span><span class="o">[</span><span class="kt">a</span>, <span class="kt">b</span>, <span class="kt">A</span>, <span class="kt">Rule</span><span class="o">]</span> <span class="k">=&gt;</span>
      <span class="n">ew</span><span class="o">.</span><span class="n">f</span><span class="o">(</span><span class="n">ctx</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Left</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>  <span class="k">=&gt;</span> <span class="n">run</span><span class="o">(</span><span class="n">ew</span><span class="o">.</span><span class="n">left</span><span class="o">)(</span><span class="n">a</span><span class="o">)</span>
        <span class="k">case</span> <span class="nc">Right</span><span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">run</span><span class="o">(</span><span class="n">ew</span><span class="o">.</span><span class="n">right</span><span class="o">)(</span><span class="n">b</span><span class="o">)</span>
      <span class="o">}</span>

    <span class="k">case</span> <span class="nc">Pure</span><span class="o">(</span><span class="n">fa</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">eval</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">ctx</span><span class="o">)</span>
  <span class="o">}</span>

<span class="k">def</span> <span class="n">eval</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">rule</span><span class="k">:</span> <span class="kt">Rule</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Result</span> <span class="o">=</span>
  <span class="n">rule</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">CitizenPassport</span> <span class="k">=&gt;</span> <span class="k">if</span> <span class="o">(</span><span class="n">value</span><span class="o">.</span><span class="n">foreign</span><span class="o">)</span> <span class="nc">Denied</span> <span class="k">else</span> <span class="nc">Approved</span>
    <span class="k">case</span> <span class="nc">ForeignPassport</span> <span class="k">=&gt;</span> <span class="k">if</span> <span class="o">(</span><span class="n">value</span><span class="o">.</span><span class="n">foreign</span><span class="o">)</span> <span class="nc">Approved</span> <span class="k">else</span> <span class="nc">Denied</span>

    <span class="k">case</span> <span class="nc">NotExpired</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="k">=</span> <span class="n">value</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="o">)</span> <span class="nc">Approved</span> <span class="k">else</span> <span class="nc">Denied</span>

    <span class="k">case</span> <span class="nc">PassportMatchesIdCard</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="o">(</span><span class="n">passport</span><span class="o">,</span> <span class="n">idCard</span><span class="o">)</span> <span class="k">=</span> <span class="n">value</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">passport</span><span class="o">.</span><span class="n">uid</span> <span class="o">==</span> <span class="n">idCard</span><span class="o">.</span><span class="n">uid</span><span class="o">)</span> <span class="nc">Approved</span> <span class="k">else</span> <span class="nc">Detained</span>

    <span class="k">case</span> <span class="nc">PassportMatchesEntryPermit</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="o">(</span><span class="n">passport</span><span class="o">,</span> <span class="n">permit</span><span class="o">)</span> <span class="k">=</span> <span class="n">value</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">passport</span><span class="o">.</span><span class="n">uid</span> <span class="o">==</span> <span class="n">permit</span><span class="o">.</span><span class="n">uid</span><span class="o">)</span> <span class="nc">Approved</span> <span class="k">else</span> <span class="nc">Detained</span>

    <span class="k">case</span> <span class="nc">Refugee</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="o">(</span><span class="n">grant</span><span class="o">,</span> <span class="n">prints</span><span class="o">)</span> <span class="k">=</span> <span class="n">value</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">grant</span><span class="o">.</span><span class="n">fingerPrints</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="n">prints</span><span class="o">.</span><span class="n">data</span><span class="o">)</span> <span class="nc">Approved</span> <span class="k">else</span> <span class="nc">Detained</span>

    <span class="k">case</span> <span class="nc">TerroristAttack</span> <span class="k">=&gt;</span> <span class="nc">Aborted</span>
  <span class="o">}</span>
</code></pre></div><p>Note that we use two functions here, one for each DSL. Secondly, these are not stack-safe and would crash if recursive rules are created. We can fix this using techniques such as Trampolining, but this will be the topic of another post.</p>
<h2 id="taking-some-steps-back">Taking some steps back<a hidden class="anchor" aria-hidden="true" href="#taking-some-steps-back">#</a></h2>
<p>No matter the approach, we ended up using three types of block:</p>
<ul>
<li><strong>primitives</strong>: which model simple solutions (<code>notExpired</code>, <code>CitizenPassport</code>&hellip;)</li>
<li><strong>constructors</strong>: which build solutions from existing solutions (<code>citizen</code>, <code>foreigner</code>, &hellip;)</li>
<li><strong>operators</strong>: which transform/combine solutions into other solutions (<code>eitherWith</code>, <code>bothWith</code>, &hellip;).</li>
</ul>
<p>As explained by <a href="https://github.com/jdegoes">John DeGoes</a> and <a href="https://ruurtjan.com/">Ruurtjan Pul</a> in this <a href="https://medium.com/bigdatarepublic/writing-functional-dsls-for-business-domains-1bccc5d3f62b">post</a>, there are some best practices regarding how <strong>primitives</strong> should be designed:</p>
<blockquote>
<ul>
<li>Composable: to build complex solutions using simple components;<!-- raw HTML omitted --></li>
<li>Orthogonal: such that there’s no overlap in capabilities between primitives;<!-- raw HTML omitted --></li>
<li>Minimal: in terms of the number of primitives.<!-- raw HTML omitted --></li>
</ul>
</blockquote>
<p>Secondly, in terms of encoding, we first embedded the evaluation function within the resulting data-structure. Later on we decided to pull it apart and use pure data-structures only. The first type of encoding is referred to as an <strong>executable encoding</strong>. It implies that <em>every constructor and operators of the model is expressed in terms of its execution</em>. It&rsquo;s defined in opposition with the <strong>declarative encoding</strong> used in the second implementation, <em>where every <strong>constructor</strong> and <strong>operator</strong> of the model is expressed as pure data in a recursive tree structure</em>.</p>
<p>Both types of encoding have their trade-offs. With an <strong>executable encoding</strong>, adding new constructors and operators is easy, as they are all defined using the same function, while adding new evaluation functions is harder, as it potentially requires changing every operator and constructors of the DSL. It&rsquo;s the exact opposite with a <strong>declarative encoding</strong> where adding new evaluation functions is easy (as these are defined separately), but adding new constructors and operators is painful. You may recognize the <a href="https://en.wikipedia.org/wiki/Expression_problem">expression problem</a> here which is the very reason why Object Oriented Programming and Functional Programming exist.</p>
<p>Moreover, both encodings tend to perform better in specific cases. The <strong>declarative encoding</strong> will usually be a better fit for use-cases involving optimizations (thanks to inspections capabilities) and/or persistence (thanks to pure data-structures), while the <strong>executable encoding</strong> is a better choice when it comes to improve legacy code. If you would like to go further, it is highly suggested to read the <a href="https://degoes.net/articles/functional-design">following post</a>, which inspired this article a lot.</p>
<h2 id="wrapping-up">Wrapping Up<a hidden class="anchor" aria-hidden="true" href="#wrapping-up">#</a></h2>
<p>This post was rather long, so here is a quick recap:</p>
<ul>
<li>To improve composition, define <strong>primitives</strong>, <strong>constructors</strong> and <strong>operators</strong> using the best practices described above</li>
<li>Provide these with <strong>binary operators</strong> to compose them forever (<code>bothWith</code>, <code>eitherWith</code>, <code>zipWith</code>, &hellip;)</li>
<li>Use the adequate encoding (executable/declarative) depending on your use-case but keep in mind that a <strong>declarative encoding</strong> suits a greenfield project better.</li>
</ul>
<p>The code of this post is all available <a href="https://github.com/FrancisToth/francistoth.github.io/blob/master/src/main/scala/dev/contramap/composition/PapersPlease.scala">here</a>. Thank you for reading, and thanks to <a href="https://www.patreon.com/jdegoes/posts">John De Goes for all his time teaching us writing better code</a>.</p>

</div>
  <footer class="post-footer">



<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share Composition on twitter"
        href="https://twitter.com/intent/tweet/?text=Composition&amp;url=https%3a%2f%2fwww.contramap.dev%2fposts%2f2020-09-22-composition%2f&amp;hashtags=">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Composition on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fwww.contramap.dev%2fposts%2f2020-09-22-composition%2f&amp;title=Composition&amp;summary=Composition&amp;source=https%3a%2f%2fwww.contramap.dev%2fposts%2f2020-09-22-composition%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Composition on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fwww.contramap.dev%2fposts%2f2020-09-22-composition%2f&title=Composition">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Composition on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.contramap.dev%2fposts%2f2020-09-22-composition%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Composition on whatsapp"
        href="https://api.whatsapp.com/send?text=Composition%20-%20https%3a%2f%2fwww.contramap.dev%2fposts%2f2020-09-22-composition%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Composition on telegram"
        href="https://telegram.me/share/url?text=Composition&amp;url=https%3a%2f%2fwww.contramap.dev%2fposts%2f2020-09-22-composition%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

  </footer>
</article>
    </main><footer class="footer">
    <span>&copy; 2020 <a href="https://www.contramap.dev/">Francis Toth / Contramap</a></span>
    <span>&middot;</span>
    <span>Powered by <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a></span>
    <span>&middot;</span>
    <span>Theme <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a></span>
</footer>
<button class="top-link" id="top-link" type="button" aria-label="go to top" title="Go to Top (Alt + G)" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6">
        <path d="M12 6H0l6-6z" /></svg>
</button>



<script defer src="https://www.contramap.dev/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js" integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w="
    onload="hljs.initHighlightingOnLoad();"></script>
<script>
    window.onload = function () {
        if (localStorage.getItem("menu-scroll-position")) {
            document.getElementById('menu').scrollLeft = localStorage.getItem("menu-scroll-position");
        }
    }
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };
    mybutton.onclick = function () {
        document.body.scrollTop = 0;
        document.documentElement.scrollTop = 0;
        window.location.hash = ''
    }

    function menu_on_scroll() {
        localStorage.setItem("menu-scroll-position", document.getElementById('menu').scrollLeft);
    }

</script>

</body>

</html>
